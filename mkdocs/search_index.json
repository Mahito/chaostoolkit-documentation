{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to the Chaos Toolkit Project\n\u00b6\n\n\nThe Chaos Toolkit is a free, open source project that enables you to create and\napply Chaos Experiments to various types of infrastructure, platforms and\napplications.\n\n\nRunning experiments is as simple as:\n\n\n$ chaos run an-experiment.json\n\n\n\n\nThis takes the description of your experiment, runs it and ourput a reports\nto share with your team.\n\n\nMission\n\u00b6\n\n\nThe Chaos Toolkit aims at simplifying your journey through the\n\nPrinciples of Chaos Engineering\n and more generally considers that\nyou should embrace continuously observing and poking your system to empower your\nteam in face of adversity.\n\n\nCome join the Chaos Toolkit community\n\u00b6\n\n\nThe Chaos Toolkit is an \nopen source project\n and strives on a diverse and\ncooperative community. We welcome input and discussions on the project itself\nbut also on the \nPrinciples of Chaos Engineering\n in general.\n\n\nPlease \njoin us\n!",
            "title": "Introduction"
        },
        {
            "location": "/#welcome-to-the-chaos-toolkit-project",
            "text": "The Chaos Toolkit is a free, open source project that enables you to create and\napply Chaos Experiments to various types of infrastructure, platforms and\napplications.  Running experiments is as simple as:  $ chaos run an-experiment.json  This takes the description of your experiment, runs it and ourput a reports\nto share with your team.",
            "title": "Welcome to the Chaos Toolkit Project"
        },
        {
            "location": "/#mission",
            "text": "The Chaos Toolkit aims at simplifying your journey through the Principles of Chaos Engineering  and more generally considers that\nyou should embrace continuously observing and poking your system to empower your\nteam in face of adversity.",
            "title": "Mission"
        },
        {
            "location": "/#come-join-the-chaos-toolkit-community",
            "text": "The Chaos Toolkit is an  open source project  and strives on a diverse and\ncooperative community. We welcome input and discussions on the project itself\nbut also on the  Principles of Chaos Engineering  in general.  Please  join us !",
            "title": "Come join the Chaos Toolkit community"
        },
        {
            "location": "/overview/concepts/",
            "text": "Chaos Engeering Concepts in the Chaos Toolkit\n\u00b6\n\n\nIf you haven\u2019t already, we strongly recommend reading the fantastic \nChaos Engineering\n book from O\u2019Reilly Media. This book will give you some fantastic background on the whole Chaos Engineering discipline, and it\u2019s free!\n\n\nChaos Engineering is a discipline that allows you to surface weaknesses, and eventually build confidence, in complex and often distributed systems. \n\n\nThe Chaos Toolkit aims to give you the simplest experience for writing and running your own Chaos Engineering experiments. The main concepts are all expressed in an experiment definition, of which the following is an example from the \nChaos Toolkit Samples\n project:\n\n\n{\n\n    \n\"title\"\n:\n \n\"System is resilient to provider's failures\"\n,\n\n    \n\"description\"\n:\n \n\"Can our consumer survive gracefully a provider's failure?\"\n,\n\n    \n\"target-layers\"\n:\n \n{\n\n        \n\"platforms\"\n:\n \n[\n\n            \n{\n \n\"key\"\n:\n \n\"kubernetes\"\n \n}\n\n        \n],\n\n        \n\"applications\"\n:\n \n[\n\n            \n{\n \n\"key\"\n:\n \n\"spring\"\n \n}\n\n        \n]\n\n    \n},\n\n    \n\"method\"\n:\n \n[\n\n        \n{\n\n            \n\"title\"\n:\n \n\"Checking our system is healthy\"\n,\n\n            \n\"probes\"\n:\n \n{\n\n                \n\"steady\"\n:\n \n{\n\n                    \n\"layer\"\n:\n \n\"kubernetes\"\n,\n\n                    \n\"name\"\n:\n \n\"microservices-all-healthy\"\n\n                \n}\n\n            \n}\n\n        \n},\n\n        \n{\n\n            \n\"title\"\n:\n \n\"Killing the provider abruptly\"\n,\n\n            \n\"action\"\n:\n \n{\n\n                \n\"layer\"\n:\n \n\"kubernetes\"\n,\n\n                \n\"name\"\n:\n \n\"kill-microservice\"\n,\n\n                \n\"parameters\"\n:\n \n{\n\n                    \n\"name\"\n:\n \n\"my-provider-service\"\n\n                \n},\n\n                \n\"pauses\"\n:\n \n{\n\n                    \n\"after\"\n:\n \n10\n\n                \n}\n\n            \n},\n\n            \n\"probes\"\n:\n \n{\n\n                \n\"steady\"\n:\n \n{\n\n                    \n\"layer\"\n:\n \n\"kubernetes\"\n,\n\n                    \n\"name\"\n:\n \n\"microservice-available-and-healthy\"\n,\n\n                    \n\"parameters\"\n:\n \n{\n\n                        \n\"name\"\n:\n \n\"my-provider-service\"\n\n                    \n}\n\n                \n},\n\n                \n\"close\"\n:\n \n{\n\n                    \n\"layer\"\n:\n \n\"kubernetes\"\n,\n\n                    \n\"name\"\n:\n \n\"microservice-is-not-available\"\n,\n\n                    \n\"parameters\"\n:\n \n{\n\n                        \n\"name\"\n:\n \n\"my-provider-service\"\n\n                    \n}\n\n                \n}\n\n            \n}\n\n        \n},\n\n        \n{\n\n            \n\"title\"\n:\n \n\"Consumer should not be impacted by provider's failure\"\n,\n\n            \n\"probes\"\n:\n \n{\n\n                \n\"steady\"\n:\n \n{\n\n                    \n\"layer\"\n:\n \n\"spring\"\n,\n\n                    \n\"name\"\n:\n \n\"endpoint-should-respond-ok\"\n,\n\n                    \n\"parameters\"\n:\n \n{\n\n                        \n\"url\"\n:\n \n\"http://192.168.99.100:32220/invokeConsumedService\"\n\n                    \n}\n\n                \n}\n\n            \n}\n\n        \n}\n\n    \n]\n\n\n}\n\n\n\n\n\nThe key concepts of the Chaos Toolkit are \nExperiments\n, \nTarget Layers\n and the experiment\u2019s \nMethod\n. The \nMethod\n contains a combination of \nProbes\n and \nActions\n.\n\n\nExperiments\n\u00b6\n\n\nA Chaos Toolkit experiment is provided in a single file and is currently expressed in JSON.\n\n\nTarget Layers\n\u00b6\n\n\nA target layer is in fact a collection of extensions that allow the experiment to target specific systems to apply the experiment to. Out of the box support for Kubernetes (Platform layer) and Spring (Application Layer) is currently provided and we intend to extend this out rapidly into other technologies.\n\n\nWhen you execute an experiment\u2019s probes and actions it is against a particular target layer.\n\n\nMethod\n\u00b6\n\n\nAn experiment\u2019s activities are contained within its \nMethod\n block.\n\n\nProbes\n\u00b6\n\n\nA probe is a way of observing a particular set of conditions in the system that is undergoing experimentation.\n\n\nActions\n\u00b6\n\n\nAn action is a particular activity that needs to be enacted on the system under experimentation.",
            "title": "Concepts"
        },
        {
            "location": "/overview/concepts/#chaos-engeering-concepts-in-the-chaos-toolkit",
            "text": "If you haven\u2019t already, we strongly recommend reading the fantastic  Chaos Engineering  book from O\u2019Reilly Media. This book will give you some fantastic background on the whole Chaos Engineering discipline, and it\u2019s free!  Chaos Engineering is a discipline that allows you to surface weaknesses, and eventually build confidence, in complex and often distributed systems.   The Chaos Toolkit aims to give you the simplest experience for writing and running your own Chaos Engineering experiments. The main concepts are all expressed in an experiment definition, of which the following is an example from the  Chaos Toolkit Samples  project:  { \n     \"title\" :   \"System is resilient to provider's failures\" , \n     \"description\" :   \"Can our consumer survive gracefully a provider's failure?\" , \n     \"target-layers\" :   { \n         \"platforms\" :   [ \n             {   \"key\" :   \"kubernetes\"   } \n         ], \n         \"applications\" :   [ \n             {   \"key\" :   \"spring\"   } \n         ] \n     }, \n     \"method\" :   [ \n         { \n             \"title\" :   \"Checking our system is healthy\" , \n             \"probes\" :   { \n                 \"steady\" :   { \n                     \"layer\" :   \"kubernetes\" , \n                     \"name\" :   \"microservices-all-healthy\" \n                 } \n             } \n         }, \n         { \n             \"title\" :   \"Killing the provider abruptly\" , \n             \"action\" :   { \n                 \"layer\" :   \"kubernetes\" , \n                 \"name\" :   \"kill-microservice\" , \n                 \"parameters\" :   { \n                     \"name\" :   \"my-provider-service\" \n                 }, \n                 \"pauses\" :   { \n                     \"after\" :   10 \n                 } \n             }, \n             \"probes\" :   { \n                 \"steady\" :   { \n                     \"layer\" :   \"kubernetes\" , \n                     \"name\" :   \"microservice-available-and-healthy\" , \n                     \"parameters\" :   { \n                         \"name\" :   \"my-provider-service\" \n                     } \n                 }, \n                 \"close\" :   { \n                     \"layer\" :   \"kubernetes\" , \n                     \"name\" :   \"microservice-is-not-available\" , \n                     \"parameters\" :   { \n                         \"name\" :   \"my-provider-service\" \n                     } \n                 } \n             } \n         }, \n         { \n             \"title\" :   \"Consumer should not be impacted by provider's failure\" , \n             \"probes\" :   { \n                 \"steady\" :   { \n                     \"layer\" :   \"spring\" , \n                     \"name\" :   \"endpoint-should-respond-ok\" , \n                     \"parameters\" :   { \n                         \"url\" :   \"http://192.168.99.100:32220/invokeConsumedService\" \n                     } \n                 } \n             } \n         } \n     ]  }   The key concepts of the Chaos Toolkit are  Experiments ,  Target Layers  and the experiment\u2019s  Method . The  Method  contains a combination of  Probes  and  Actions .",
            "title": "Chaos Engeering Concepts in the Chaos Toolkit"
        },
        {
            "location": "/overview/concepts/#experiments",
            "text": "A Chaos Toolkit experiment is provided in a single file and is currently expressed in JSON.",
            "title": "Experiments"
        },
        {
            "location": "/overview/concepts/#target-layers",
            "text": "A target layer is in fact a collection of extensions that allow the experiment to target specific systems to apply the experiment to. Out of the box support for Kubernetes (Platform layer) and Spring (Application Layer) is currently provided and we intend to extend this out rapidly into other technologies.  When you execute an experiment\u2019s probes and actions it is against a particular target layer.",
            "title": "Target Layers"
        },
        {
            "location": "/overview/concepts/#method",
            "text": "An experiment\u2019s activities are contained within its  Method  block.",
            "title": "Method"
        },
        {
            "location": "/overview/concepts/#probes",
            "text": "A probe is a way of observing a particular set of conditions in the system that is undergoing experimentation.",
            "title": "Probes"
        },
        {
            "location": "/overview/concepts/#actions",
            "text": "An action is a particular activity that needs to be enacted on the system under experimentation.",
            "title": "Actions"
        },
        {
            "location": "/faq/",
            "text": "FAQ\n\u00b6\n\n\nWhat is the Chaos Toolkit?\n\u00b6\n\n\nIt is an open-source software that runs an experiment against your system to\nconfirm or infirm an hypothesis. Colloquially this refers to the \nC\nhaos Engineering Principles\n.\n\n\nWhy do I need to run experiments?\n\u00b6\n\n\nSystems do not live in a vacuum, they are subjected to real world events, some\nexpected and tolerated, others considered as attacks. Waiting for those\nconditions arise does not give the time your team needs to handle, learn and\nadapt to the situation at hand.\n\n\nIn many countries, fire alarm tests are conducted at random in offices so \npeople learn how to react well for the benefit of everyone. Software systems\nshould go through the same exercises. The Chaos Toolkit hopes to make it \nsimple and safe to run experiments like these.\n\n\nEngaging the team and organisation\n\u00b6\n\n\nChaos engineering aims at making you learn from your system. This is not a lone\nactivity but a team, potentially the whole organisation, endeavour.\n\n\nIndeed, a hypothesis you could set the hypothesis \u201cwe have been hacked and lost\nusers sensitive data, we should issue a statement we are doing everything to\nfix the problem within 15mn\u201d. This experiment is not really technical but\norganisational: is the chain of information and command working effectively?\n\n\nIsn\u2019t it testing?\n\u00b6\n\n\nWe do not consider testing and chaos engineering to conflict with each other.\nThey both provide useful and actionable feedback. Where they differ is their\nobjective. \n\n\nTesting is a process that aims at telling you if your application,\nwithin controlled boundaries, runs as expected. \n\n\nChaos engineering is a displine of posing a hypothesis before collecting\nevidence to reject or accept that hypothesis.\n\n\nA test is sort of an hypothesis in its own. The difference lies in the\nexperimental approach of the chaos engineering displine. It asks a question and\nthen observe the system to see if we can answer that question positively or\nnegatively.\n\n\nIncidentaly, some forms of testing are not too dissmilar to a chaos engineering\nexperiment. Say for instance, you run a load testing. Your hypothesis is that\nresponse time should not be impacted under load. By running your experiment,\nyou may answer that question.\n\n\nIsn\u2019t it monitoring?\n\u00b6\n\n\nMuch like chaos engineering is not testing, it should not be conflated with\nmonitoring. If anything, chaos engineering strives for good monitoring for it\nhelps observing the system during the experiment.\n\n\nMonitoring surfaces, informs and may even react to confitions in your system.\nBut this is not answering a question like chaos engineering tries to do.\n\n\nWhy a toolkit?\n\u00b6\n\n\nCurrently, running experiments is not an easy task because the ecosystem is \nstill fairly young. Complex cases have been demonstrated at large corporations\nsuch as Netflix or LinkedIn. Tools such as \nChAP\n or \nSimoorg\n\nare powerful but quite involved.\n\n\nThe Chaos Toolkit aims at providing a more straightforward initial user\nexperience to gain confidence in doing Chaos Engineering experiments. The\nsimpler it gets the greater our cognitive capacity to understand what is going\non.\n\n\nUltimately, the Chaos Toolkit should lead you on the path to using richer tools\nsuch as those cited above.\n\n\nWhat does the Chaos Toolkit do?\n\u00b6\n\n\nThe Chaos Toolkit user-interface is a command line that takes a JSON-encoded\nfile describing the experiment to run. It consists of a sequence of activities\nthe toolkit executes in order to produce a final report. \n\n\nThe activities are of two kinds. Probes observe the system at various point of\nthe experiment. Actions interact with the system to change its state. Usually\nthe action represents the hypothesis you are trying to learn from.\n\n\nWho is behind the Chaos Toolkit?\n\u00b6\n\n\nThe effort was initiated by \nRuss Miles\n and\n\nSylvain Hellegouarch\n, two engineers passionate about fluidity in\ncomplex systems. However, their vision is really to build a\n\nstrong community\n of engineer experiences to feedback\ninto the Chaos Toolkit.\n\n\nWhat is the license of the Chaos Toolkit?\n\u00b6\n\n\nApache 2.0\n.\n\n\nHow can I contribute?\n\u00b6\n\n\nThe Chaos Toolkit welcomes contributors! To help the project, please go to\nthe right project on \nGitHub\n and create an issue. If you feel like it,\ndo not hesitate to fork the repository, make a change and submit a \npull-request to the upstream project for review.",
            "title": "FAQ"
        },
        {
            "location": "/faq/#faq",
            "text": "",
            "title": "FAQ"
        },
        {
            "location": "/faq/#what-is-the-chaos-toolkit",
            "text": "It is an open-source software that runs an experiment against your system to\nconfirm or infirm an hypothesis. Colloquially this refers to the \nC haos Engineering Principles .",
            "title": "What is the Chaos Toolkit?"
        },
        {
            "location": "/faq/#why-do-i-need-to-run-experiments",
            "text": "Systems do not live in a vacuum, they are subjected to real world events, some\nexpected and tolerated, others considered as attacks. Waiting for those\nconditions arise does not give the time your team needs to handle, learn and\nadapt to the situation at hand.  In many countries, fire alarm tests are conducted at random in offices so \npeople learn how to react well for the benefit of everyone. Software systems\nshould go through the same exercises. The Chaos Toolkit hopes to make it \nsimple and safe to run experiments like these.",
            "title": "Why do I need to run experiments?"
        },
        {
            "location": "/faq/#engaging-the-team-and-organisation",
            "text": "Chaos engineering aims at making you learn from your system. This is not a lone\nactivity but a team, potentially the whole organisation, endeavour.  Indeed, a hypothesis you could set the hypothesis \u201cwe have been hacked and lost\nusers sensitive data, we should issue a statement we are doing everything to\nfix the problem within 15mn\u201d. This experiment is not really technical but\norganisational: is the chain of information and command working effectively?",
            "title": "Engaging the team and organisation"
        },
        {
            "location": "/faq/#isnt-it-testing",
            "text": "We do not consider testing and chaos engineering to conflict with each other.\nThey both provide useful and actionable feedback. Where they differ is their\nobjective.   Testing is a process that aims at telling you if your application,\nwithin controlled boundaries, runs as expected.   Chaos engineering is a displine of posing a hypothesis before collecting\nevidence to reject or accept that hypothesis.  A test is sort of an hypothesis in its own. The difference lies in the\nexperimental approach of the chaos engineering displine. It asks a question and\nthen observe the system to see if we can answer that question positively or\nnegatively.  Incidentaly, some forms of testing are not too dissmilar to a chaos engineering\nexperiment. Say for instance, you run a load testing. Your hypothesis is that\nresponse time should not be impacted under load. By running your experiment,\nyou may answer that question.",
            "title": "Isn't it testing?"
        },
        {
            "location": "/faq/#isnt-it-monitoring",
            "text": "Much like chaos engineering is not testing, it should not be conflated with\nmonitoring. If anything, chaos engineering strives for good monitoring for it\nhelps observing the system during the experiment.  Monitoring surfaces, informs and may even react to confitions in your system.\nBut this is not answering a question like chaos engineering tries to do.",
            "title": "Isn't it monitoring?"
        },
        {
            "location": "/faq/#why-a-toolkit",
            "text": "Currently, running experiments is not an easy task because the ecosystem is \nstill fairly young. Complex cases have been demonstrated at large corporations\nsuch as Netflix or LinkedIn. Tools such as  ChAP  or  Simoorg \nare powerful but quite involved.  The Chaos Toolkit aims at providing a more straightforward initial user\nexperience to gain confidence in doing Chaos Engineering experiments. The\nsimpler it gets the greater our cognitive capacity to understand what is going\non.  Ultimately, the Chaos Toolkit should lead you on the path to using richer tools\nsuch as those cited above.",
            "title": "Why a toolkit?"
        },
        {
            "location": "/faq/#what-does-the-chaos-toolkit-do",
            "text": "The Chaos Toolkit user-interface is a command line that takes a JSON-encoded\nfile describing the experiment to run. It consists of a sequence of activities\nthe toolkit executes in order to produce a final report.   The activities are of two kinds. Probes observe the system at various point of\nthe experiment. Actions interact with the system to change its state. Usually\nthe action represents the hypothesis you are trying to learn from.",
            "title": "What does the Chaos Toolkit do?"
        },
        {
            "location": "/faq/#who-is-behind-the-chaos-toolkit",
            "text": "The effort was initiated by  Russ Miles  and Sylvain Hellegouarch , two engineers passionate about fluidity in\ncomplex systems. However, their vision is really to build a strong community  of engineer experiences to feedback\ninto the Chaos Toolkit.",
            "title": "Who is behind the Chaos Toolkit?"
        },
        {
            "location": "/faq/#what-is-the-license-of-the-chaos-toolkit",
            "text": "Apache 2.0 .",
            "title": "What is the license of the Chaos Toolkit?"
        },
        {
            "location": "/faq/#how-can-i-contribute",
            "text": "The Chaos Toolkit welcomes contributors! To help the project, please go to\nthe right project on  GitHub  and create an issue. If you feel like it,\ndo not hesitate to fork the repository, make a change and submit a \npull-request to the upstream project for review.",
            "title": "How can I contribute?"
        },
        {
            "location": "/usage/install/",
            "text": "How to Install the Chaos Toolkit\n\u00b6\n\n\nYou can either install the chaostoolkit command line or run it from a container.\n\n\nThe former expects \nPython 3.5+\n properly setup on your machine while\nthe latter expects a tool implementing the \nOCI 1.0 specification\n, \nsuch as \nDocker\n or \nrunc\n.\n\n\nPython Requirements\n\u00b6\n\n\nThe \nchaostoolkit CLI\n is implemented in Python 3 and this require a\nworking Python installation to run. It officially supports Python 3.5+. It has\nonly been tested against \nCPython\n.\n\n\nInstall Python\n\u00b6\n\n\nInstall Python for your system:\n\n\nOn MacOSX:\n\n\n$ brew install python3\n\n\n\n\nOn Debian/Ubuntu:\n\n\n$ sudo apt-get install python3 python3-venv\n\n\n\n\nOn CentOS:\n\n\n$ sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm\n$ sudo yum -y install python35u\n\n\n\n\nNotice, on CentOS, the Python 3.5 binary is named \npython3.5\n rather than\n\npython3\n as other systems.\n\n\nOn Windows:\n\n\nDownload the latest binary installer\n from the Python website.\n\n\nCreate a virtual environment\n\u00b6\n\n\nDependencies can be installed for your system via its package management but,\nmore likely, you will want to install them yourself in a local virtual\nenvironment.\n\n\n$ python3 -m venv ~/.venvs/chaostk\n\n\n\n\nMake sure to always activate your virtual environment before using it:\n\n\n$ source  ~/.venvs/chaostk/bin/activate\n\n\n\n\n\n\nTip\n\n\nYou may want to use \nvirtualenvwrapper\n to make this process much nicer.\n\n\n\n\nInstall the CLI\n\u00b6\n\n\nInstall \nchaostoolkit\n in the virtual environment as follows:\n\n\n(chaostk) $ pip install chaostoolkit\n\n\n\n\nYou can verify the command was installed by running:\n\n\n(chaostk) $ chaos --version\n\n\n\n\nDownload the container image\n\u00b6\n\n\nYou can run the chaostoolkit from a container rather than install it.\n\n\nFor instance, using \nDocker\n, you can pull the\n\nchaostoolkit image\n:\n\n\n$ docker pull chaostoolkit/chaostoolkit",
            "title": "Install"
        },
        {
            "location": "/usage/install/#how-to-install-the-chaos-toolkit",
            "text": "You can either install the chaostoolkit command line or run it from a container.  The former expects  Python 3.5+  properly setup on your machine while\nthe latter expects a tool implementing the  OCI 1.0 specification , \nsuch as  Docker  or  runc .",
            "title": "How to Install the Chaos Toolkit"
        },
        {
            "location": "/usage/install/#python-requirements",
            "text": "The  chaostoolkit CLI  is implemented in Python 3 and this require a\nworking Python installation to run. It officially supports Python 3.5+. It has\nonly been tested against  CPython .",
            "title": "Python Requirements"
        },
        {
            "location": "/usage/install/#install-python",
            "text": "Install Python for your system:  On MacOSX:  $ brew install python3  On Debian/Ubuntu:  $ sudo apt-get install python3 python3-venv  On CentOS:  $ sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm\n$ sudo yum -y install python35u  Notice, on CentOS, the Python 3.5 binary is named  python3.5  rather than python3  as other systems.  On Windows:  Download the latest binary installer  from the Python website.",
            "title": "Install Python"
        },
        {
            "location": "/usage/install/#create-a-virtual-environment",
            "text": "Dependencies can be installed for your system via its package management but,\nmore likely, you will want to install them yourself in a local virtual\nenvironment.  $ python3 -m venv ~/.venvs/chaostk  Make sure to always activate your virtual environment before using it:  $ source  ~/.venvs/chaostk/bin/activate   Tip  You may want to use  virtualenvwrapper  to make this process much nicer.",
            "title": "Create a virtual environment"
        },
        {
            "location": "/usage/install/#install-the-cli",
            "text": "Install  chaostoolkit  in the virtual environment as follows:  (chaostk) $ pip install chaostoolkit  You can verify the command was installed by running:  (chaostk) $ chaos --version",
            "title": "Install the CLI"
        },
        {
            "location": "/usage/install/#download-the-container-image",
            "text": "You can run the chaostoolkit from a container rather than install it.  For instance, using  Docker , you can pull the chaostoolkit image :  $ docker pull chaostoolkit/chaostoolkit",
            "title": "Download the container image"
        },
        {
            "location": "/usage/upgrade/",
            "text": "How to Upgrade the Chaos Toolkit\n\u00b6\n\n\nUsing pip\n\u00b6\n\n\nYou can update your Chaos Toolkit installation as follows:\n\n\n(chaostk) $ pip install -U chaostoolkit\n\n\n\n\nUsing a container image\n\u00b6\n\n\nIf you downloaded the Docker image of the toolkit, you can pull it again:\n\n\n$ docker pull chaostoolkit/chaostoolkit",
            "title": "Upgrade"
        },
        {
            "location": "/usage/upgrade/#how-to-upgrade-the-chaos-toolkit",
            "text": "",
            "title": "How to Upgrade the Chaos Toolkit"
        },
        {
            "location": "/usage/upgrade/#using-pip",
            "text": "You can update your Chaos Toolkit installation as follows:  (chaostk) $ pip install -U chaostoolkit",
            "title": "Using pip"
        },
        {
            "location": "/usage/upgrade/#using-a-container-image",
            "text": "If you downloaded the Docker image of the toolkit, you can pull it again:  $ docker pull chaostoolkit/chaostoolkit",
            "title": "Using a container image"
        },
        {
            "location": "/usage/running/",
            "text": "Running the Chaos Toolkit\n\u00b6\n\n\nThe \nchaostoolkit\n CLI will display commands it supports as follows:\n\n\n(chaostk) $ chaos --help\n\n\n\n\n\n\nActivate the Python virtual environment\n\n\nIf you run the Chaos Toolkit directly, rather than using a container,\nalways ensure you have activated the virtual environment so that it can\nbe found along its dependencies:\n\n\n$ source ~/.venvs/chaostk/bin/activate\n(chaostk) $\n\n\n\n\n\n\nExecuting a plan\n\u00b6\n\n\nThe main function of the \nchaostoolkit\n CLI is to execute the plan you\ndeclared. This is done as follows:\n\n\n(chaostk) $ chaos run my-plan.json\n\n\n\n\nchaostoolkit\n will log all the steps it follows from your plan.\n\n\nIf you run the command from a container:\n\n\n$ docker run --rm -it \\\n    --user `id -u` \\\n    -v $HOME/.kube:/root/.kube \\\n    -v $HOME/.minikube:$HOME/.minikube \\\n    -v `pwd`:/tmp/chaos \\\n    chaostoolkit/chaostoolkit run /tmp/chaos/my-plan.json\n\n\n\n\nThis command snippet shows how you would share your \nKubernetes\n\n and \nminikube\n configurations if your experiment targets Kubernetes.\n\n\n\n\nBattery not included in the container\n\n\nDepending on your experiment, running as a container may not be as simple\nas it looks because all the extensions (Python packages, commands to run,\nconfig files\u2026) are not included in the base image.",
            "title": "Run"
        },
        {
            "location": "/usage/running/#running-the-chaos-toolkit",
            "text": "The  chaostoolkit  CLI will display commands it supports as follows:  (chaostk) $ chaos --help   Activate the Python virtual environment  If you run the Chaos Toolkit directly, rather than using a container,\nalways ensure you have activated the virtual environment so that it can\nbe found along its dependencies:  $ source ~/.venvs/chaostk/bin/activate\n(chaostk) $",
            "title": "Running the Chaos Toolkit"
        },
        {
            "location": "/usage/running/#executing-a-plan",
            "text": "The main function of the  chaostoolkit  CLI is to execute the plan you\ndeclared. This is done as follows:  (chaostk) $ chaos run my-plan.json  chaostoolkit  will log all the steps it follows from your plan.  If you run the command from a container:  $ docker run --rm -it \\\n    --user `id -u` \\\n    -v $HOME/.kube:/root/.kube \\\n    -v $HOME/.minikube:$HOME/.minikube \\\n    -v `pwd`:/tmp/chaos \\\n    chaostoolkit/chaostoolkit run /tmp/chaos/my-plan.json  This command snippet shows how you would share your  Kubernetes \n and  minikube  configurations if your experiment targets Kubernetes.   Battery not included in the container  Depending on your experiment, running as a container may not be as simple\nas it looks because all the extensions (Python packages, commands to run,\nconfig files\u2026) are not included in the base image.",
            "title": "Executing a plan"
        },
        {
            "location": "/usage/tutorial/",
            "text": "Create your first Experiment\n\u00b6\n\n\nThis walkthrough will drive you the basics of writing your very first\nexperiment.\n\n\nDefine your hypothesis\n\u00b6\n\n\nBefore you start writing code, you need to define your hypthesis. What is it\nyou are trying to confirm or infirm?\n\n\nThere are various ways to come up with an hypothesis:\n\n\n\n\na real scenario that you and your team did not fully get a chance to learn\n  from while in emergency mode. Retrospective sessions in agile teams may be\n  a great starting point\n\n\nimpact mapping\n is another strategy to let the team bubble\n  up relevant scenarios\n\n\nyour existing disaster recovery playbooks could be turned into experiments\n  that are actively applied against the system\n\n\n\n\nHowever you come up with your hypothesis, make sure you can analyse the \nresult so keep its scope and objective simple and comprehensible.\n\n\nGet the requirements\n\u00b6\n\n\nOften, an experiment involves fairly specific access to observe or interact\nwith the system. Make sure you can gather the right permissions and people on\nboard.\n\n\nA first experiment: a missing file\n\u00b6\n\n\nLet\u2019s say we have a service that polls a local file every second to see if new\ncontent was added for processing. Development made the assumption the file\nwould always be there and did not write a failure code path.\n\n\nOur hypothesis is that the service should not break but simply try again until\nthe file comes back. \n\n\nOur experiment should try that hypothesis to see where our system stands.\n\n\nBelow is the code of our service as it is now:\n\n\n# -*- coding: utf-8 -*-\n\n\nfrom\n \ndatetime\n \nimport\n \ndatetime\n\n\nimport\n \nio\n\n\nimport\n \ntime\n\n\nimport\n \nthreading\n\n\nfrom\n \nwsgiref.validate\n \nimport\n \nvalidator\n\n\nfrom\n \nwsgiref.simple_server\n \nimport\n \nmake_server\n\n\n\nEXCHANGE_FILE\n \n=\n \n\"./exchange.dat\"\n\n\n\n\ndef\n \nupdate_exchange_file\n():\n\n    \n\"\"\"\n\n\n    Writes the current date and time every 10 seconds into the exchange file.\n\n\n\n    The file is created if it does not exist.\n\n\n    \"\"\"\n\n    \nprint\n(\n\"Will update to exchange file\"\n)\n\n    \nwhile\n \nTrue\n:\n\n        \nwith\n \nio\n.\nopen\n(\nEXCHANGE_FILE\n,\n \n\"w\"\n)\n \nas\n \nf\n:\n\n            \nf\n.\nwrite\n(\ndatetime\n.\nnow\n()\n.\nisoformat\n())\n\n        \ntime\n.\nsleep\n(\n10\n)\n\n\n\n\ndef\n \nsimple_app\n(\nenviron\n,\n \nstart_response\n):\n\n    \n\"\"\"\n\n\n    Read the content of the exchange file and return it.\n\n\n    \"\"\"\n\n    \nstart_response\n(\n'200 OK'\n,\n \n[(\n'Content-type'\n,\n \n'text/plain'\n)])\n\n    \nwith\n \nio\n.\nopen\n(\nEXCHANGE_FILE\n)\n \nas\n \nf\n:\n\n        \nreturn\n \n[\nf\n.\nread\n()\n.\nencode\n(\n'utf-8'\n)]\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nt\n \n=\n \nthreading\n.\nThread\n(\ntarget\n=\nupdate_exchange_file\n)\n\n    \nt\n.\nstart\n()\n\n\n    \nhttpd\n \n=\n \nmake_server\n(\n''\n,\n \n8080\n,\n \nsimple_app\n)\n\n    \nprint\n(\n\"Listening on port 8080....\"\n)\n\n\n    \ntry\n:\n\n        \nhttpd\n.\nserve_forever\n()\n\n    \nexcept\n \nKeyboardInterrupt\n:\n\n        \nhttpd\n.\nshutdown\n()\n\n        \nt\n.\njoin\n(\ntimeout\n=\n1\n)\n\n\n\n\n\nThe code is simple for the purpose of this tutorial. As you can see, we declare\na simple function that reads a file and returns its content when called.\n\n\nA background thread function writes the current data to that file every 10\nseconds.\n\n\nNotice how we do not check the file exists before reading it soo it is likely\nthis can fail.\n\n\nRun this service from another terminal as follows:\n\n\n$ python service.py\n\n\n\n\n\n\nTip\n\n\nThe \ncode of this tutorial\n can be found along side this\ndocumentation.\n\n\n\n\nDeclare your experiment\n\u00b6\n\n\nBelow is the experiment for our hypothesis:\n\n\n{\n\n    \n\"title\"\n:\n \n\"Does our service tolerate the loss of its exchange file?\"\n,\n\n    \n\"description\"\n:\n \n\"Our srevice reads data from an exchange file, can it support that file disappearing?\"\n,\n\n    \n\"method\"\n:\n \n[\n\n        \n{\n\n            \n\"title\"\n:\n \n\"Is the file currently where it ought to be?\"\n,\n\n            \n\"probes\"\n:\n \n{\n\n                \n\"steady\"\n:\n \n{\n\n                    \n\"title\"\n:\n \n\"Looking for data file\"\n,\n\n                    \n\"layer\"\n:\n \n\"application\"\n,\n\n                    \n\"type\"\n:\n \n\"python\"\n,\n\n                    \n\"module\"\n:\n \n\"os.path\"\n,\n\n                    \n\"func\"\n:\n \n\"exists\"\n,\n\n                    \n\"arguments\"\n:\n \n{\n\n                        \n\"path\"\n:\n \n\"./exchange.dat\"\n\n                    \n}\n\n                \n}\n\n            \n}\n\n        \n},\n\n        \n{\n\n            \n\"title\"\n:\n \n\"Next, we pretend that configuration is gone\"\n,\n\n            \n\"action\"\n:\n \n{\n\n                \n\"title\"\n:\n \n\"Move the configuration to a different name\"\n,\n\n                \n\"layer\"\n:\n \n\"application\"\n,\n\n                \n\"type\"\n:\n \n\"python\"\n,\n\n                \n\"module\"\n:\n \n\"os\"\n,\n\n                \n\"func\"\n:\n \n\"rename\"\n,\n\n                \n\"arguments\"\n:\n \n{\n\n                    \n\"src\"\n:\n \n\"./exchange.dat\"\n,\n\n                    \n\"dst\"\n:\n \n\"./exchange.dat.old\"\n\n                \n}\n\n            \n}\n\n        \n},\n\n        \n{\n\n            \n\"title\"\n:\n \n\"Our service should not break\"\n,\n\n            \n\"probes\"\n:\n \n{\n\n                \n\"steady\"\n:\n \n{\n\n                    \n\"title\"\n:\n \n\"Calling our service\"\n,\n\n                    \n\"layer\"\n:\n \n\"application\"\n,\n\n                    \n\"type\"\n:\n \n\"http\"\n,\n\n                    \n\"url\"\n:\n \n\"http://localhost:8080/\"\n\n                \n}\n\n            \n}\n\n        \n}\n\n    \n]\n\n\n}\n\n\n\n\n\nThi experiment shows the bricks of encoding your experiment with Chaos Toolkit.\nOnce you have provided various metadata, you tell the chaos Toolkit the\nactivitites it ought to play for us.\n\n\nUsually we start with a probe that tells us the steady state of our system. In\nthis case, we simply ensure the exchange file exists. That tells us the\nservice has its expectation met.\n\n\nNext, we create the conditions of our hypothesis by pretending our file does not\nexist any longer by renaming it.\n\n\nFinally, we query our service over HTTP and expect a response that does not\nindicate the service is unexpectedly broken.\n\n\nAn experiment is made of any numbering of those activities - probes and actions.\nNote that an action can also have its own probes for a specific inspection\nbefore and after the action was applied.\n\n\nThe steady probe and the action are implemented by using Python functions while\nthe last probe performs a HTTP call on your behalf. Please review the\n\ndocumentation\n for other supported implementations.\n\n\nRun your experiment\n\u00b6\n\n\nTo run the experiment, use the \nchaostoolkit\n CLI as follows:\n\n\n$ chaos run experiment.json\n\n[\n2017\n-10-12 \n10\n:17:42 INFO\n]\n Running experiment: Does our service tolerate the loss of its exchange file?\n\n[\n2017\n-10-12 \n10\n:17:42 INFO\n]\n Loading secrets...\n\n[\n2017\n-10-12 \n10\n:17:42 INFO\n]\n Steady State: Looking \nfor\n data file\n\n[\n2017\n-10-12 \n10\n:17:42 INFO\n]\n Steady State succeeded\n\n[\n2017\n-10-12 \n10\n:17:42 INFO\n]\n Action: Move the configuration to a different name\n\n[\n2017\n-10-12 \n10\n:17:42 INFO\n]\n Action succeeded\n\n[\n2017\n-10-12 \n10\n:17:42 INFO\n]\n Steady State: Calling our service\n\n[\n2017\n-10-12 \n10\n:17:42 ERROR\n]\n Steady State failed: A server error occurred.  Please contact the administrator.\n\n[\n2017\n-10-12 \n10\n:17:42 INFO\n]\n Experiment is now \ncomplete\n\n\n\n\n\nNotice the error towards the end, it tells us the service failed with an\nunexpected error.\n\n\nAt this stage, you need to pause and analyse the results of this experiment\nto decide what to do next.\n\n\nFix your service\n\u00b6\n\n\nWhen we ran our service, it broke because the file was not found when read.\nFixing it can take various aspects, we could ensure the file can never be\nremoved through permissions or locking. Or we could also tolerate such \nfailure but let the service return a more appropriate error message in that\ncase.\n\n\nThis is how we are going to fix it in this tutorial:\n\n\n# -*- coding: utf-8 -*-\n\n\nfrom\n \ndatetime\n \nimport\n \ndatetime\n\n\nimport\n \nio\n\n\nimport\n \nos.path\n\n\nimport\n \ntime\n\n\nimport\n \nthreading\n\n\nfrom\n \nwsgiref.validate\n \nimport\n \nvalidator\n\n\nfrom\n \nwsgiref.simple_server\n \nimport\n \nmake_server\n\n\n\nEXCHANGE_FILE\n \n=\n \n\"./exchange.dat\"\n\n\n\n\ndef\n \nupdate_exchange_file\n():\n\n    \n\"\"\"\n\n\n    Writes the current date and time every 10 seconds into the exchange file.\n\n\n\n    The file is created if it does not exist.\n\n\n    \"\"\"\n\n    \nprint\n(\n\"Will update to exchange file\"\n)\n\n    \nwhile\n \nTrue\n:\n\n        \nwith\n \nio\n.\nopen\n(\nEXCHANGE_FILE\n,\n \n\"w\"\n)\n \nas\n \nf\n:\n\n            \nf\n.\nwrite\n(\ndatetime\n.\nnow\n()\n.\nisoformat\n())\n\n        \ntime\n.\nsleep\n(\n10\n)\n\n\n\n\ndef\n \nsimple_app\n(\nenviron\n,\n \nstart_response\n):\n\n    \n\"\"\"\n\n\n    Read the content of the exchange file and return it.\n\n\n    \"\"\"\n\n    \nif\n \nnot\n \nos\n.\npath\n.\nexists\n(\nEXCHANGE_FILE\n):\n\n        \nstart_response\n(\n\n            \n'503 Service Unavailable'\n,\n\n            \n[(\n'Content-type'\n,\n \n'text/plain'\n)]\n\n        \n)\n\n        \nreturn\n \n[\nb\n'Exchange file is not ready'\n]\n\n\n    \nstart_response\n(\n'200 OK'\n,\n \n[(\n'Content-type'\n,\n \n'text/plain'\n)])\n\n    \nwith\n \nio\n.\nopen\n(\nEXCHANGE_FILE\n)\n \nas\n \nf\n:\n\n        \nreturn\n \n[\nf\n.\nread\n()\n.\nencode\n(\n'utf-8'\n)]\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nt\n \n=\n \nthreading\n.\nThread\n(\ntarget\n=\nupdate_exchange_file\n)\n\n    \nt\n.\nstart\n()\n\n\n    \nhttpd\n \n=\n \nmake_server\n(\n''\n,\n \n8080\n,\n \nsimple_app\n)\n\n    \nprint\n(\n\"Listening on port 8080....\"\n)\n\n\n    \ntry\n:\n\n        \nhttpd\n.\nserve_forever\n()\n\n    \nexcept\n \nKeyboardInterrupt\n:\n\n        \nhttpd\n.\nshutdown\n()\n\n        \nt\n.\njoin\n(\ntimeout\n=\n1\n)\n\n\n\n\n\nThe service looks very similar but notice how we check the file indeed exists\nbefore reading it. When it does not exist, we return a more useful \n[503 Service Unavailable][503] error that a consumer could interpret as\n\u201ctry again later\u201d.\n\n\nNote, that we understand a race condition may happen between the time we\nchecked for the path and the time we read content at that location. We keep\nit easy for the benefit of this tutorial.\n\n\nRun your experiment again\n\u00b6\n\n\nLet\u2019s run again our experiment now that we have fixed and restart our service:\n\n\n$ chaos run experiment.json\n\n[\n2017\n-10-12 \n10\n:18:09 INFO\n]\n Running experiment: Does our service tolerate the loss of its exchange file?\n\n[\n2017\n-10-12 \n10\n:18:09 INFO\n]\n Loading secrets...\n\n[\n2017\n-10-12 \n10\n:18:09 INFO\n]\n Steady State: Looking \nfor\n data file\n\n[\n2017\n-10-12 \n10\n:18:09 INFO\n]\n Steady State succeeded\n\n[\n2017\n-10-12 \n10\n:18:09 INFO\n]\n Action: Move the configuration to a different name\n\n[\n2017\n-10-12 \n10\n:18:09 INFO\n]\n Action succeeded\n\n[\n2017\n-10-12 \n10\n:18:09 INFO\n]\n Steady State: Calling our service\n\n[\n2017\n-10-12 \n10\n:18:09 ERROR\n]\n Steady State failed: Exchange file is not ready\n\n[\n2017\n-10-12 \n10\n:18:09 INFO\n]\n Experiment is now \ncomplete\n\n\n\n\n\nNotice the error towards the end, it tells us the service failed still but now\nwe get the error we designed our service for.\n\n\nGo further\n\u00b6\n\n\nIn this tutorial, you first approached the Chaos Toolkit to apply experiments\nagainst your system to confirm or infirm your initial hypothesis.\n\n\nThe example is basic on purpose but shows the simplicity of exercising\nthe \nchaos engineering principles\n to learn and adapt your system.\n\n\nThe Chaos Toolkit does not limit itself to local use-cases like this one and\noffers the possibility to interact with any system through remote API calls.\n\n\nPlease \njoin us\n on the Chaos Toolkit community to continue your\nexploration.",
            "title": "Tutorials"
        },
        {
            "location": "/usage/tutorial/#create-your-first-experiment",
            "text": "This walkthrough will drive you the basics of writing your very first\nexperiment.",
            "title": "Create your first Experiment"
        },
        {
            "location": "/usage/tutorial/#define-your-hypothesis",
            "text": "Before you start writing code, you need to define your hypthesis. What is it\nyou are trying to confirm or infirm?  There are various ways to come up with an hypothesis:   a real scenario that you and your team did not fully get a chance to learn\n  from while in emergency mode. Retrospective sessions in agile teams may be\n  a great starting point  impact mapping  is another strategy to let the team bubble\n  up relevant scenarios  your existing disaster recovery playbooks could be turned into experiments\n  that are actively applied against the system   However you come up with your hypothesis, make sure you can analyse the \nresult so keep its scope and objective simple and comprehensible.",
            "title": "Define your hypothesis"
        },
        {
            "location": "/usage/tutorial/#get-the-requirements",
            "text": "Often, an experiment involves fairly specific access to observe or interact\nwith the system. Make sure you can gather the right permissions and people on\nboard.",
            "title": "Get the requirements"
        },
        {
            "location": "/usage/tutorial/#a-first-experiment-a-missing-file",
            "text": "Let\u2019s say we have a service that polls a local file every second to see if new\ncontent was added for processing. Development made the assumption the file\nwould always be there and did not write a failure code path.  Our hypothesis is that the service should not break but simply try again until\nthe file comes back.   Our experiment should try that hypothesis to see where our system stands.  Below is the code of our service as it is now:  # -*- coding: utf-8 -*-  from   datetime   import   datetime  import   io  import   time  import   threading  from   wsgiref.validate   import   validator  from   wsgiref.simple_server   import   make_server  EXCHANGE_FILE   =   \"./exchange.dat\"  def   update_exchange_file (): \n     \"\"\"      Writes the current date and time every 10 seconds into the exchange file.      The file is created if it does not exist.      \"\"\" \n     print ( \"Will update to exchange file\" ) \n     while   True : \n         with   io . open ( EXCHANGE_FILE ,   \"w\" )   as   f : \n             f . write ( datetime . now () . isoformat ()) \n         time . sleep ( 10 )  def   simple_app ( environ ,   start_response ): \n     \"\"\"      Read the content of the exchange file and return it.      \"\"\" \n     start_response ( '200 OK' ,   [( 'Content-type' ,   'text/plain' )]) \n     with   io . open ( EXCHANGE_FILE )   as   f : \n         return   [ f . read () . encode ( 'utf-8' )]  if   __name__   ==   '__main__' : \n     t   =   threading . Thread ( target = update_exchange_file ) \n     t . start () \n\n     httpd   =   make_server ( '' ,   8080 ,   simple_app ) \n     print ( \"Listening on port 8080....\" ) \n\n     try : \n         httpd . serve_forever () \n     except   KeyboardInterrupt : \n         httpd . shutdown () \n         t . join ( timeout = 1 )   The code is simple for the purpose of this tutorial. As you can see, we declare\na simple function that reads a file and returns its content when called.  A background thread function writes the current data to that file every 10\nseconds.  Notice how we do not check the file exists before reading it soo it is likely\nthis can fail.  Run this service from another terminal as follows:  $ python service.py   Tip  The  code of this tutorial  can be found along side this\ndocumentation.",
            "title": "A first experiment: a missing file"
        },
        {
            "location": "/usage/tutorial/#declare-your-experiment",
            "text": "Below is the experiment for our hypothesis:  { \n     \"title\" :   \"Does our service tolerate the loss of its exchange file?\" , \n     \"description\" :   \"Our srevice reads data from an exchange file, can it support that file disappearing?\" , \n     \"method\" :   [ \n         { \n             \"title\" :   \"Is the file currently where it ought to be?\" , \n             \"probes\" :   { \n                 \"steady\" :   { \n                     \"title\" :   \"Looking for data file\" , \n                     \"layer\" :   \"application\" , \n                     \"type\" :   \"python\" , \n                     \"module\" :   \"os.path\" , \n                     \"func\" :   \"exists\" , \n                     \"arguments\" :   { \n                         \"path\" :   \"./exchange.dat\" \n                     } \n                 } \n             } \n         }, \n         { \n             \"title\" :   \"Next, we pretend that configuration is gone\" , \n             \"action\" :   { \n                 \"title\" :   \"Move the configuration to a different name\" , \n                 \"layer\" :   \"application\" , \n                 \"type\" :   \"python\" , \n                 \"module\" :   \"os\" , \n                 \"func\" :   \"rename\" , \n                 \"arguments\" :   { \n                     \"src\" :   \"./exchange.dat\" , \n                     \"dst\" :   \"./exchange.dat.old\" \n                 } \n             } \n         }, \n         { \n             \"title\" :   \"Our service should not break\" , \n             \"probes\" :   { \n                 \"steady\" :   { \n                     \"title\" :   \"Calling our service\" , \n                     \"layer\" :   \"application\" , \n                     \"type\" :   \"http\" , \n                     \"url\" :   \"http://localhost:8080/\" \n                 } \n             } \n         } \n     ]  }   Thi experiment shows the bricks of encoding your experiment with Chaos Toolkit.\nOnce you have provided various metadata, you tell the chaos Toolkit the\nactivitites it ought to play for us.  Usually we start with a probe that tells us the steady state of our system. In\nthis case, we simply ensure the exchange file exists. That tells us the\nservice has its expectation met.  Next, we create the conditions of our hypothesis by pretending our file does not\nexist any longer by renaming it.  Finally, we query our service over HTTP and expect a response that does not\nindicate the service is unexpectedly broken.  An experiment is made of any numbering of those activities - probes and actions.\nNote that an action can also have its own probes for a specific inspection\nbefore and after the action was applied.  The steady probe and the action are implemented by using Python functions while\nthe last probe performs a HTTP call on your behalf. Please review the documentation  for other supported implementations.",
            "title": "Declare your experiment"
        },
        {
            "location": "/usage/tutorial/#run-your-experiment",
            "text": "To run the experiment, use the  chaostoolkit  CLI as follows:  $ chaos run experiment.json [ 2017 -10-12  10 :17:42 INFO ]  Running experiment: Does our service tolerate the loss of its exchange file? [ 2017 -10-12  10 :17:42 INFO ]  Loading secrets... [ 2017 -10-12  10 :17:42 INFO ]  Steady State: Looking  for  data file [ 2017 -10-12  10 :17:42 INFO ]  Steady State succeeded [ 2017 -10-12  10 :17:42 INFO ]  Action: Move the configuration to a different name [ 2017 -10-12  10 :17:42 INFO ]  Action succeeded [ 2017 -10-12  10 :17:42 INFO ]  Steady State: Calling our service [ 2017 -10-12  10 :17:42 ERROR ]  Steady State failed: A server error occurred.  Please contact the administrator. [ 2017 -10-12  10 :17:42 INFO ]  Experiment is now  complete   Notice the error towards the end, it tells us the service failed with an\nunexpected error.  At this stage, you need to pause and analyse the results of this experiment\nto decide what to do next.",
            "title": "Run your experiment"
        },
        {
            "location": "/usage/tutorial/#fix-your-service",
            "text": "When we ran our service, it broke because the file was not found when read.\nFixing it can take various aspects, we could ensure the file can never be\nremoved through permissions or locking. Or we could also tolerate such \nfailure but let the service return a more appropriate error message in that\ncase.  This is how we are going to fix it in this tutorial:  # -*- coding: utf-8 -*-  from   datetime   import   datetime  import   io  import   os.path  import   time  import   threading  from   wsgiref.validate   import   validator  from   wsgiref.simple_server   import   make_server  EXCHANGE_FILE   =   \"./exchange.dat\"  def   update_exchange_file (): \n     \"\"\"      Writes the current date and time every 10 seconds into the exchange file.      The file is created if it does not exist.      \"\"\" \n     print ( \"Will update to exchange file\" ) \n     while   True : \n         with   io . open ( EXCHANGE_FILE ,   \"w\" )   as   f : \n             f . write ( datetime . now () . isoformat ()) \n         time . sleep ( 10 )  def   simple_app ( environ ,   start_response ): \n     \"\"\"      Read the content of the exchange file and return it.      \"\"\" \n     if   not   os . path . exists ( EXCHANGE_FILE ): \n         start_response ( \n             '503 Service Unavailable' , \n             [( 'Content-type' ,   'text/plain' )] \n         ) \n         return   [ b 'Exchange file is not ready' ] \n\n     start_response ( '200 OK' ,   [( 'Content-type' ,   'text/plain' )]) \n     with   io . open ( EXCHANGE_FILE )   as   f : \n         return   [ f . read () . encode ( 'utf-8' )]  if   __name__   ==   '__main__' : \n     t   =   threading . Thread ( target = update_exchange_file ) \n     t . start () \n\n     httpd   =   make_server ( '' ,   8080 ,   simple_app ) \n     print ( \"Listening on port 8080....\" ) \n\n     try : \n         httpd . serve_forever () \n     except   KeyboardInterrupt : \n         httpd . shutdown () \n         t . join ( timeout = 1 )   The service looks very similar but notice how we check the file indeed exists\nbefore reading it. When it does not exist, we return a more useful \n[503 Service Unavailable][503] error that a consumer could interpret as\n\u201ctry again later\u201d.  Note, that we understand a race condition may happen between the time we\nchecked for the path and the time we read content at that location. We keep\nit easy for the benefit of this tutorial.",
            "title": "Fix your service"
        },
        {
            "location": "/usage/tutorial/#run-your-experiment-again",
            "text": "Let\u2019s run again our experiment now that we have fixed and restart our service:  $ chaos run experiment.json [ 2017 -10-12  10 :18:09 INFO ]  Running experiment: Does our service tolerate the loss of its exchange file? [ 2017 -10-12  10 :18:09 INFO ]  Loading secrets... [ 2017 -10-12  10 :18:09 INFO ]  Steady State: Looking  for  data file [ 2017 -10-12  10 :18:09 INFO ]  Steady State succeeded [ 2017 -10-12  10 :18:09 INFO ]  Action: Move the configuration to a different name [ 2017 -10-12  10 :18:09 INFO ]  Action succeeded [ 2017 -10-12  10 :18:09 INFO ]  Steady State: Calling our service [ 2017 -10-12  10 :18:09 ERROR ]  Steady State failed: Exchange file is not ready [ 2017 -10-12  10 :18:09 INFO ]  Experiment is now  complete   Notice the error towards the end, it tells us the service failed still but now\nwe get the error we designed our service for.",
            "title": "Run your experiment again"
        },
        {
            "location": "/usage/tutorial/#go-further",
            "text": "In this tutorial, you first approached the Chaos Toolkit to apply experiments\nagainst your system to confirm or infirm your initial hypothesis.  The example is basic on purpose but shows the simplicity of exercising\nthe  chaos engineering principles  to learn and adapt your system.  The Chaos Toolkit does not limit itself to local use-cases like this one and\noffers the possibility to interact with any system through remote API calls.  Please  join us  on the Chaos Toolkit community to continue your\nexploration.",
            "title": "Go further"
        },
        {
            "location": "/technology/",
            "text": "Technology\n\u00b6\n\n\nKey values\n\u00b6\n\n\nThe following key values of the Chaos Toolkit reflect the mindset the community\nhas when engineering the Chaos Toolkit project.\n\n\nSimplicity\n\u00b6\n\n\nThe Chaos Toolkit aims at being a simple piece of technology both from a user\nand developer perspective.\n\n\nTo achieve simplicity, the Chaos Toolkit comes as a command line interface\ndriven by a description file. As a user, this means no code and no need to \nlearn a programming language. As a developer, this reduces the functional\nsurface area to consider.\n\n\nExtensibility\n\u00b6\n\n\nThe Chaos Toolkit does not wish to be a monolith and strives to be extended to\nfully reach its goal through community driven efforts.\n\n\nBy using a description file, the implementation is not prescribed by the Chaos\nToolkit project. Although we fully expect the community to eventually settle on\ncertain implementations of probes and actions.\n\n\nReadability\n\u00b6\n\n\nWe believe code readbility is a factor for positive maintenance and evolutivity.\n\n\nReadable code never goes out of fashion. As the code of the Chaos Toolkit is\nmostly written in Python, best practices such as defined in \nPEP8\n.\n\n\nDiversity\n\u00b6\n\n\nAlthough not strictly speaking referring to the technological aspect of the \nproject, having diversity in the community will contribute to a better project\noverall.\n\n\nCore Projects\n\u00b6\n\n\nThe Chaos Toolkit is made of several projects that work together to provide its\nservice.\n\n\nchaostoolkit\n\u00b6\n\n\nThe \nchaostoolkit\n project is the command-line interface (CLI), in other words\nthe command executed by users to run their experiments.\n\n\nThat project tries to remain as shallow as possible, only providing the user\ninterface commands by gluing other projects together.\n\n\nThis project is implemented in Python 3.\n\n\nchaostoolkit-lib\n\u00b6\n\n\nThe \nchaostoolkit-lib\n project is the core library which implements\nthe \ncore concepts\n of the Chaos Toolkit.\n\n\nThis project is implemented in Python 3.\n\n\nchaostoolkit-documentation\n\u00b6\n\n\nThe \nchaostoolkit-documehtation\n is the documentation source and\nrenderer of the Chaos Toolkit. Namely, that project generates the website you\nare currently reading.\n\n\nThis project is implemented in Python 3 by generating HTML from Markdown\ndocuments.\n\n\nExtension Projects\n\u00b6\n\n\nIn addition to the core projects, the Chaos Toolkit manages some extension\nprojects which provide probes and/or actions for experiments.\n\n\nchaostoolkit-kubernetes\n\u00b6\n\n\nThe \nchaostoolkit-kubernetes\n project implements probes and actions\nfor experiments targetting a \nKubernetes\n cluster. Those activities\nare implemented as Python functions.\n\n\nThis project is implemented in Python 3.\n\n\nchaostoolkit-gremlin\n\u00b6\n\n\nThe \nchaostoolkit-gremlin\n project implements actions\nfor experiments exploring resource failures (CPU, Memory, Network\u2026) in their\nsystem through the \nGremlin, Inc.\n services. Those activities\nare implemented as Python functions talking to the \nGremlin API\n.\n\n\nThis project is implemented in Python 3.\n\n\nchaostoolkit-prometheus\n\u00b6\n\n\nThe \nchaostoolkit-prometheus\n project implements probes to fetch\ninformation from your system through \nPrometheus\n. Those probes\nare implemented as Python functions talking to the \nPrometheus API\n.\n\n\nThis project is implemented in Python 3.\n\n\nTechnical Choices\n\u00b6\n\n\nPython 3\n\u00b6\n\n\nThe Chaos Toolkit is implemented in \nPython 3\n. A high-level language with\na long successfuly story for writing great software. It\u2019s a common choice for\ntooling purpose.\n\n\nThe language supports readbility well and has a large ecosystem of libraries. It\nis also well-spread and easy to install. The choice to not support Python 2 is\na look at Python\u2019s present and future.\n\n\nThe choice for a dynamic language was also motivated because the Chaos Toolkit\nmanipulates a lot of strings and that task is made straightforward with Python.\n\n\nAlthough Python cannot generate (well, not easily) standalone binaries like\n\ngolang\n would. We do not believe this will harm the project and hope that\npackage managers will eventually provide native installers.\n\n\nFunctional\n\u00b6\n\n\nWell, this project is not truly a functional piece of code but the code relies\nas little as possible on stateful constructions as provided by classes.\n\n\nMutable data structures are used but mostly created and returned from functions\nrather than modified.\n\n\nGenerally speaking, the project draws inspirations from certain ideas of \n\nfunctional paradigms\n but does not enforce them strictly. One notable\narea where the code strays away from these principles is the use of exceptions\nrather than returning error codes. This may change if the community expresses\nsuch an intention.\n\n\nJSON\n\u00b6\n\n\nThe experiment description and structure is encoded using JSON. The choice for\nJSON over YAML is because it leaves less room for ambiguity and is marginally\nless readable for a structure with a shallow depth like Chaos Toolkit\nexperiments.",
            "title": "Overview"
        },
        {
            "location": "/technology/#technology",
            "text": "",
            "title": "Technology"
        },
        {
            "location": "/technology/#key-values",
            "text": "The following key values of the Chaos Toolkit reflect the mindset the community\nhas when engineering the Chaos Toolkit project.",
            "title": "Key values"
        },
        {
            "location": "/technology/#simplicity",
            "text": "The Chaos Toolkit aims at being a simple piece of technology both from a user\nand developer perspective.  To achieve simplicity, the Chaos Toolkit comes as a command line interface\ndriven by a description file. As a user, this means no code and no need to \nlearn a programming language. As a developer, this reduces the functional\nsurface area to consider.",
            "title": "Simplicity"
        },
        {
            "location": "/technology/#extensibility",
            "text": "The Chaos Toolkit does not wish to be a monolith and strives to be extended to\nfully reach its goal through community driven efforts.  By using a description file, the implementation is not prescribed by the Chaos\nToolkit project. Although we fully expect the community to eventually settle on\ncertain implementations of probes and actions.",
            "title": "Extensibility"
        },
        {
            "location": "/technology/#readability",
            "text": "We believe code readbility is a factor for positive maintenance and evolutivity.  Readable code never goes out of fashion. As the code of the Chaos Toolkit is\nmostly written in Python, best practices such as defined in  PEP8 .",
            "title": "Readability"
        },
        {
            "location": "/technology/#diversity",
            "text": "Although not strictly speaking referring to the technological aspect of the \nproject, having diversity in the community will contribute to a better project\noverall.",
            "title": "Diversity"
        },
        {
            "location": "/technology/#core-projects",
            "text": "The Chaos Toolkit is made of several projects that work together to provide its\nservice.",
            "title": "Core Projects"
        },
        {
            "location": "/technology/#chaostoolkit",
            "text": "The  chaostoolkit  project is the command-line interface (CLI), in other words\nthe command executed by users to run their experiments.  That project tries to remain as shallow as possible, only providing the user\ninterface commands by gluing other projects together.  This project is implemented in Python 3.",
            "title": "chaostoolkit"
        },
        {
            "location": "/technology/#chaostoolkit-lib",
            "text": "The  chaostoolkit-lib  project is the core library which implements\nthe  core concepts  of the Chaos Toolkit.  This project is implemented in Python 3.",
            "title": "chaostoolkit-lib"
        },
        {
            "location": "/technology/#chaostoolkit-documentation",
            "text": "The  chaostoolkit-documehtation  is the documentation source and\nrenderer of the Chaos Toolkit. Namely, that project generates the website you\nare currently reading.  This project is implemented in Python 3 by generating HTML from Markdown\ndocuments.",
            "title": "chaostoolkit-documentation"
        },
        {
            "location": "/technology/#extension-projects",
            "text": "In addition to the core projects, the Chaos Toolkit manages some extension\nprojects which provide probes and/or actions for experiments.",
            "title": "Extension Projects"
        },
        {
            "location": "/technology/#chaostoolkit-kubernetes",
            "text": "The  chaostoolkit-kubernetes  project implements probes and actions\nfor experiments targetting a  Kubernetes  cluster. Those activities\nare implemented as Python functions.  This project is implemented in Python 3.",
            "title": "chaostoolkit-kubernetes"
        },
        {
            "location": "/technology/#chaostoolkit-gremlin",
            "text": "The  chaostoolkit-gremlin  project implements actions\nfor experiments exploring resource failures (CPU, Memory, Network\u2026) in their\nsystem through the  Gremlin, Inc.  services. Those activities\nare implemented as Python functions talking to the  Gremlin API .  This project is implemented in Python 3.",
            "title": "chaostoolkit-gremlin"
        },
        {
            "location": "/technology/#chaostoolkit-prometheus",
            "text": "The  chaostoolkit-prometheus  project implements probes to fetch\ninformation from your system through  Prometheus . Those probes\nare implemented as Python functions talking to the  Prometheus API .  This project is implemented in Python 3.",
            "title": "chaostoolkit-prometheus"
        },
        {
            "location": "/technology/#technical-choices",
            "text": "",
            "title": "Technical Choices"
        },
        {
            "location": "/technology/#python-3",
            "text": "The Chaos Toolkit is implemented in  Python 3 . A high-level language with\na long successfuly story for writing great software. It\u2019s a common choice for\ntooling purpose.  The language supports readbility well and has a large ecosystem of libraries. It\nis also well-spread and easy to install. The choice to not support Python 2 is\na look at Python\u2019s present and future.  The choice for a dynamic language was also motivated because the Chaos Toolkit\nmanipulates a lot of strings and that task is made straightforward with Python.  Although Python cannot generate (well, not easily) standalone binaries like golang  would. We do not believe this will harm the project and hope that\npackage managers will eventually provide native installers.",
            "title": "Python 3"
        },
        {
            "location": "/technology/#functional",
            "text": "Well, this project is not truly a functional piece of code but the code relies\nas little as possible on stateful constructions as provided by classes.  Mutable data structures are used but mostly created and returned from functions\nrather than modified.  Generally speaking, the project draws inspirations from certain ideas of  functional paradigms  but does not enforce them strictly. One notable\narea where the code strays away from these principles is the use of exceptions\nrather than returning error codes. This may change if the community expresses\nsuch an intention.",
            "title": "Functional"
        },
        {
            "location": "/technology/#json",
            "text": "The experiment description and structure is encoded using JSON. The choice for\nJSON over YAML is because it leaves less room for ambiguity and is marginally\nless readable for a structure with a shallow depth like Chaos Toolkit\nexperiments.",
            "title": "JSON"
        },
        {
            "location": "/technology/experiment/",
            "text": "Experiment\n\u00b6\n\n\nObjective\n\u00b6\n\n\nA Chaos experiment is an hypothesis you make about your system. The Chaos\nToolkit runs it and observes the state of the system. On completion, a report\nis generated for analsyis.\n\n\nOverview\n\u00b6\n\n\nAn experiment has a simple structure with the following elements:\n\n\n\n\nsome high-level metadata\n\n\na method: a sequence of activities that together represent the experiment\n\n\n\n\nThe metadata found in the experiment helps the shared understanding of its\ncontext and objective among the team. In other words, the metadata target the\nhumans dealing with this experiment.\n\n\nThe method is the meat of the experiment. It tells the Chaos Toolkit what to\nrun. It is a sequence of activities:\n\n\n\n\nactions\n\n\nprobes\n\n\n\n\nActions represent the enactment of your hypothesis, e.g. \u201cLet\u2019s shutdown\nservice A and confirm this should not bring our entire system down by ripple\neffect\u201d.\n\n\nProbes observe the system as the experiment runs. Two kinds of probes can be\ndeclared: steady and close. A steady probe looks for the state of a resource\nor the whole system before an action (or another probe) is applied. Likewsise,\nthe close probe look for the state after the action was applied.\n\n\nProbes inform your about what was happening in your system as the experiment\ntook place but also the effect of actioning the system.\n\n\nMethod Activities\n\u00b6\n\n\nProbe\n\u00b6\n\n\nA probe lets you observe your system (or any external system relevant to the\nexperiment). Think of a probe as a view on a specific aspect of your system.\nThrough probes, you can assess the conditions of your system at a\ngiven point of your experiment.\n\n\nAs seen before, the Chaos Toolkit defines two kinds of probes:\n\n\n\n\nsteady probes: appropriate to observe the steady state of your system before\n  an action is triggered\n\n\nclose probes: appropriate to observe the close state after an action is \n  triggered\n\n\n\n\nBoth probes have the same structure and only differ about when you apply them.\n\n\nAction\n\u00b6\n\n\nAn action interacts with the system, either stopping or starting a service, or\nmaybe triggering a resource failure.\n\n\nAlthough an experiment can declare many actions, it is better to keep the\nhypothesis comprehensible to make the analysis simpler and conclusive.\n\n\nBackground Activities\n\u00b6\n\n\nActivities run sequentially by default. Sometimes, you may wish to trigger an\naction and observe the system for a while. To do so, you can declare that\nactivities are executed in background. The experiment will start tha backrground\nactivity and move right away to the next activity. It will wait for all\nbackground activities to complete before terminating.\n\n\nTo declare a background activity, add the following flag to its declaration:\n\n\n\"background\"\n:\n \ntrue\n\n\n\n\n\nSecrets\n\u00b6\n\n\nAn experiment may require some secrets to pass to its activities when executed.\nThe Chaos Toolkit supports for declaring those by either inlining the values\nin the experiment itself, or by referencing environmental variables.\nEventually, it will likely support fetching secrets from products such as\n\nvault\n.\n\n\nDeclare secrets at the top of your experiment as follows:\n\n\n\"secrets\"\n:\n \n{\n\n    \n\"prometheus\"\n:\n \n{\n\n        \n\"username\"\n:\n \n\"env.PROMETHEUS_USERNAME\"\n,\n\n        \n\"password\"\n:\n \n\"env.PROMETHEUS_PASSWORD\"\n\n    \n}\n\n\n}\n\n\n\n\n\nSecrets are loaded when the experiment starts and fails if one of them cannot\nbe found in the current environment.\n\n\nThen, reference it from any activity by using:\n\n\n\"secrets\"\n:\n \n\"prometheus\"\n\n\n\n\n\nThe Chaos Toolkit, will inject those secrets down to the activity function.\n\n\n\n\nNote\n\n\nThe Chaos Toolkit does not log secrets nor does it store them into the\nresulting report it generates.\n\n\n\n\nStructure Schema\n\u00b6\n\n\nAn experiment is stored in a JSON-encoded file. It has the following\n\nschema\n.",
            "title": "Experiment"
        },
        {
            "location": "/technology/experiment/#experiment",
            "text": "",
            "title": "Experiment"
        },
        {
            "location": "/technology/experiment/#objective",
            "text": "A Chaos experiment is an hypothesis you make about your system. The Chaos\nToolkit runs it and observes the state of the system. On completion, a report\nis generated for analsyis.",
            "title": "Objective"
        },
        {
            "location": "/technology/experiment/#overview",
            "text": "An experiment has a simple structure with the following elements:   some high-level metadata  a method: a sequence of activities that together represent the experiment   The metadata found in the experiment helps the shared understanding of its\ncontext and objective among the team. In other words, the metadata target the\nhumans dealing with this experiment.  The method is the meat of the experiment. It tells the Chaos Toolkit what to\nrun. It is a sequence of activities:   actions  probes   Actions represent the enactment of your hypothesis, e.g. \u201cLet\u2019s shutdown\nservice A and confirm this should not bring our entire system down by ripple\neffect\u201d.  Probes observe the system as the experiment runs. Two kinds of probes can be\ndeclared: steady and close. A steady probe looks for the state of a resource\nor the whole system before an action (or another probe) is applied. Likewsise,\nthe close probe look for the state after the action was applied.  Probes inform your about what was happening in your system as the experiment\ntook place but also the effect of actioning the system.",
            "title": "Overview"
        },
        {
            "location": "/technology/experiment/#method-activities",
            "text": "",
            "title": "Method Activities"
        },
        {
            "location": "/technology/experiment/#probe",
            "text": "A probe lets you observe your system (or any external system relevant to the\nexperiment). Think of a probe as a view on a specific aspect of your system.\nThrough probes, you can assess the conditions of your system at a\ngiven point of your experiment.  As seen before, the Chaos Toolkit defines two kinds of probes:   steady probes: appropriate to observe the steady state of your system before\n  an action is triggered  close probes: appropriate to observe the close state after an action is \n  triggered   Both probes have the same structure and only differ about when you apply them.",
            "title": "Probe"
        },
        {
            "location": "/technology/experiment/#action",
            "text": "An action interacts with the system, either stopping or starting a service, or\nmaybe triggering a resource failure.  Although an experiment can declare many actions, it is better to keep the\nhypothesis comprehensible to make the analysis simpler and conclusive.",
            "title": "Action"
        },
        {
            "location": "/technology/experiment/#background-activities",
            "text": "Activities run sequentially by default. Sometimes, you may wish to trigger an\naction and observe the system for a while. To do so, you can declare that\nactivities are executed in background. The experiment will start tha backrground\nactivity and move right away to the next activity. It will wait for all\nbackground activities to complete before terminating.  To declare a background activity, add the following flag to its declaration:  \"background\" :   true",
            "title": "Background Activities"
        },
        {
            "location": "/technology/experiment/#secrets",
            "text": "An experiment may require some secrets to pass to its activities when executed.\nThe Chaos Toolkit supports for declaring those by either inlining the values\nin the experiment itself, or by referencing environmental variables.\nEventually, it will likely support fetching secrets from products such as vault .  Declare secrets at the top of your experiment as follows:  \"secrets\" :   { \n     \"prometheus\" :   { \n         \"username\" :   \"env.PROMETHEUS_USERNAME\" , \n         \"password\" :   \"env.PROMETHEUS_PASSWORD\" \n     }  }   Secrets are loaded when the experiment starts and fails if one of them cannot\nbe found in the current environment.  Then, reference it from any activity by using:  \"secrets\" :   \"prometheus\"   The Chaos Toolkit, will inject those secrets down to the activity function.   Note  The Chaos Toolkit does not log secrets nor does it store them into the\nresulting report it generates.",
            "title": "Secrets"
        },
        {
            "location": "/technology/experiment/#structure-schema",
            "text": "An experiment is stored in a JSON-encoded file. It has the following schema .",
            "title": "Structure Schema"
        },
        {
            "location": "/technology/extend/",
            "text": "Extend\n\u00b6\n\n\nOverview\n\u00b6\n\n\nExperiments are declared in JSON-encoded files. Probes and actions describe\nwhat should be executed by the Chaos Toolkit.\n\n\nThe ChaosToolkit does not implement probes and actions natively. Instead,\nit supports three extension mechanisms:\n\n\n\n\nPython function\n\n\nProcess\n\n\nHTTP\n\n\n\n\nIn the future, other providers will likely be added such as \nFaaS\n.\n\n\nPython function\n\u00b6\n\n\nYou can implement a probe or action as a Python function. In that case, you\ncan use any Python package your activity needs. The structure for a Python\nfunction is as follows:\n\n\n{\n\n    \n\"type\"\n:\n \n\"python\"\n,\n\n    \n\"module\"\n:\n \n\"os.path\"\n,\n\n    \n\"func\"\n:\n \n\"exists\"\n,\n\n    \n\"arguments\"\n:\n \n{\n\n        \n\"path\"\n:\n \n\"/some/path\"\n\n    \n}\n\n\n}\n\n\n\n\n\nThe \ntype=\"python\"\n entry informs the Chaos Toolkit this is a Python function\nactivity. The \nmodule\n should be found in the Python path of the Chaos Toolkit\nprocess (its virtual environment usually). Make sure the \nfunc\n belongs to\na package that has been installed prior to running the command the toolkit will\nnot attempt to fetch it.\n\n\nThe \narguments\n object is a mapping of keys to string values that will be \npassed as-is to the function arguments. If they do not match, the Chaos Toolkit\nwill raise an error.\n\n\nProcess\n\u00b6\n\n\nThe Chaos Toolkit can run external processes, found in the PATH. The structure\nfor a process is as follows:\n\n\n{\n\n    \n\"type\"\n:\n \n\"process\"\n,\n\n    \n\"path\"\n:\n \n\"/sbin/ip\"\n,\n\n    \n\"arguments\"\n:\n \n{\n\n        \n\"-a\"\n:\n \nnull\n\n    \n}\n\n\n}\n\n\n\n\n\nThe \ntype=\"process\"\n entry informs the Chaos Toolkit this is a process activity.\nThe \npath\n indicates the executable to run. Either an absolute path or a command\nto be found in the PATH. The user running the Chaos Toolkit must have the \npermissions to execute the command.\n\n\nThe \narguments\n object is a mapping of keys to string values that will be \npassed as-is to the process as arguments.\n\n\nYou can provide a \ntimeout\n to interrupt the command at some point, in that case\nthe activity will be considered failed.\n\n\nHTTP\n\u00b6\n\n\nThe Chaos Toolkit can call HTTP endpoints.The structure for a HTTP call is as\nfollows:\n\n\n{\n\n    \n\"type\"\n:\n \n\"http\"\n,\n\n    \n\"url\"\n:\n \n\"http://httpbin.org/post\"\n,\n\n    \n\"method\"\n:\n \n\"POST\"\n,\n\n    \n\"headers\"\n:\n \n{\n\n        \n\"accept\"\n:\n \n\"application/json\"\n\n    \n},\n\n    \n\"arguments\"\n:\n \n{\n\n        \n\"name\"\n:\n \n\"john\"\n \n    \n}\n\n\n}\n\n\n\n\n\nThe \ntype=\"http\"\n entry informs the Chaos Toolkit this is a HTTP activity.\nThe \nurl\n is the only required key and indicates the endpoint to talk to. You\ncan pass \nheaders\n as well and specify the HTTP \nmethod\n to be used.\n\n\nThe \narguments\n object is a mapping of keys to string values that will be \npassed as-is to the process as arguments.\n\n\nYou can provide a \ntimeout\n to interrupt the command at some point, in that case\nthe activity will be considered failed.",
            "title": "Extend"
        },
        {
            "location": "/technology/extend/#extend",
            "text": "",
            "title": "Extend"
        },
        {
            "location": "/technology/extend/#overview",
            "text": "Experiments are declared in JSON-encoded files. Probes and actions describe\nwhat should be executed by the Chaos Toolkit.  The ChaosToolkit does not implement probes and actions natively. Instead,\nit supports three extension mechanisms:   Python function  Process  HTTP   In the future, other providers will likely be added such as  FaaS .",
            "title": "Overview"
        },
        {
            "location": "/technology/extend/#python-function",
            "text": "You can implement a probe or action as a Python function. In that case, you\ncan use any Python package your activity needs. The structure for a Python\nfunction is as follows:  { \n     \"type\" :   \"python\" , \n     \"module\" :   \"os.path\" , \n     \"func\" :   \"exists\" , \n     \"arguments\" :   { \n         \"path\" :   \"/some/path\" \n     }  }   The  type=\"python\"  entry informs the Chaos Toolkit this is a Python function\nactivity. The  module  should be found in the Python path of the Chaos Toolkit\nprocess (its virtual environment usually). Make sure the  func  belongs to\na package that has been installed prior to running the command the toolkit will\nnot attempt to fetch it.  The  arguments  object is a mapping of keys to string values that will be \npassed as-is to the function arguments. If they do not match, the Chaos Toolkit\nwill raise an error.",
            "title": "Python function"
        },
        {
            "location": "/technology/extend/#process",
            "text": "The Chaos Toolkit can run external processes, found in the PATH. The structure\nfor a process is as follows:  { \n     \"type\" :   \"process\" , \n     \"path\" :   \"/sbin/ip\" , \n     \"arguments\" :   { \n         \"-a\" :   null \n     }  }   The  type=\"process\"  entry informs the Chaos Toolkit this is a process activity.\nThe  path  indicates the executable to run. Either an absolute path or a command\nto be found in the PATH. The user running the Chaos Toolkit must have the \npermissions to execute the command.  The  arguments  object is a mapping of keys to string values that will be \npassed as-is to the process as arguments.  You can provide a  timeout  to interrupt the command at some point, in that case\nthe activity will be considered failed.",
            "title": "Process"
        },
        {
            "location": "/technology/extend/#http",
            "text": "The Chaos Toolkit can call HTTP endpoints.The structure for a HTTP call is as\nfollows:  { \n     \"type\" :   \"http\" , \n     \"url\" :   \"http://httpbin.org/post\" , \n     \"method\" :   \"POST\" , \n     \"headers\" :   { \n         \"accept\" :   \"application/json\" \n     }, \n     \"arguments\" :   { \n         \"name\" :   \"john\"  \n     }  }   The  type=\"http\"  entry informs the Chaos Toolkit this is a HTTP activity.\nThe  url  is the only required key and indicates the endpoint to talk to. You\ncan pass  headers  as well and specify the HTTP  method  to be used.  The  arguments  object is a mapping of keys to string values that will be \npassed as-is to the process as arguments.  You can provide a  timeout  to interrupt the command at some point, in that case\nthe activity will be considered failed.",
            "title": "HTTP"
        }
    ]
}