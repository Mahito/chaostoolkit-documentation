{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chaos Engineering Experiments Automation \u00b6 The Chaos Toolkit aims to be the simplest and easiest way to explore building your own Chaos Engineering Experiments. It also aims to define a vendor and technology independent way of specifying Chaos Engineering experiments by providing an Open API . We suggest you start with the tutorials to get a feel for how the Chaos Toolkit can help you automate your Chaos Engineering effort. Once you are ready for your own experiments, have a look at the various driver extensions we support, which ranges from platforms to cloud providers while giving you tools to observe your system as you run your experiments. Finally, if you cant to contribute , you are more than welcome. Start with joining the community and read our references like the Open API which specifies the Chaos Toolkit experiment format. Above all, have fun!","title":"Home"},{"location":"#chaos-engineering-experiments-automation","text":"The Chaos Toolkit aims to be the simplest and easiest way to explore building your own Chaos Engineering Experiments. It also aims to define a vendor and technology independent way of specifying Chaos Engineering experiments by providing an Open API . We suggest you start with the tutorials to get a feel for how the Chaos Toolkit can help you automate your Chaos Engineering effort. Once you are ready for your own experiments, have a look at the various driver extensions we support, which ranges from platforms to cloud providers while giving you tools to observe your system as you run your experiments. Finally, if you cant to contribute , you are more than welcome. Start with joining the community and read our references like the Open API which specifies the Chaos Toolkit experiment format. Above all, have fun!","title":"Chaos Engineering Experiments Automation"},{"location":"explore-specific-cases/","text":"Once you\u2019re familiar with the basics of the Chaos Toolkit\u2019s Workflow you can begin to explore how this can be applied to specific targets through further tutorials: Applying Chaos Engineering to Cloud Native Microservices on Kubernetes","title":"Explore specific cases"},{"location":"faq/","text":"What is the Chaos Toolkit? \u00b6 It is an open-source software that runs an experiment against your system to confirm or infirm an hypothesis. Colloquially this refers to the C haos Engineering Principles . Why do I need to run experiments? \u00b6 Systems do not live in a vacuum, they are subjected to real world events, some expected and tolerated, others considered as attacks. Waiting for those conditions arise does not give the time your team needs to handle, learn and adapt to the situation at hand. In many countries, fire alarm tests are conducted at random in offices so people learn how to react well for the benefit of everyone. Software systems should go through the same exercises. The Chaos Toolkit hopes to make it simple and safe to run experiments like these. Engaging the team and organisation \u00b6 Chaos engineering aims at making you learn from your system. This is not a lone activity but a team, potentially the whole organisation, endeavor. Indeed, a hypothesis you could set the hypothesis \u201cwe have been hacked and lost users sensitive data, we should issue a statement we are doing everything to fix the problem within 15min\u201d. This experiment is not really technical but organisational: is the chain of information and command working effectively? Isn\u2019t it testing? \u00b6 We do not consider testing and chaos engineering to conflict with each other. They both provide useful and actionable feedback. Where they differ is their objective. Testing is a process that aims at telling you if your application, within controlled boundaries, runs as expected. Chaos engineering is a discipline of posing a hypothesis before collecting evidence to reject or accept that hypothesis. A test is sort of an hypothesis in its own. The difference lies in the experimental approach of the chaos engineering discipline. It asks a question and then observe the system to see if we can answer that question positively or negatively. Incidentally, some forms of testing are not too dissimilar to a chaos engineering experiment. Say for instance, you run a load testing. Your hypothesis is that response time should not be impacted under load. By running your experiment, you may answer that question. Isn\u2019t it monitoring? \u00b6 Much like chaos engineering is not testing, it should not be conflated with monitoring. If anything, chaos engineering strives for good monitoring for it helps observing the system during the experiment. Monitoring surfaces, informs and may even react to conditions in your system. But this is not answering a question like chaos engineering tries to do. Why a toolkit? \u00b6 Currently, running experiments is not an easy task because the ecosystem is still fairly young. Complex cases have been demonstrated at large corporations such as Netflix or LinkedIn. Tools such as ChAP or Simoorg are powerful but quite involved. The Chaos Toolkit aims at providing a more straightforward initial user experience to gain confidence in doing Chaos Engineering experiments. The simpler it gets the greater our cognitive capacity to understand what is going on. Ultimately, the Chaos Toolkit should lead you on the path to using richer tools such as those cited above. What does the Chaos Toolkit do? \u00b6 The Chaos Toolkit user-interface is a command line that takes a JSON-encoded file describing the experiment to run. It consists of a sequence of activities the toolkit executes in order to produce a final report. The activities are of two kinds. Probes observe the system at various point of the experiment. Actions interact with the system to change its state. Usually the action represents the hypothesis you are trying to learn from. Who is behind the Chaos Toolkit? \u00b6 The effort was initiated by Russ Miles and Sylvain Hellegouarch , two engineers passionate about fluidity in complex systems. However, their vision is really to build a strong community of engineer experiences to feedback into the Chaos Toolkit. What is the license of the Chaos Toolkit? \u00b6 Apache 2.0 . How can I contribute? \u00b6 The Chaos Toolkit welcomes contributors! To help the project, please go to the right project on GitHub and create an issue. If you feel like it, do not hesitate to fork the repository, make a change and submit a pull-request to the upstream project for review.","title":"Faq"},{"location":"faq/#what-is-the-chaos-toolkit","text":"It is an open-source software that runs an experiment against your system to confirm or infirm an hypothesis. Colloquially this refers to the C haos Engineering Principles .","title":"What is the Chaos Toolkit?"},{"location":"faq/#why-do-i-need-to-run-experiments","text":"Systems do not live in a vacuum, they are subjected to real world events, some expected and tolerated, others considered as attacks. Waiting for those conditions arise does not give the time your team needs to handle, learn and adapt to the situation at hand. In many countries, fire alarm tests are conducted at random in offices so people learn how to react well for the benefit of everyone. Software systems should go through the same exercises. The Chaos Toolkit hopes to make it simple and safe to run experiments like these.","title":"Why do I need to run experiments?"},{"location":"faq/#engaging-the-team-and-organisation","text":"Chaos engineering aims at making you learn from your system. This is not a lone activity but a team, potentially the whole organisation, endeavor. Indeed, a hypothesis you could set the hypothesis \u201cwe have been hacked and lost users sensitive data, we should issue a statement we are doing everything to fix the problem within 15min\u201d. This experiment is not really technical but organisational: is the chain of information and command working effectively?","title":"Engaging the team and organisation"},{"location":"faq/#isnt-it-testing","text":"We do not consider testing and chaos engineering to conflict with each other. They both provide useful and actionable feedback. Where they differ is their objective. Testing is a process that aims at telling you if your application, within controlled boundaries, runs as expected. Chaos engineering is a discipline of posing a hypothesis before collecting evidence to reject or accept that hypothesis. A test is sort of an hypothesis in its own. The difference lies in the experimental approach of the chaos engineering discipline. It asks a question and then observe the system to see if we can answer that question positively or negatively. Incidentally, some forms of testing are not too dissimilar to a chaos engineering experiment. Say for instance, you run a load testing. Your hypothesis is that response time should not be impacted under load. By running your experiment, you may answer that question.","title":"Isn't it testing?"},{"location":"faq/#isnt-it-monitoring","text":"Much like chaos engineering is not testing, it should not be conflated with monitoring. If anything, chaos engineering strives for good monitoring for it helps observing the system during the experiment. Monitoring surfaces, informs and may even react to conditions in your system. But this is not answering a question like chaos engineering tries to do.","title":"Isn't it monitoring?"},{"location":"faq/#why-a-toolkit","text":"Currently, running experiments is not an easy task because the ecosystem is still fairly young. Complex cases have been demonstrated at large corporations such as Netflix or LinkedIn. Tools such as ChAP or Simoorg are powerful but quite involved. The Chaos Toolkit aims at providing a more straightforward initial user experience to gain confidence in doing Chaos Engineering experiments. The simpler it gets the greater our cognitive capacity to understand what is going on. Ultimately, the Chaos Toolkit should lead you on the path to using richer tools such as those cited above.","title":"Why a toolkit?"},{"location":"faq/#what-does-the-chaos-toolkit-do","text":"The Chaos Toolkit user-interface is a command line that takes a JSON-encoded file describing the experiment to run. It consists of a sequence of activities the toolkit executes in order to produce a final report. The activities are of two kinds. Probes observe the system at various point of the experiment. Actions interact with the system to change its state. Usually the action represents the hypothesis you are trying to learn from.","title":"What does the Chaos Toolkit do?"},{"location":"faq/#who-is-behind-the-chaos-toolkit","text":"The effort was initiated by Russ Miles and Sylvain Hellegouarch , two engineers passionate about fluidity in complex systems. However, their vision is really to build a strong community of engineer experiences to feedback into the Chaos Toolkit.","title":"Who is behind the Chaos Toolkit?"},{"location":"faq/#what-is-the-license-of-the-chaos-toolkit","text":"Apache 2.0 .","title":"What is the license of the Chaos Toolkit?"},{"location":"faq/#how-can-i-contribute","text":"The Chaos Toolkit welcomes contributors! To help the project, please go to the right project on GitHub and create an issue. If you feel like it, do not hesitate to fork the repository, make a change and submit a pull-request to the upstream project for review.","title":"How can I contribute?"},{"location":"getting-started/","text":"The best way to quickly explore using the Chaos Toolkit is to work through the Getting Started section of our free online tutorials , available thanks to the excellent Katacoda system. These Getting Started tutorials show you how to install the Chaos Toolkit and how to use the Chaos Toolkit\u2019s Workflow to discover and init to bootstrap your own experiments, so that you can then run them in order to produce a report that you and your teams can learn from as you aim to improve your system.","title":"Getting started"},{"location":"integrations/","text":"The Chaos Toolkit uses a number of third-party integrations to probe and act upon your systems. Some of these integrations are commercial and there is a growing catalogue of online tutorials around these integrations as well .","title":"Integrations"},{"location":"new-to-chaos/","text":"If you\u2019re new to Chaos Engineering and want to get up-to-speed on the concept quickly we recommend reading the following: Download the free, Chaos Engineering eBook Understanding the importance of the Chaos Engineering terms in this discussion of the term by Russ Miles How to explain Chaos Engineering effectively to your colleagues and non-technical stakeholders How to decide you are ready to begin using Chaos Engineering on your own systems Explore and learn more about all the aspects of Chaos Engineering Chaos engineering helps you build confidence in your system\u2019s availability using experiments to explore and discover the unknown weaknesses within those systems.","title":"New to chaos"},{"location":"drivers/aws/","text":"Extension chaosaws \u00b6 Version 0.9.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-aws This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-aws Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"name\" : \"stop-an-ec2-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"arguments\" : { \"instance_id\" : \"i-123456\" } } } , { \"name\" : \"create-a-new-policy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"create_policy\" , \"arguments\" : { \"name\" : \"mypolicy\" , \"path\" : \"user/Jane\" , \"policy\" : { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"s3:ListAllMyBuckets\" , \"s3:GetBucketLocation\" ], \"Resource\" : \"arn:aws:s3:::*\" } ] } } } } Or select one at random from an AZ: { \"name\" : \"stop-an-ec2-instance-in-az-at-random\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"arguments\" : { \"az\" : \"us-west-1\" } } } That\u2019s it! Please explore the code to see existing probes and actions. Configuration \u00b6 Credentials \u00b6 This extension uses the boto3 library under the hood. This library expects that you have properly configured your environment to connect and authenticate with the AWS services. Generally speaking, there are two ways of doing this: you have configured the environment where you will run the experiment from (any of the user-wide credential sources would do). You may also provide a profile name to assume a role . { \"configuration\" : { \"aws_profile_name\" : \"dev\" } } you explicitely pass the correct environment variables to the experiment definition as follows: { \"secrets\" : { \"aws\" : { \"aws_access_key_id\" : \"your key\" , \"aws_secret_access_key\" : \"access key\" , \"aws_session_token\" : \"token\" , } } } Note that the token is optional. Then, use it as follows: ```json { \"name\": \"stop-an-ec2-instance\", \"provider\": { \"type\": \"python\", \"module\": \"chaosaws.ec2.actions\", \"func\": \"stop_instance\", \"secrets\": [\"aws\"], \"arguments\": { \"instance_id\": \"i-123456\" } } } ``` Other AWS settings \u00b6 In additon to the authentication credentials, you can configure the region against which you want to use. At the top level of the experiment, add: { \"configuration\" : { \"aws_region\" : \"us-east-1\" } } Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Add new AWS API Support \u00b6 Once you have setup your environment, you can start adding new AWS API support by adding new actions, probes and entire sub-packages for those. Services supported by boto \u00b6 This package relies on boto3 to wrap the API calls into a fluent Python API. Some newer AWS services are not yet available in boto3, in that case, you should read the next section. Let\u2019s say you want to support a new action in the EC2 sub-package. Start by creating a new function in ec2/actions.py : from chaoslib.types import Configuration , Secrets from chaosaws import aws_client from chaosaws.types import AWSResponse def reboot_instance ( instance_id : str , dry_run : bool = False , configuration : Configuration = None , secrets : Secrets = None ) -> AWSResponse : \"\"\" Reboot a given EC2 instance. \"\"\" client = aws_client ( 'ec2' , configuration , secrets ) return client . reboot_instances ( InstanceIds = [ instance_id ], DryRun = dry_run ) As you can see, the actual code is straightforward. You first create a EC2 client and simply call the appropriate method on that client with the expected arguments. We return the action as-is so that it can be logged by the chaostoolkit, or even be used as part of a steady-state hypothesis probe (if this was a probe, not action that is). You could decide to make more than one AWS API call but, it is better to keep it simple so that composition is easier from the experiment. Nonetheless, you may also compose those directly into a single action as well for specific use-cases. Please refer to the Chaos Toolkit documentation to learn more about the configuration and secrets objects. Once you have implemented that action, you must create at least one unit test for it in the tests/ec2/test_ec2_actions.py test module. For example: from chaosaws.ec2.actions import reboot_instancex @patch ( 'chaosaws.ec2.actions.aws_client' , autospec = True ) def test_reboot_instance ( aws_client ): client = MagicMock () aws_client . return_value = client inst_id = \"i-1234567890abcdef0\" response = reboot_instance ( inst_id ) client . reboot_instances . assert_called_with ( InstanceIds = [ inst_id ], DryRun = False ) By using the built-in Python module to mock objects , we can mock the EC2 client and assert we edo indeed call the appropriate method with the right arguments. You are encouraged to write more than a single test for various conditions. Finally, should you choose to add support for a new AWS API resource altogether, you should create the according sub-package. Services not supported by boto (new AWS features) \u00b6 If the support you want to provide is for a new AWS service that boto does not support yet, this requires direct call to the API endpoint via the requests package. Say we have a new service, not yet supported by boto3 from chaoslib.types import Configuration , Secrets from chaosaws import signed_api_call from chaosaws.types import AWSResponse def terminate_worker_node ( worker_node_id : str , configuration : Configuration = None , secrets : Secrets = None ) -> AWSResponse : \"\"\" Terminate a worker node. \"\"\" params = { \"DryRun\" : True , \"WorkerNodeId.1\" : worker_node_id } response = signed_api_call ( 'some-new-service-name' , path = '/2018-01-01/worker/terminate' , method = 'POST' , params = params , configuration = configuration , secrets = secrets ) return response . json () Here is an example on existing API call (as a more concrete snippet): from chaoslib.types import Configuration , Secrets from chaosaws import signed_api_call def stop_instance ( instance_id : str , configuration : Configuration = None , secrets : Secrets = None ) -> str : response = signed_api_call ( 'ec2' , configuration = configuration , secrets = secrets , params = { \"Action\" : \"StopInstances\" , \"InstanceId.1\" : instance_id , \"Version\" : \"2013-06-15\" } ) # this API returns XML, not JSON return response . text When using the signed_api_call , you are responsible for the right way of passing the parameters. Basically, look at the AWS documentation for each API call. WARNING: It should be noted that, whenever boto3 implements an API, this package should be updated accordingly, as boto3 is much more versatile and solid. Make your new sub-package discoverable \u00b6 Finally, if you have created a new sub-package entirely, you need to make its capability discoverable by the chaos toolkit. Simply amend the discover function in the chaosaws/__init__.py . For example, assuming a new eks sub-package, with actions and probes: activities . extend ( discover_actions ( \"chaosaws.eks.actions\" )) activities . extend ( discover_probes ( \"chaosaws.eks.probes\" )) Exported Activities \u00b6 awslambda \u00b6 delete_function_concurrency \u00b6 Type action Module chaosaws.awslambda.actions Name delete_function_concurrency Return None Removes concurrency limit applied to the specified Lambda Signature: def delete_function_concurrency ( function_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes Usage: { \"name\" : \"delete-function-concurrency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"delete_function_concurrency\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : delete-function-concurrency provider : arguments : function_name : '' func : delete_function_concurrency module : chaosaws.awslambda.actions type : python type : action get_function_concurrency \u00b6 Type probe Module chaosaws.awslambda.probes Name get_function_concurrency Return None Get configuration information of lambda by its function name Signature: def get_function_concurrency ( function_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required function_name string Yes Usage: { \"name\" : \"get-function-concurrency\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"get_function_concurrency\" , \"module\" : \"chaosaws.awslambda.probes\" } } name : get-function-concurrency provider : arguments : function_name : '' func : get_function_concurrency module : chaosaws.awslambda.probes type : python type : probe get_function_memory_size \u00b6 Type probe Module chaosaws.awslambda.probes Name get_function_memory_size Return None Get the configured memory size of a lambda function. The returned memory size is specified in megabytes. Signature: def get_function_memory_size ( function_name : str , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required function_name string Yes qualifier string null No Usage: { \"name\" : \"get-function-memory-size\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"get_function_memory_size\" , \"module\" : \"chaosaws.awslambda.probes\" } } name : get-function-memory-size provider : arguments : function_name : '' func : get_function_memory_size module : chaosaws.awslambda.probes type : python type : probe get_function_timeout \u00b6 Type probe Module chaosaws.awslambda.probes Name get_function_timeout Return None Get the configured timeout of a lambda function. The returned timeout is specified in number of seconds. Signature: def get_function_timeout ( function_name : str , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required function_name string Yes qualifier string null No Usage: { \"name\" : \"get-function-timeout\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"get_function_timeout\" , \"module\" : \"chaosaws.awslambda.probes\" } } name : get-function-timeout provider : arguments : function_name : '' func : get_function_timeout module : chaosaws.awslambda.probes type : python type : probe invoke_function \u00b6 Type action Module chaosaws.awslambda.actions Name invoke_function Return None Invokes Lambda. More information about request arguments are available in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/lambda.html#Lambda.Client.invoke Signature: def invoke_function ( function_name : str , function_arguments : Dict [ str , Any ] = None , invocation_type : str = 'RequestResponse' , client_context : Dict [ str , Any ] = None , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes function_arguments mapping null No invocation_type string \u201cRequestResponse\u201d No client_context mapping null No qualifier string null No Usage: { \"name\" : \"invoke-function\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"invoke_function\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : invoke-function provider : arguments : function_name : '' func : invoke_function module : chaosaws.awslambda.actions type : python type : action put_function_concurrency \u00b6 Type action Module chaosaws.awslambda.actions Name put_function_concurrency Return None Throttles Lambda by setting reserved concurrency amount. Signature: def put_function_concurrency ( function_name : str , concurrent_executions : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes concurrent_executions integer Yes Usage: { \"name\" : \"put-function-concurrency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" , \"concurrent_executions\" : 0 }, \"func\" : \"put_function_concurrency\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : put-function-concurrency provider : arguments : concurrent_executions : 0 function_name : '' func : put_function_concurrency module : chaosaws.awslambda.actions type : python type : action put_function_memory_size \u00b6 Type action Module chaosaws.awslambda.actions Name put_function_memory_size Return None Sets the function memory size. Input memory_size argument is specified in megabytes. Signature: def put_function_memory_size ( function_name : str , memory_size : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes memory_size integer Yes Usage: { \"name\" : \"put-function-memory-size\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" , \"memory_size\" : 0 }, \"func\" : \"put_function_memory_size\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : put-function-memory-size provider : arguments : function_name : '' memory_size : 0 func : put_function_memory_size module : chaosaws.awslambda.actions type : python type : action put_function_timeout \u00b6 Type action Module chaosaws.awslambda.actions Name put_function_timeout Return None Sets the function timeout. Input timeout argument is specified in seconds. Signature: def put_function_timeout ( function_name : str , timeout : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes timeout integer Yes Usage: { \"name\" : \"put-function-timeout\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" , \"timeout\" : 0 }, \"func\" : \"put_function_timeout\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : put-function-timeout provider : arguments : function_name : '' timeout : 0 func : put_function_timeout module : chaosaws.awslambda.actions type : python type : action eks \u00b6 create_cluster \u00b6 Type action Module chaosaws.eks.actions Name create_cluster Return None Create a new EKS cluster. Signature: def create_cluster ( name : str , role_arn : str , vpc_config : Dict [ str , Any ], version : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes role_arn string Yes vpc_config mapping Yes version string null No Usage: { \"name\" : \"create-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" , \"role_arn\" : \"\" , \"vpc_config\" : {} }, \"func\" : \"create_cluster\" , \"module\" : \"chaosaws.eks.actions\" } } name : create-cluster provider : arguments : name : '' role_arn : '' vpc_config : {} func : create_cluster module : chaosaws.eks.actions type : python type : action delete_cluster \u00b6 Type action Module chaosaws.eks.actions Name delete_cluster Return None Delete the given EKS cluster. Signature: def delete_cluster ( name : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string null No Usage: { \"name\" : \"delete-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"delete_cluster\" , \"module\" : \"chaosaws.eks.actions\" } } name : delete-cluster provider : func : delete_cluster module : chaosaws.eks.actions type : python type : action describe_cluster \u00b6 Type probe Module chaosaws.eks.probes Name describe_cluster Return None Describe an EKS cluster. Signature: def describe_cluster ( name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes Usage: { \"name\" : \"describe-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"describe_cluster\" , \"module\" : \"chaosaws.eks.probes\" } } name : describe-cluster provider : arguments : name : '' func : describe_cluster module : chaosaws.eks.probes type : python type : probe list_clusters \u00b6 Type probe Module chaosaws.eks.probes Name list_clusters Return None List EKS clusters available to the authenticated account. Signature: def list_clusters ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-clusters\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"list_clusters\" , \"module\" : \"chaosaws.eks.probes\" } } name : list-clusters provider : func : list_clusters module : chaosaws.eks.probes type : python type : probe elbv2 \u00b6 all_targets_healthy \u00b6 Type probe Module chaosaws.elbv2.probes Name all_targets_healthy Return None Return true/false based on if all targets for listed target groups are healthy Signature: def all_targets_healthy ( tg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_names list Yes Usage: { \"name\" : \"all-targets-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"tg_names\" : [] }, \"func\" : \"all_targets_healthy\" , \"module\" : \"chaosaws.elbv2.probes\" } } name : all-targets-healthy provider : arguments : tg_names : [] func : all_targets_healthy module : chaosaws.elbv2.probes type : python type : probe deregister_target \u00b6 Type action Module chaosaws.elbv2.actions Name deregister_target Return None Deregisters one random target from target group Signature: def deregister_target ( tg_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_name string Yes Usage: { \"name\" : \"deregister-target\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"tg_name\" : \"\" }, \"func\" : \"deregister_target\" , \"module\" : \"chaosaws.elbv2.actions\" } } name : deregister-target provider : arguments : tg_name : '' func : deregister_target module : chaosaws.elbv2.actions type : python type : action targets_health_count \u00b6 Type probe Module chaosaws.elbv2.probes Name targets_health_count Return None Count of healthy/unhealthy targets per targetgroup Signature: def targets_health_count ( tg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_names list Yes Usage: { \"name\" : \"targets-health-count\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"tg_names\" : [] }, \"func\" : \"targets_health_count\" , \"module\" : \"chaosaws.elbv2.probes\" } } name : targets-health-count provider : arguments : tg_names : [] func : targets_health_count module : chaosaws.elbv2.probes type : python type : probe cloudwatch \u00b6 delete_rule \u00b6 Type action Module chaosaws.cloudwatch.actions Name delete_rule Return None Deletes a CloudWatch rule. All rule targets must be removed before deleting the rule. Set input argument force to True to force all rule targets to be deleted. Signature: def delete_rule ( rule_name : str , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes force boolean false No Usage: { \"name\" : \"delete-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"delete_rule\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : delete-rule provider : arguments : rule_name : '' func : delete_rule module : chaosaws.cloudwatch.actions type : python type : action disable_rule \u00b6 Type action Module chaosaws.cloudwatch.actions Name disable_rule Return None Disables a CloudWatch rule. Signature: def disable_rule ( rule_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes Usage: { \"name\" : \"disable-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"disable_rule\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : disable-rule provider : arguments : rule_name : '' func : disable_rule module : chaosaws.cloudwatch.actions type : python type : action enable_rule \u00b6 Type action Module chaosaws.cloudwatch.actions Name enable_rule Return None Enables a CloudWatch rule. Signature: def enable_rule ( rule_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes Usage: { \"name\" : \"enable-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"enable_rule\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : enable-rule provider : arguments : rule_name : '' func : enable_rule module : chaosaws.cloudwatch.actions type : python type : action get_alarm_state_value \u00b6 Type probe Module chaosaws.cloudwatch.probes Name get_alarm_state_value Return None Return the state value of an alarm. The possbile alarm state values are described in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.describe_alarms Signature: def get_alarm_state_value ( alarm_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required alarm_name string Yes Usage: { \"name\" : \"get-alarm-state-value\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"alarm_name\" : \"\" }, \"func\" : \"get_alarm_state_value\" , \"module\" : \"chaosaws.cloudwatch.probes\" } } name : get-alarm-state-value provider : arguments : alarm_name : '' func : get_alarm_state_value module : chaosaws.cloudwatch.probes type : python type : probe get_metric_statistics \u00b6 Type probe Module chaosaws.cloudwatch.probes Name get_metric_statistics Return None Get the value of a statistical calculation for a given metric. The period for which the calculation will be performed is specified by a duration and an offset from the current time. Both are specified in seconds. Example: A duration of 60 seconds and an offset of 30 seconds will yield a statistical value based on the time interval between 30 and 90 seconds in the past. More information about input parameters are available in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_statistics Signature: def get_metric_statistics ( namespace : str , metric_name : str , dimension_name : str , dimension_value : str , duration : int = 60 , offset : int = 0 , statistic : str = None , extended_statistic : str = None , unit : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required namespace string Yes metric_name string Yes dimension_name string Yes dimension_value string Yes duration integer 60 No offset integer 0 No statistic string null No extended_statistic string null No unit string null No Usage: { \"name\" : \"get-metric-statistics\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"dimension_name\" : \"\" , \"namespace\" : \"\" , \"dimension_value\" : \"\" , \"metric_name\" : \"\" }, \"func\" : \"get_metric_statistics\" , \"module\" : \"chaosaws.cloudwatch.probes\" } } name : get-metric-statistics provider : arguments : dimension_name : '' dimension_value : '' metric_name : '' namespace : '' func : get_metric_statistics module : chaosaws.cloudwatch.probes type : python type : probe put_rule \u00b6 Type action Module chaosaws.cloudwatch.actions Name put_rule Return None Creates or updates a CloudWatch event rule. Please refer to https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/events.html#CloudWatchEvents.Client.put_rule for details on input arguments. Signature: def put_rule ( rule_name : str , schedule_expression : str = None , event_pattern : str = None , state : str = None , description : str = None , role_arn : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes schedule_expression string null No event_pattern string null No state string null No description string null No role_arn string null No Usage: { \"name\" : \"put-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"put_rule\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : put-rule provider : arguments : rule_name : '' func : put_rule module : chaosaws.cloudwatch.actions type : python type : action put_rule_targets \u00b6 Type action Module chaosaws.cloudwatch.actions Name put_rule_targets Return None Creates or update CloudWatch event rule targets. Please refer to https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/events.html#CloudWatchEvents.Client.put_targets for details on input arguments. Signature: def put_rule_targets ( rule_name : str , targets : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes targets list Yes Usage: { \"name\" : \"put-rule-targets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"targets\" : [], \"rule_name\" : \"\" }, \"func\" : \"put_rule_targets\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : put-rule-targets provider : arguments : rule_name : '' targets : [] func : put_rule_targets module : chaosaws.cloudwatch.actions type : python type : action remove_rule_targets \u00b6 Type action Module chaosaws.cloudwatch.actions Name remove_rule_targets Return None Removes CloudWatch rule targets. If no target ids are provided all targets will be removed. Signature: def remove_rule_targets ( rule_name : str , target_ids : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes target_ids list null No Usage: { \"name\" : \"remove-rule-targets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"remove_rule_targets\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : remove-rule-targets provider : arguments : rule_name : '' func : remove_rule_targets module : chaosaws.cloudwatch.actions type : python type : action ecs \u00b6 are_all_desired_tasks_running \u00b6 Type probe Module chaosaws.ecs.probes Name are_all_desired_tasks_running Return None Checks to make sure desired and running tasks counts are equal Signature: def are_all_desired_tasks_running ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"are-all-desired-tasks-running\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"service\" : \"\" , \"cluster\" : \"\" }, \"func\" : \"are_all_desired_tasks_running\" , \"module\" : \"chaosaws.ecs.probes\" } } name : are-all-desired-tasks-running provider : arguments : cluster : '' service : '' func : are_all_desired_tasks_running module : chaosaws.ecs.probes type : python type : probe delete_cluster \u00b6 Type action Module chaosaws.ecs.actions Name delete_cluster Return None Delete a given ECS cluster Signature: def delete_cluster ( cluster : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes Usage: { \"name\" : \"delete-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"cluster\" : \"\" }, \"func\" : \"delete_cluster\" , \"module\" : \"chaosaws.ecs.actions\" } } name : delete-cluster provider : arguments : cluster : '' func : delete_cluster module : chaosaws.ecs.actions type : python type : action delete_service \u00b6 Type action Module chaosaws.ecs.actions Name delete_service Return None Update a given ECS service by updating it to set the desired count of tasks to 0 then delete it. If not provided, a random one will be picked up regarding service_pattern , if provided, so that only service names matching the pattern would be be used. This should be a valid regex. You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. Signature: def delete_service ( service : str = None , cluster : str = None , service_pattern : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required service string null No cluster string null No service_pattern string null No Usage: { \"name\" : \"delete-service\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"delete_service\" , \"module\" : \"chaosaws.ecs.actions\" } } name : delete-service provider : func : delete_service module : chaosaws.ecs.actions type : python type : action deregister_container_instance \u00b6 Type action Module chaosaws.ecs.actions Name deregister_container_instance Return None Deregister a given ECS container. Becareful that tasks handled by this instance will remain orphan. Signature: def deregister_container_instance ( cluster : str , instance_id : str , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes instance_id string Yes force boolean false No Usage: { \"name\" : \"deregister-container-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"cluster\" : \"\" , \"instance_id\" : \"\" }, \"func\" : \"deregister_container_instance\" , \"module\" : \"chaosaws.ecs.actions\" } } name : deregister-container-instance provider : arguments : cluster : '' instance_id : '' func : deregister_container_instance module : chaosaws.ecs.actions type : python type : action service_is_deploying \u00b6 Type probe Module chaosaws.ecs.probes Name service_is_deploying Return None Checks to make sure there is not an in progress deployment Signature: def service_is_deploying ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"service-is-deploying\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"service\" : \"\" , \"cluster\" : \"\" }, \"func\" : \"service_is_deploying\" , \"module\" : \"chaosaws.ecs.probes\" } } name : service-is-deploying provider : arguments : cluster : '' service : '' func : service_is_deploying module : chaosaws.ecs.probes type : python type : probe stop_task \u00b6 Type action Module chaosaws.ecs.actions Name stop_task Return None Stop a given ECS task instance. If no task_id provided, a random task of the given service is stopped. You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. Signature: def stop_task ( cluster : str = None , task_id : str = None , service : str = None , reason : str = 'Chaos Testing' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string null No task_id string null No service string null No reason string \u201cChaos Testing\u201d No Usage: { \"name\" : \"stop-task\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"stop_task\" , \"module\" : \"chaosaws.ecs.actions\" } } name : stop-task provider : func : stop_task module : chaosaws.ecs.actions type : python type : action ec2 \u00b6 count_instances \u00b6 Type probe Module chaosaws.ec2.probes Name count_instances Return None Return count of instances matching the specified filters. Please refer to http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Client.describe_instances for details on said filters. Signature: def count_instances ( filters : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required filters list Yes Usage: { \"name\" : \"count-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"filters\" : [] }, \"func\" : \"count_instances\" , \"module\" : \"chaosaws.ec2.probes\" } } name : count-instances provider : arguments : filters : [] func : count_instances module : chaosaws.ec2.probes type : python type : probe describe_instances \u00b6 Type probe Module chaosaws.ec2.probes Name describe_instances Return None Describe instances following the specified filters. Please refer to http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Client.describe_instances for details on said filters. Signature: def describe_instances ( filters : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required filters list Yes Usage: { \"name\" : \"describe-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"filters\" : [] }, \"func\" : \"describe_instances\" , \"module\" : \"chaosaws.ec2.probes\" } } name : describe-instances provider : arguments : filters : [] func : describe_instances module : chaosaws.ec2.probes type : python type : probe stop_instance \u00b6 Type action Module chaosaws.ec2.actions Name stop_instance Return None Stop a single EC2 instance. You may provide an instance id explicitely or, if you only specify the AZ, a random instance will be selected. If you need more control, you can also provide a list of filters following the documentation https://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def stop_instance ( instance_id : str = None , az : str = None , force : bool = False , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string null No az string null No force boolean false No filters list null No Usage: { \"name\" : \"stop-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"stop_instance\" , \"module\" : \"chaosaws.ec2.actions\" } } name : stop-instance provider : func : stop_instance module : chaosaws.ec2.actions type : python type : action stop_instances \u00b6 Type action Module chaosaws.ec2.actions Name stop_instances Return None Stop the given EC2 instances or, if none is provided, all instances of the given availability zone. If you need more control, you can also provide a list of filters following the documentation https://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def stop_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No force boolean false No Usage: { \"name\" : \"stop-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"stop_instances\" , \"module\" : \"chaosaws.ec2.actions\" } } name : stop-instances provider : func : stop_instances module : chaosaws.ec2.actions type : python type : action iam \u00b6 attach_role_policy \u00b6 Type action Module chaosaws.iam.actions Name attach_role_policy Return None Attach a role to a policy. Signature: def attach_role_policy ( arn : str , role_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required arn string Yes role_name string Yes Usage: { \"name\" : \"attach-role-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"role_name\" : \"\" , \"arn\" : \"\" }, \"func\" : \"attach_role_policy\" , \"module\" : \"chaosaws.iam.actions\" } } name : attach-role-policy provider : arguments : arn : '' role_name : '' func : attach_role_policy module : chaosaws.iam.actions type : python type : action create_policy \u00b6 Type action Module chaosaws.iam.actions Name create_policy Return None Create a new IAM policy Signature: def create_policy ( name : str , policy : Dict [ str , Any ], path : str = '/' , description : str = '' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes policy mapping Yes path string \u201d/\u201d No description string \u201d\u201c No Usage: { \"name\" : \"create-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" , \"policy\" : {} }, \"func\" : \"create_policy\" , \"module\" : \"chaosaws.iam.actions\" } } name : create-policy provider : arguments : name : '' policy : {} func : create_policy module : chaosaws.iam.actions type : python type : action detach_role_policy \u00b6 Type action Module chaosaws.iam.actions Name detach_role_policy Return None Detach a role from a policy. Signature: def detach_role_policy ( arn : str , role_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required arn string Yes role_name string Yes Usage: { \"name\" : \"detach-role-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"role_name\" : \"\" , \"arn\" : \"\" }, \"func\" : \"detach_role_policy\" , \"module\" : \"chaosaws.iam.actions\" } } name : detach-role-policy provider : arguments : arn : '' role_name : '' func : detach_role_policy module : chaosaws.iam.actions type : python type : action get_policy \u00b6 Type probe Module chaosaws.iam.probes Name get_policy Return None Get a policy by its ARN Signature: def get_policy ( arn : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required arn string Yes Usage: { \"name\" : \"get-policy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"arn\" : \"\" }, \"func\" : \"get_policy\" , \"module\" : \"chaosaws.iam.probes\" } } name : get-policy provider : arguments : arn : '' func : get_policy module : chaosaws.iam.probes type : python type : probe","title":"AWS"},{"location":"drivers/aws/#extension-chaosaws","text":"Version 0.9.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-aws This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit .","title":"Extension chaosaws"},{"location":"drivers/aws/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-aws","title":"Install"},{"location":"drivers/aws/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"name\" : \"stop-an-ec2-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"arguments\" : { \"instance_id\" : \"i-123456\" } } } , { \"name\" : \"create-a-new-policy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"create_policy\" , \"arguments\" : { \"name\" : \"mypolicy\" , \"path\" : \"user/Jane\" , \"policy\" : { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"s3:ListAllMyBuckets\" , \"s3:GetBucketLocation\" ], \"Resource\" : \"arn:aws:s3:::*\" } ] } } } } Or select one at random from an AZ: { \"name\" : \"stop-an-ec2-instance-in-az-at-random\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"arguments\" : { \"az\" : \"us-west-1\" } } } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/aws/#configuration","text":"","title":"Configuration"},{"location":"drivers/aws/#credentials","text":"This extension uses the boto3 library under the hood. This library expects that you have properly configured your environment to connect and authenticate with the AWS services. Generally speaking, there are two ways of doing this: you have configured the environment where you will run the experiment from (any of the user-wide credential sources would do). You may also provide a profile name to assume a role . { \"configuration\" : { \"aws_profile_name\" : \"dev\" } } you explicitely pass the correct environment variables to the experiment definition as follows: { \"secrets\" : { \"aws\" : { \"aws_access_key_id\" : \"your key\" , \"aws_secret_access_key\" : \"access key\" , \"aws_session_token\" : \"token\" , } } } Note that the token is optional. Then, use it as follows: ```json { \"name\": \"stop-an-ec2-instance\", \"provider\": { \"type\": \"python\", \"module\": \"chaosaws.ec2.actions\", \"func\": \"stop_instance\", \"secrets\": [\"aws\"], \"arguments\": { \"instance_id\": \"i-123456\" } } } ```","title":"Credentials"},{"location":"drivers/aws/#other-aws-settings","text":"In additon to the authentication credentials, you can configure the region against which you want to use. At the top level of the experiment, add: { \"configuration\" : { \"aws_region\" : \"us-east-1\" } }","title":"Other AWS settings"},{"location":"drivers/aws/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/aws/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/aws/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/aws/#add-new-aws-api-support","text":"Once you have setup your environment, you can start adding new AWS API support by adding new actions, probes and entire sub-packages for those.","title":"Add new AWS API Support"},{"location":"drivers/aws/#services-supported-by-boto","text":"This package relies on boto3 to wrap the API calls into a fluent Python API. Some newer AWS services are not yet available in boto3, in that case, you should read the next section. Let\u2019s say you want to support a new action in the EC2 sub-package. Start by creating a new function in ec2/actions.py : from chaoslib.types import Configuration , Secrets from chaosaws import aws_client from chaosaws.types import AWSResponse def reboot_instance ( instance_id : str , dry_run : bool = False , configuration : Configuration = None , secrets : Secrets = None ) -> AWSResponse : \"\"\" Reboot a given EC2 instance. \"\"\" client = aws_client ( 'ec2' , configuration , secrets ) return client . reboot_instances ( InstanceIds = [ instance_id ], DryRun = dry_run ) As you can see, the actual code is straightforward. You first create a EC2 client and simply call the appropriate method on that client with the expected arguments. We return the action as-is so that it can be logged by the chaostoolkit, or even be used as part of a steady-state hypothesis probe (if this was a probe, not action that is). You could decide to make more than one AWS API call but, it is better to keep it simple so that composition is easier from the experiment. Nonetheless, you may also compose those directly into a single action as well for specific use-cases. Please refer to the Chaos Toolkit documentation to learn more about the configuration and secrets objects. Once you have implemented that action, you must create at least one unit test for it in the tests/ec2/test_ec2_actions.py test module. For example: from chaosaws.ec2.actions import reboot_instancex @patch ( 'chaosaws.ec2.actions.aws_client' , autospec = True ) def test_reboot_instance ( aws_client ): client = MagicMock () aws_client . return_value = client inst_id = \"i-1234567890abcdef0\" response = reboot_instance ( inst_id ) client . reboot_instances . assert_called_with ( InstanceIds = [ inst_id ], DryRun = False ) By using the built-in Python module to mock objects , we can mock the EC2 client and assert we edo indeed call the appropriate method with the right arguments. You are encouraged to write more than a single test for various conditions. Finally, should you choose to add support for a new AWS API resource altogether, you should create the according sub-package.","title":"Services supported by boto"},{"location":"drivers/aws/#services-not-supported-by-boto-new-aws-features","text":"If the support you want to provide is for a new AWS service that boto does not support yet, this requires direct call to the API endpoint via the requests package. Say we have a new service, not yet supported by boto3 from chaoslib.types import Configuration , Secrets from chaosaws import signed_api_call from chaosaws.types import AWSResponse def terminate_worker_node ( worker_node_id : str , configuration : Configuration = None , secrets : Secrets = None ) -> AWSResponse : \"\"\" Terminate a worker node. \"\"\" params = { \"DryRun\" : True , \"WorkerNodeId.1\" : worker_node_id } response = signed_api_call ( 'some-new-service-name' , path = '/2018-01-01/worker/terminate' , method = 'POST' , params = params , configuration = configuration , secrets = secrets ) return response . json () Here is an example on existing API call (as a more concrete snippet): from chaoslib.types import Configuration , Secrets from chaosaws import signed_api_call def stop_instance ( instance_id : str , configuration : Configuration = None , secrets : Secrets = None ) -> str : response = signed_api_call ( 'ec2' , configuration = configuration , secrets = secrets , params = { \"Action\" : \"StopInstances\" , \"InstanceId.1\" : instance_id , \"Version\" : \"2013-06-15\" } ) # this API returns XML, not JSON return response . text When using the signed_api_call , you are responsible for the right way of passing the parameters. Basically, look at the AWS documentation for each API call. WARNING: It should be noted that, whenever boto3 implements an API, this package should be updated accordingly, as boto3 is much more versatile and solid.","title":"Services not supported by boto (new AWS features)"},{"location":"drivers/aws/#make-your-new-sub-package-discoverable","text":"Finally, if you have created a new sub-package entirely, you need to make its capability discoverable by the chaos toolkit. Simply amend the discover function in the chaosaws/__init__.py . For example, assuming a new eks sub-package, with actions and probes: activities . extend ( discover_actions ( \"chaosaws.eks.actions\" )) activities . extend ( discover_probes ( \"chaosaws.eks.probes\" ))","title":"Make your new sub-package discoverable"},{"location":"drivers/aws/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/aws/#awslambda","text":"","title":"awslambda"},{"location":"drivers/aws/#delete_function_concurrency","text":"Type action Module chaosaws.awslambda.actions Name delete_function_concurrency Return None Removes concurrency limit applied to the specified Lambda Signature: def delete_function_concurrency ( function_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes Usage: { \"name\" : \"delete-function-concurrency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"delete_function_concurrency\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : delete-function-concurrency provider : arguments : function_name : '' func : delete_function_concurrency module : chaosaws.awslambda.actions type : python type : action","title":"delete_function_concurrency"},{"location":"drivers/aws/#get_function_concurrency","text":"Type probe Module chaosaws.awslambda.probes Name get_function_concurrency Return None Get configuration information of lambda by its function name Signature: def get_function_concurrency ( function_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required function_name string Yes Usage: { \"name\" : \"get-function-concurrency\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"get_function_concurrency\" , \"module\" : \"chaosaws.awslambda.probes\" } } name : get-function-concurrency provider : arguments : function_name : '' func : get_function_concurrency module : chaosaws.awslambda.probes type : python type : probe","title":"get_function_concurrency"},{"location":"drivers/aws/#get_function_memory_size","text":"Type probe Module chaosaws.awslambda.probes Name get_function_memory_size Return None Get the configured memory size of a lambda function. The returned memory size is specified in megabytes. Signature: def get_function_memory_size ( function_name : str , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required function_name string Yes qualifier string null No Usage: { \"name\" : \"get-function-memory-size\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"get_function_memory_size\" , \"module\" : \"chaosaws.awslambda.probes\" } } name : get-function-memory-size provider : arguments : function_name : '' func : get_function_memory_size module : chaosaws.awslambda.probes type : python type : probe","title":"get_function_memory_size"},{"location":"drivers/aws/#get_function_timeout","text":"Type probe Module chaosaws.awslambda.probes Name get_function_timeout Return None Get the configured timeout of a lambda function. The returned timeout is specified in number of seconds. Signature: def get_function_timeout ( function_name : str , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required function_name string Yes qualifier string null No Usage: { \"name\" : \"get-function-timeout\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"get_function_timeout\" , \"module\" : \"chaosaws.awslambda.probes\" } } name : get-function-timeout provider : arguments : function_name : '' func : get_function_timeout module : chaosaws.awslambda.probes type : python type : probe","title":"get_function_timeout"},{"location":"drivers/aws/#invoke_function","text":"Type action Module chaosaws.awslambda.actions Name invoke_function Return None Invokes Lambda. More information about request arguments are available in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/lambda.html#Lambda.Client.invoke Signature: def invoke_function ( function_name : str , function_arguments : Dict [ str , Any ] = None , invocation_type : str = 'RequestResponse' , client_context : Dict [ str , Any ] = None , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes function_arguments mapping null No invocation_type string \u201cRequestResponse\u201d No client_context mapping null No qualifier string null No Usage: { \"name\" : \"invoke-function\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" }, \"func\" : \"invoke_function\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : invoke-function provider : arguments : function_name : '' func : invoke_function module : chaosaws.awslambda.actions type : python type : action","title":"invoke_function"},{"location":"drivers/aws/#put_function_concurrency","text":"Type action Module chaosaws.awslambda.actions Name put_function_concurrency Return None Throttles Lambda by setting reserved concurrency amount. Signature: def put_function_concurrency ( function_name : str , concurrent_executions : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes concurrent_executions integer Yes Usage: { \"name\" : \"put-function-concurrency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" , \"concurrent_executions\" : 0 }, \"func\" : \"put_function_concurrency\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : put-function-concurrency provider : arguments : concurrent_executions : 0 function_name : '' func : put_function_concurrency module : chaosaws.awslambda.actions type : python type : action","title":"put_function_concurrency"},{"location":"drivers/aws/#put_function_memory_size","text":"Type action Module chaosaws.awslambda.actions Name put_function_memory_size Return None Sets the function memory size. Input memory_size argument is specified in megabytes. Signature: def put_function_memory_size ( function_name : str , memory_size : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes memory_size integer Yes Usage: { \"name\" : \"put-function-memory-size\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" , \"memory_size\" : 0 }, \"func\" : \"put_function_memory_size\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : put-function-memory-size provider : arguments : function_name : '' memory_size : 0 func : put_function_memory_size module : chaosaws.awslambda.actions type : python type : action","title":"put_function_memory_size"},{"location":"drivers/aws/#put_function_timeout","text":"Type action Module chaosaws.awslambda.actions Name put_function_timeout Return None Sets the function timeout. Input timeout argument is specified in seconds. Signature: def put_function_timeout ( function_name : str , timeout : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes timeout integer Yes Usage: { \"name\" : \"put-function-timeout\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"function_name\" : \"\" , \"timeout\" : 0 }, \"func\" : \"put_function_timeout\" , \"module\" : \"chaosaws.awslambda.actions\" } } name : put-function-timeout provider : arguments : function_name : '' timeout : 0 func : put_function_timeout module : chaosaws.awslambda.actions type : python type : action","title":"put_function_timeout"},{"location":"drivers/aws/#eks","text":"","title":"eks"},{"location":"drivers/aws/#create_cluster","text":"Type action Module chaosaws.eks.actions Name create_cluster Return None Create a new EKS cluster. Signature: def create_cluster ( name : str , role_arn : str , vpc_config : Dict [ str , Any ], version : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes role_arn string Yes vpc_config mapping Yes version string null No Usage: { \"name\" : \"create-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" , \"role_arn\" : \"\" , \"vpc_config\" : {} }, \"func\" : \"create_cluster\" , \"module\" : \"chaosaws.eks.actions\" } } name : create-cluster provider : arguments : name : '' role_arn : '' vpc_config : {} func : create_cluster module : chaosaws.eks.actions type : python type : action","title":"create_cluster"},{"location":"drivers/aws/#delete_cluster","text":"Type action Module chaosaws.eks.actions Name delete_cluster Return None Delete the given EKS cluster. Signature: def delete_cluster ( name : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string null No Usage: { \"name\" : \"delete-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"delete_cluster\" , \"module\" : \"chaosaws.eks.actions\" } } name : delete-cluster provider : func : delete_cluster module : chaosaws.eks.actions type : python type : action","title":"delete_cluster"},{"location":"drivers/aws/#describe_cluster","text":"Type probe Module chaosaws.eks.probes Name describe_cluster Return None Describe an EKS cluster. Signature: def describe_cluster ( name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes Usage: { \"name\" : \"describe-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"describe_cluster\" , \"module\" : \"chaosaws.eks.probes\" } } name : describe-cluster provider : arguments : name : '' func : describe_cluster module : chaosaws.eks.probes type : python type : probe","title":"describe_cluster"},{"location":"drivers/aws/#list_clusters","text":"Type probe Module chaosaws.eks.probes Name list_clusters Return None List EKS clusters available to the authenticated account. Signature: def list_clusters ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-clusters\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"list_clusters\" , \"module\" : \"chaosaws.eks.probes\" } } name : list-clusters provider : func : list_clusters module : chaosaws.eks.probes type : python type : probe","title":"list_clusters"},{"location":"drivers/aws/#elbv2","text":"","title":"elbv2"},{"location":"drivers/aws/#all_targets_healthy","text":"Type probe Module chaosaws.elbv2.probes Name all_targets_healthy Return None Return true/false based on if all targets for listed target groups are healthy Signature: def all_targets_healthy ( tg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_names list Yes Usage: { \"name\" : \"all-targets-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"tg_names\" : [] }, \"func\" : \"all_targets_healthy\" , \"module\" : \"chaosaws.elbv2.probes\" } } name : all-targets-healthy provider : arguments : tg_names : [] func : all_targets_healthy module : chaosaws.elbv2.probes type : python type : probe","title":"all_targets_healthy"},{"location":"drivers/aws/#deregister_target","text":"Type action Module chaosaws.elbv2.actions Name deregister_target Return None Deregisters one random target from target group Signature: def deregister_target ( tg_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_name string Yes Usage: { \"name\" : \"deregister-target\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"tg_name\" : \"\" }, \"func\" : \"deregister_target\" , \"module\" : \"chaosaws.elbv2.actions\" } } name : deregister-target provider : arguments : tg_name : '' func : deregister_target module : chaosaws.elbv2.actions type : python type : action","title":"deregister_target"},{"location":"drivers/aws/#targets_health_count","text":"Type probe Module chaosaws.elbv2.probes Name targets_health_count Return None Count of healthy/unhealthy targets per targetgroup Signature: def targets_health_count ( tg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_names list Yes Usage: { \"name\" : \"targets-health-count\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"tg_names\" : [] }, \"func\" : \"targets_health_count\" , \"module\" : \"chaosaws.elbv2.probes\" } } name : targets-health-count provider : arguments : tg_names : [] func : targets_health_count module : chaosaws.elbv2.probes type : python type : probe","title":"targets_health_count"},{"location":"drivers/aws/#cloudwatch","text":"","title":"cloudwatch"},{"location":"drivers/aws/#delete_rule","text":"Type action Module chaosaws.cloudwatch.actions Name delete_rule Return None Deletes a CloudWatch rule. All rule targets must be removed before deleting the rule. Set input argument force to True to force all rule targets to be deleted. Signature: def delete_rule ( rule_name : str , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes force boolean false No Usage: { \"name\" : \"delete-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"delete_rule\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : delete-rule provider : arguments : rule_name : '' func : delete_rule module : chaosaws.cloudwatch.actions type : python type : action","title":"delete_rule"},{"location":"drivers/aws/#disable_rule","text":"Type action Module chaosaws.cloudwatch.actions Name disable_rule Return None Disables a CloudWatch rule. Signature: def disable_rule ( rule_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes Usage: { \"name\" : \"disable-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"disable_rule\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : disable-rule provider : arguments : rule_name : '' func : disable_rule module : chaosaws.cloudwatch.actions type : python type : action","title":"disable_rule"},{"location":"drivers/aws/#enable_rule","text":"Type action Module chaosaws.cloudwatch.actions Name enable_rule Return None Enables a CloudWatch rule. Signature: def enable_rule ( rule_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes Usage: { \"name\" : \"enable-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"enable_rule\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : enable-rule provider : arguments : rule_name : '' func : enable_rule module : chaosaws.cloudwatch.actions type : python type : action","title":"enable_rule"},{"location":"drivers/aws/#get_alarm_state_value","text":"Type probe Module chaosaws.cloudwatch.probes Name get_alarm_state_value Return None Return the state value of an alarm. The possbile alarm state values are described in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.describe_alarms Signature: def get_alarm_state_value ( alarm_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required alarm_name string Yes Usage: { \"name\" : \"get-alarm-state-value\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"alarm_name\" : \"\" }, \"func\" : \"get_alarm_state_value\" , \"module\" : \"chaosaws.cloudwatch.probes\" } } name : get-alarm-state-value provider : arguments : alarm_name : '' func : get_alarm_state_value module : chaosaws.cloudwatch.probes type : python type : probe","title":"get_alarm_state_value"},{"location":"drivers/aws/#get_metric_statistics","text":"Type probe Module chaosaws.cloudwatch.probes Name get_metric_statistics Return None Get the value of a statistical calculation for a given metric. The period for which the calculation will be performed is specified by a duration and an offset from the current time. Both are specified in seconds. Example: A duration of 60 seconds and an offset of 30 seconds will yield a statistical value based on the time interval between 30 and 90 seconds in the past. More information about input parameters are available in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_statistics Signature: def get_metric_statistics ( namespace : str , metric_name : str , dimension_name : str , dimension_value : str , duration : int = 60 , offset : int = 0 , statistic : str = None , extended_statistic : str = None , unit : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required namespace string Yes metric_name string Yes dimension_name string Yes dimension_value string Yes duration integer 60 No offset integer 0 No statistic string null No extended_statistic string null No unit string null No Usage: { \"name\" : \"get-metric-statistics\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"dimension_name\" : \"\" , \"namespace\" : \"\" , \"dimension_value\" : \"\" , \"metric_name\" : \"\" }, \"func\" : \"get_metric_statistics\" , \"module\" : \"chaosaws.cloudwatch.probes\" } } name : get-metric-statistics provider : arguments : dimension_name : '' dimension_value : '' metric_name : '' namespace : '' func : get_metric_statistics module : chaosaws.cloudwatch.probes type : python type : probe","title":"get_metric_statistics"},{"location":"drivers/aws/#put_rule","text":"Type action Module chaosaws.cloudwatch.actions Name put_rule Return None Creates or updates a CloudWatch event rule. Please refer to https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/events.html#CloudWatchEvents.Client.put_rule for details on input arguments. Signature: def put_rule ( rule_name : str , schedule_expression : str = None , event_pattern : str = None , state : str = None , description : str = None , role_arn : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes schedule_expression string null No event_pattern string null No state string null No description string null No role_arn string null No Usage: { \"name\" : \"put-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"put_rule\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : put-rule provider : arguments : rule_name : '' func : put_rule module : chaosaws.cloudwatch.actions type : python type : action","title":"put_rule"},{"location":"drivers/aws/#put_rule_targets","text":"Type action Module chaosaws.cloudwatch.actions Name put_rule_targets Return None Creates or update CloudWatch event rule targets. Please refer to https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/events.html#CloudWatchEvents.Client.put_targets for details on input arguments. Signature: def put_rule_targets ( rule_name : str , targets : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes targets list Yes Usage: { \"name\" : \"put-rule-targets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"targets\" : [], \"rule_name\" : \"\" }, \"func\" : \"put_rule_targets\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : put-rule-targets provider : arguments : rule_name : '' targets : [] func : put_rule_targets module : chaosaws.cloudwatch.actions type : python type : action","title":"put_rule_targets"},{"location":"drivers/aws/#remove_rule_targets","text":"Type action Module chaosaws.cloudwatch.actions Name remove_rule_targets Return None Removes CloudWatch rule targets. If no target ids are provided all targets will be removed. Signature: def remove_rule_targets ( rule_name : str , target_ids : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes target_ids list null No Usage: { \"name\" : \"remove-rule-targets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"rule_name\" : \"\" }, \"func\" : \"remove_rule_targets\" , \"module\" : \"chaosaws.cloudwatch.actions\" } } name : remove-rule-targets provider : arguments : rule_name : '' func : remove_rule_targets module : chaosaws.cloudwatch.actions type : python type : action","title":"remove_rule_targets"},{"location":"drivers/aws/#ecs","text":"","title":"ecs"},{"location":"drivers/aws/#are_all_desired_tasks_running","text":"Type probe Module chaosaws.ecs.probes Name are_all_desired_tasks_running Return None Checks to make sure desired and running tasks counts are equal Signature: def are_all_desired_tasks_running ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"are-all-desired-tasks-running\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"service\" : \"\" , \"cluster\" : \"\" }, \"func\" : \"are_all_desired_tasks_running\" , \"module\" : \"chaosaws.ecs.probes\" } } name : are-all-desired-tasks-running provider : arguments : cluster : '' service : '' func : are_all_desired_tasks_running module : chaosaws.ecs.probes type : python type : probe","title":"are_all_desired_tasks_running"},{"location":"drivers/aws/#delete_cluster_1","text":"Type action Module chaosaws.ecs.actions Name delete_cluster Return None Delete a given ECS cluster Signature: def delete_cluster ( cluster : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes Usage: { \"name\" : \"delete-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"cluster\" : \"\" }, \"func\" : \"delete_cluster\" , \"module\" : \"chaosaws.ecs.actions\" } } name : delete-cluster provider : arguments : cluster : '' func : delete_cluster module : chaosaws.ecs.actions type : python type : action","title":"delete_cluster"},{"location":"drivers/aws/#delete_service","text":"Type action Module chaosaws.ecs.actions Name delete_service Return None Update a given ECS service by updating it to set the desired count of tasks to 0 then delete it. If not provided, a random one will be picked up regarding service_pattern , if provided, so that only service names matching the pattern would be be used. This should be a valid regex. You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. Signature: def delete_service ( service : str = None , cluster : str = None , service_pattern : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required service string null No cluster string null No service_pattern string null No Usage: { \"name\" : \"delete-service\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"delete_service\" , \"module\" : \"chaosaws.ecs.actions\" } } name : delete-service provider : func : delete_service module : chaosaws.ecs.actions type : python type : action","title":"delete_service"},{"location":"drivers/aws/#deregister_container_instance","text":"Type action Module chaosaws.ecs.actions Name deregister_container_instance Return None Deregister a given ECS container. Becareful that tasks handled by this instance will remain orphan. Signature: def deregister_container_instance ( cluster : str , instance_id : str , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes instance_id string Yes force boolean false No Usage: { \"name\" : \"deregister-container-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"cluster\" : \"\" , \"instance_id\" : \"\" }, \"func\" : \"deregister_container_instance\" , \"module\" : \"chaosaws.ecs.actions\" } } name : deregister-container-instance provider : arguments : cluster : '' instance_id : '' func : deregister_container_instance module : chaosaws.ecs.actions type : python type : action","title":"deregister_container_instance"},{"location":"drivers/aws/#service_is_deploying","text":"Type probe Module chaosaws.ecs.probes Name service_is_deploying Return None Checks to make sure there is not an in progress deployment Signature: def service_is_deploying ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"service-is-deploying\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"service\" : \"\" , \"cluster\" : \"\" }, \"func\" : \"service_is_deploying\" , \"module\" : \"chaosaws.ecs.probes\" } } name : service-is-deploying provider : arguments : cluster : '' service : '' func : service_is_deploying module : chaosaws.ecs.probes type : python type : probe","title":"service_is_deploying"},{"location":"drivers/aws/#stop_task","text":"Type action Module chaosaws.ecs.actions Name stop_task Return None Stop a given ECS task instance. If no task_id provided, a random task of the given service is stopped. You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. Signature: def stop_task ( cluster : str = None , task_id : str = None , service : str = None , reason : str = 'Chaos Testing' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string null No task_id string null No service string null No reason string \u201cChaos Testing\u201d No Usage: { \"name\" : \"stop-task\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"stop_task\" , \"module\" : \"chaosaws.ecs.actions\" } } name : stop-task provider : func : stop_task module : chaosaws.ecs.actions type : python type : action","title":"stop_task"},{"location":"drivers/aws/#ec2","text":"","title":"ec2"},{"location":"drivers/aws/#count_instances","text":"Type probe Module chaosaws.ec2.probes Name count_instances Return None Return count of instances matching the specified filters. Please refer to http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Client.describe_instances for details on said filters. Signature: def count_instances ( filters : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required filters list Yes Usage: { \"name\" : \"count-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"filters\" : [] }, \"func\" : \"count_instances\" , \"module\" : \"chaosaws.ec2.probes\" } } name : count-instances provider : arguments : filters : [] func : count_instances module : chaosaws.ec2.probes type : python type : probe","title":"count_instances"},{"location":"drivers/aws/#describe_instances","text":"Type probe Module chaosaws.ec2.probes Name describe_instances Return None Describe instances following the specified filters. Please refer to http://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Client.describe_instances for details on said filters. Signature: def describe_instances ( filters : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required filters list Yes Usage: { \"name\" : \"describe-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"filters\" : [] }, \"func\" : \"describe_instances\" , \"module\" : \"chaosaws.ec2.probes\" } } name : describe-instances provider : arguments : filters : [] func : describe_instances module : chaosaws.ec2.probes type : python type : probe","title":"describe_instances"},{"location":"drivers/aws/#stop_instance","text":"Type action Module chaosaws.ec2.actions Name stop_instance Return None Stop a single EC2 instance. You may provide an instance id explicitely or, if you only specify the AZ, a random instance will be selected. If you need more control, you can also provide a list of filters following the documentation https://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def stop_instance ( instance_id : str = None , az : str = None , force : bool = False , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string null No az string null No force boolean false No filters list null No Usage: { \"name\" : \"stop-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"stop_instance\" , \"module\" : \"chaosaws.ec2.actions\" } } name : stop-instance provider : func : stop_instance module : chaosaws.ec2.actions type : python type : action","title":"stop_instance"},{"location":"drivers/aws/#stop_instances","text":"Type action Module chaosaws.ec2.actions Name stop_instances Return None Stop the given EC2 instances or, if none is provided, all instances of the given availability zone. If you need more control, you can also provide a list of filters following the documentation https://boto3.readthedocs.io/en/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def stop_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No force boolean false No Usage: { \"name\" : \"stop-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"stop_instances\" , \"module\" : \"chaosaws.ec2.actions\" } } name : stop-instances provider : func : stop_instances module : chaosaws.ec2.actions type : python type : action","title":"stop_instances"},{"location":"drivers/aws/#iam","text":"","title":"iam"},{"location":"drivers/aws/#attach_role_policy","text":"Type action Module chaosaws.iam.actions Name attach_role_policy Return None Attach a role to a policy. Signature: def attach_role_policy ( arn : str , role_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required arn string Yes role_name string Yes Usage: { \"name\" : \"attach-role-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"role_name\" : \"\" , \"arn\" : \"\" }, \"func\" : \"attach_role_policy\" , \"module\" : \"chaosaws.iam.actions\" } } name : attach-role-policy provider : arguments : arn : '' role_name : '' func : attach_role_policy module : chaosaws.iam.actions type : python type : action","title":"attach_role_policy"},{"location":"drivers/aws/#create_policy","text":"Type action Module chaosaws.iam.actions Name create_policy Return None Create a new IAM policy Signature: def create_policy ( name : str , policy : Dict [ str , Any ], path : str = '/' , description : str = '' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes policy mapping Yes path string \u201d/\u201d No description string \u201d\u201c No Usage: { \"name\" : \"create-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" , \"policy\" : {} }, \"func\" : \"create_policy\" , \"module\" : \"chaosaws.iam.actions\" } } name : create-policy provider : arguments : name : '' policy : {} func : create_policy module : chaosaws.iam.actions type : python type : action","title":"create_policy"},{"location":"drivers/aws/#detach_role_policy","text":"Type action Module chaosaws.iam.actions Name detach_role_policy Return None Detach a role from a policy. Signature: def detach_role_policy ( arn : str , role_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required arn string Yes role_name string Yes Usage: { \"name\" : \"detach-role-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"role_name\" : \"\" , \"arn\" : \"\" }, \"func\" : \"detach_role_policy\" , \"module\" : \"chaosaws.iam.actions\" } } name : detach-role-policy provider : arguments : arn : '' role_name : '' func : detach_role_policy module : chaosaws.iam.actions type : python type : action","title":"detach_role_policy"},{"location":"drivers/aws/#get_policy","text":"Type probe Module chaosaws.iam.probes Name get_policy Return None Get a policy by its ARN Signature: def get_policy ( arn : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required arn string Yes Usage: { \"name\" : \"get-policy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"arn\" : \"\" }, \"func\" : \"get_policy\" , \"module\" : \"chaosaws.iam.probes\" } } name : get-policy provider : arguments : arn : '' func : get_policy module : chaosaws.iam.probes type : python type : probe","title":"get_policy"},{"location":"drivers/azure/","text":"","title":"Azure"},{"location":"drivers/cloudfoundry/","text":"Extension chaoscf \u00b6 Version 0.6.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-cloud-foundry This extension package provides probes and actions for Chaos Engineering experiments against a Cloud Foundry instance using the Chaos Toolkit . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-cloud-foundry Usage \u00b6 To use the probes and actions from this package, add a similar payload to your experiment file: { \"type\" : \"action\" , \"name\" : \"terminate-random-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"terminate_some_random_instance\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } } , { \"type\" : \"probe\" , \"name\" : \"fetch-app-statistics\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } } That\u2019s it! Please explore the code to see existing probes and actions. Discovery \u00b6 You may use the Chaos Toolkit to discover the capabilities of this extension: $ chaos discover chaostoolkit-cloud-foundry --no-install If you have logged in against a Cloud Foundry environment, this will discover information about it along the way. Configuration \u00b6 This extension to the Chaos Toolkit need credentials to a Cloud Foundry account with appropriate scopes. Please add the following sections to your experiment file: { \"configuration\" : { \"cf_api_url\" : \"https://api.local.pcfdev.io\" , \"cf_verify_ssl\" : false }, \"secrets\" : { \"cloudfoundry\" : { \"cf_username\" : \"user\" , \"cf_password\" : \"pass\" } } } You may leave \"cf_verifiy_ssl\" out of the configuration when you want to verify TLS certificates. Usually, local environments are self-signed so it may be useful to disable that check in that case. You may also specify the \"cf_client_id\" and \"cf_client_secret\" secrets when you need. Their default values are \"cf\" and \"\" respectively. These work well against a local PCF dev install. Then in your probe or action: { \"type\" : \"probe\" , \"name\" : \"fetch-app-statistics\" , \"provider\" : { \"type\" : \"python\" , \"secrets\" : [ \"cloudfoundry\" ], \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } } Test \u00b6 To run the tests for the project execute the following: $ pip install -r requirements-dev.txt $ pytest Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit project requires all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 probes \u00b6 get_app_stats \u00b6 Type probe Module chaoscf.probes Name get_app_stats Return None Fetch the metrics of the given application. See https://apidocs.cloudfoundry.org/280/apps/get_detailed_stats_for_a_started_app.html for more information. Signature: def get_app_stats ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"get-app-stats\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"get_app_stats\" , \"module\" : \"chaoscf.probes\" } } name : get-app-stats provider : arguments : app_name : '' func : get_app_stats module : chaoscf.probes type : python type : probe list_apps \u00b6 Type probe Module chaoscf.probes Name list_apps Return None List all applications available to the authorized user. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html to understand the content of the response. Signature: def list_apps ( configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-apps\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"list_apps\" , \"module\" : \"chaoscf.probes\" } } name : list-apps provider : func : list_apps module : chaoscf.probes type : python type : probe actions \u00b6 delete_app \u00b6 Type action Module chaoscf.actions Name delete_app Return None Delete application. See https://apidocs.cloudfoundry.org/280/apps/delete_a_particular_app.html Signature: def delete_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"delete-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"delete_app\" , \"module\" : \"chaoscf.actions\" } } name : delete-app provider : arguments : app_name : '' func : delete_app module : chaoscf.actions type : python type : action map_route_to_app \u00b6 Type action Module chaoscf.actions Name map_route_to_app Return None Map a specific route to a given application. As Domains are deprecated in the Cloud Foundry API, they are not specified here. See https://apidocs.cloudfoundry.org/280/#domains--deprecated- See https://www.cloudfoundry.org/blog/coming-changes-app-manifest-simplification/ See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def map_route_to_app ( app_name : str , host_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes host_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"map-route-to-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"host_name\" : \"\" }, \"func\" : \"map_route_to_app\" , \"module\" : \"chaoscf.actions\" } } name : map-route-to-app provider : arguments : app_name : '' host_name : '' func : map_route_to_app module : chaoscf.actions type : python type : action remove_routes_from_app \u00b6 Type action Module chaoscf.actions Name remove_routes_from_app Return None Remove routes from a given application. See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def remove_routes_from_app ( app_name : str , route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes route_host string Yes org_name string null No space_name string null No Usage: { \"name\" : \"remove-routes-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"route_host\" : \"\" }, \"func\" : \"remove_routes_from_app\" , \"module\" : \"chaoscf.actions\" } } name : remove-routes-from-app provider : arguments : app_name : '' route_host : '' func : remove_routes_from_app module : chaoscf.actions type : python type : action stop_app \u00b6 Type action Module chaoscf.actions Name stop_app Return None Stop application See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def stop_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"stop-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"stop_app\" , \"module\" : \"chaoscf.actions\" } } name : stop-app provider : arguments : app_name : '' func : stop_app module : chaoscf.actions type : python type : action terminate_app_instance \u00b6 Type action Module chaoscf.actions Name terminate_app_instance Return None Terminate the application\u2019s instance at the given index. See https://apidocs.cloudfoundry.org/280/apps/terminate_the_running_app_instance_at_the_given_index.html Signature: def terminate_app_instance ( app_name : str , instance_index : int , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes instance_index integer Yes org_name string null No space_name string null No Usage: { \"name\" : \"terminate-app-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"instance_index\" : 0 }, \"func\" : \"terminate_app_instance\" , \"module\" : \"chaoscf.actions\" } } name : terminate-app-instance provider : arguments : app_name : '' instance_index : 0 func : terminate_app_instance module : chaoscf.actions type : python type : action terminate_some_random_instance \u00b6 Type action Module chaoscf.actions Name terminate_some_random_instance Return None Terminate a random application\u2019s instance. See https://apidocs.cloudfoundry.org/280/apps/terminate_the_running_app_instance_at_the_given_index.html Signature: def terminate_some_random_instance ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"terminate-some-random-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"terminate_some_random_instance\" , \"module\" : \"chaoscf.actions\" } } name : terminate-some-random-instance provider : arguments : app_name : '' func : terminate_some_random_instance module : chaoscf.actions type : python type : action unbind_service_from_app \u00b6 Type action Module chaoscf.actions Name unbind_service_from_app Return None Unbind the service from the given application. See https://apidocs.cloudfoundry.org/280/service_bindings/delete_a_particular_service_binding.html Signature: def unbind_service_from_app ( app_name : str , bind_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes bind_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"unbind-service-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"bind_name\" : \"\" }, \"func\" : \"unbind_service_from_app\" , \"module\" : \"chaoscf.actions\" } } name : unbind-service-from-app provider : arguments : app_name : '' bind_name : '' func : unbind_service_from_app module : chaoscf.actions type : python type : action unmap_route_from_app \u00b6 Type action Module chaoscf.actions Name unmap_route_from_app Return None Unmap a specific route from a given application. As Domains are deprecated in the Cloud Foundry API, they are not specified here. See https://apidocs.cloudfoundry.org/280/#domains--deprecated- See https://www.cloudfoundry.org/blog/coming-changes-app-manifest-simplification/ See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def unmap_route_from_app ( app_name : str , host_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes host_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"unmap-route-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"host_name\" : \"\" }, \"func\" : \"unmap_route_from_app\" , \"module\" : \"chaoscf.actions\" } } name : unmap-route-from-app provider : arguments : app_name : '' host_name : '' func : unmap_route_from_app module : chaoscf.actions type : python type : action api \u00b6 call_api \u00b6 Type Module chaoscf.api Name call_api Return None Perform a Cloud Foundry API call and return the full response to the caller. Signature: def call_api ( path : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], query : Dict [ str , Any ] = None , body : Dict [ str , Any ] = None , method : str = 'GET' , headers : Dict [ str , str ] = None ) -> requests . models . Response : pass Arguments: Name Type Default Required path string Yes query mapping null No body mapping null No method string \u201cGET\u201d No headers mapping null No Usage: { \"name\" : \"call-api\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"path\" : \"\" }, \"func\" : \"call_api\" , \"module\" : \"chaoscf.api\" } } name : call-api provider : arguments : path : '' func : call_api module : chaoscf.api type : python type : '' get_app_by_name \u00b6 Type Module chaoscf.api Name get_app_by_name Return None Get the application with the given name. You may restrict the search by organization and/or space by providing the various according parameters. When passing the names, the function performs a lookup for each of them to fetch their GUID. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html Signature: def get_app_by_name ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required app_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"get_app_by_name\" , \"module\" : \"chaoscf.api\" } } name : get-app-by-name provider : arguments : app_name : '' func : get_app_by_name module : chaoscf.api type : python type : '' get_app_instances \u00b6 Type Module chaoscf.api Name get_app_instances Return None Get all the instances of a started application. See https://apidocs.cloudfoundry.org/280/apps/get_the_instance_information_for_a_started_app.html Signature: def get_app_instances ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-instances\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"get_app_instances\" , \"module\" : \"chaoscf.api\" } } name : get-app-instances provider : arguments : app_name : '' func : get_app_instances module : chaoscf.api type : python type : '' get_app_routes_by_host \u00b6 Type Module chaoscf.api Name get_app_routes_by_host Return None Get all routes associated with the provided app and the given host. See https://apidocs.cloudfoundry.org/280/routes/list_all_routes.html Signature: def get_app_routes_by_host ( app_name : str , route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes route_host string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-routes-by-host\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"route_host\" : \"\" }, \"func\" : \"get_app_routes_by_host\" , \"module\" : \"chaoscf.api\" } } name : get-app-routes-by-host provider : arguments : app_name : '' route_host : '' func : get_app_routes_by_host module : chaoscf.api type : python type : '' get_bind_by_name \u00b6 Type Module chaoscf.api Name get_bind_by_name Return None Get the service bind with the given name. You may restrict the search by organization and/or space by providing the various according parameters. When passing the names, the function performs a lookup for each of them to fetch their GUID. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html Signature: def get_bind_by_name ( bind_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required bind_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-bind-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"bind_name\" : \"\" }, \"func\" : \"get_bind_by_name\" , \"module\" : \"chaoscf.api\" } } name : get-bind-by-name provider : arguments : bind_name : '' func : get_bind_by_name module : chaoscf.api type : python type : '' get_org_by_name \u00b6 Type Module chaoscf.api Name get_org_by_name Return None Get the organization with the given name. Signature: def get_org_by_name ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"get-org-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"org_name\" : \"\" }, \"func\" : \"get_org_by_name\" , \"module\" : \"chaoscf.api\" } } name : get-org-by-name provider : arguments : org_name : '' func : get_org_by_name module : chaoscf.api type : python type : '' get_routes_by_host \u00b6 Type Module chaoscf.api Name get_routes_by_host Return None Get all routes with given host. See https://apidocs.cloudfoundry.org/280/routes/list_all_routes.html Signature: def get_routes_by_host ( route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required route_host string Yes org_name string null No org_guid string null No Usage: { \"name\" : \"get-routes-by-host\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"route_host\" : \"\" }, \"func\" : \"get_routes_by_host\" , \"module\" : \"chaoscf.api\" } } name : get-routes-by-host provider : arguments : route_host : '' func : get_routes_by_host module : chaoscf.api type : python type : '' get_space_by_name \u00b6 Type Module chaoscf.api Name get_space_by_name Return None Get the space with the given name. You may restrict the search by organization by providing the various according parameters. When passing the name, the function performs a lookup for the org to fetch its GUID. Signature: def get_space_by_name ( space_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , org_guid = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required space_name string Yes org_name string null No org_guid null No Usage: { \"name\" : \"get-space-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"space_name\" : \"\" }, \"func\" : \"get_space_by_name\" , \"module\" : \"chaoscf.api\" } } name : get-space-by-name provider : arguments : space_name : '' func : get_space_by_name module : chaoscf.api type : python type : ''","title":"Cloud Foundry"},{"location":"drivers/cloudfoundry/#extension-chaoscf","text":"Version 0.6.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-cloud-foundry This extension package provides probes and actions for Chaos Engineering experiments against a Cloud Foundry instance using the Chaos Toolkit .","title":"Extension chaoscf"},{"location":"drivers/cloudfoundry/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-cloud-foundry","title":"Install"},{"location":"drivers/cloudfoundry/#usage","text":"To use the probes and actions from this package, add a similar payload to your experiment file: { \"type\" : \"action\" , \"name\" : \"terminate-random-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"terminate_some_random_instance\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } } , { \"type\" : \"probe\" , \"name\" : \"fetch-app-statistics\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/cloudfoundry/#discovery","text":"You may use the Chaos Toolkit to discover the capabilities of this extension: $ chaos discover chaostoolkit-cloud-foundry --no-install If you have logged in against a Cloud Foundry environment, this will discover information about it along the way.","title":"Discovery"},{"location":"drivers/cloudfoundry/#configuration","text":"This extension to the Chaos Toolkit need credentials to a Cloud Foundry account with appropriate scopes. Please add the following sections to your experiment file: { \"configuration\" : { \"cf_api_url\" : \"https://api.local.pcfdev.io\" , \"cf_verify_ssl\" : false }, \"secrets\" : { \"cloudfoundry\" : { \"cf_username\" : \"user\" , \"cf_password\" : \"pass\" } } } You may leave \"cf_verifiy_ssl\" out of the configuration when you want to verify TLS certificates. Usually, local environments are self-signed so it may be useful to disable that check in that case. You may also specify the \"cf_client_id\" and \"cf_client_secret\" secrets when you need. Their default values are \"cf\" and \"\" respectively. These work well against a local PCF dev install. Then in your probe or action: { \"type\" : \"probe\" , \"name\" : \"fetch-app-statistics\" , \"provider\" : { \"type\" : \"python\" , \"secrets\" : [ \"cloudfoundry\" ], \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } }","title":"Configuration"},{"location":"drivers/cloudfoundry/#test","text":"To run the tests for the project execute the following: $ pip install -r requirements-dev.txt $ pytest","title":"Test"},{"location":"drivers/cloudfoundry/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit project requires all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/cloudfoundry/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/cloudfoundry/#test_1","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/cloudfoundry/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/cloudfoundry/#probes","text":"","title":"probes"},{"location":"drivers/cloudfoundry/#get_app_stats","text":"Type probe Module chaoscf.probes Name get_app_stats Return None Fetch the metrics of the given application. See https://apidocs.cloudfoundry.org/280/apps/get_detailed_stats_for_a_started_app.html for more information. Signature: def get_app_stats ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"get-app-stats\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"get_app_stats\" , \"module\" : \"chaoscf.probes\" } } name : get-app-stats provider : arguments : app_name : '' func : get_app_stats module : chaoscf.probes type : python type : probe","title":"get_app_stats"},{"location":"drivers/cloudfoundry/#list_apps","text":"Type probe Module chaoscf.probes Name list_apps Return None List all applications available to the authorized user. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html to understand the content of the response. Signature: def list_apps ( configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-apps\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"list_apps\" , \"module\" : \"chaoscf.probes\" } } name : list-apps provider : func : list_apps module : chaoscf.probes type : python type : probe","title":"list_apps"},{"location":"drivers/cloudfoundry/#actions","text":"","title":"actions"},{"location":"drivers/cloudfoundry/#delete_app","text":"Type action Module chaoscf.actions Name delete_app Return None Delete application. See https://apidocs.cloudfoundry.org/280/apps/delete_a_particular_app.html Signature: def delete_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"delete-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"delete_app\" , \"module\" : \"chaoscf.actions\" } } name : delete-app provider : arguments : app_name : '' func : delete_app module : chaoscf.actions type : python type : action","title":"delete_app"},{"location":"drivers/cloudfoundry/#map_route_to_app","text":"Type action Module chaoscf.actions Name map_route_to_app Return None Map a specific route to a given application. As Domains are deprecated in the Cloud Foundry API, they are not specified here. See https://apidocs.cloudfoundry.org/280/#domains--deprecated- See https://www.cloudfoundry.org/blog/coming-changes-app-manifest-simplification/ See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def map_route_to_app ( app_name : str , host_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes host_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"map-route-to-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"host_name\" : \"\" }, \"func\" : \"map_route_to_app\" , \"module\" : \"chaoscf.actions\" } } name : map-route-to-app provider : arguments : app_name : '' host_name : '' func : map_route_to_app module : chaoscf.actions type : python type : action","title":"map_route_to_app"},{"location":"drivers/cloudfoundry/#remove_routes_from_app","text":"Type action Module chaoscf.actions Name remove_routes_from_app Return None Remove routes from a given application. See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def remove_routes_from_app ( app_name : str , route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes route_host string Yes org_name string null No space_name string null No Usage: { \"name\" : \"remove-routes-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"route_host\" : \"\" }, \"func\" : \"remove_routes_from_app\" , \"module\" : \"chaoscf.actions\" } } name : remove-routes-from-app provider : arguments : app_name : '' route_host : '' func : remove_routes_from_app module : chaoscf.actions type : python type : action","title":"remove_routes_from_app"},{"location":"drivers/cloudfoundry/#stop_app","text":"Type action Module chaoscf.actions Name stop_app Return None Stop application See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def stop_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"stop-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"stop_app\" , \"module\" : \"chaoscf.actions\" } } name : stop-app provider : arguments : app_name : '' func : stop_app module : chaoscf.actions type : python type : action","title":"stop_app"},{"location":"drivers/cloudfoundry/#terminate_app_instance","text":"Type action Module chaoscf.actions Name terminate_app_instance Return None Terminate the application\u2019s instance at the given index. See https://apidocs.cloudfoundry.org/280/apps/terminate_the_running_app_instance_at_the_given_index.html Signature: def terminate_app_instance ( app_name : str , instance_index : int , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes instance_index integer Yes org_name string null No space_name string null No Usage: { \"name\" : \"terminate-app-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"instance_index\" : 0 }, \"func\" : \"terminate_app_instance\" , \"module\" : \"chaoscf.actions\" } } name : terminate-app-instance provider : arguments : app_name : '' instance_index : 0 func : terminate_app_instance module : chaoscf.actions type : python type : action","title":"terminate_app_instance"},{"location":"drivers/cloudfoundry/#terminate_some_random_instance","text":"Type action Module chaoscf.actions Name terminate_some_random_instance Return None Terminate a random application\u2019s instance. See https://apidocs.cloudfoundry.org/280/apps/terminate_the_running_app_instance_at_the_given_index.html Signature: def terminate_some_random_instance ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"terminate-some-random-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"terminate_some_random_instance\" , \"module\" : \"chaoscf.actions\" } } name : terminate-some-random-instance provider : arguments : app_name : '' func : terminate_some_random_instance module : chaoscf.actions type : python type : action","title":"terminate_some_random_instance"},{"location":"drivers/cloudfoundry/#unbind_service_from_app","text":"Type action Module chaoscf.actions Name unbind_service_from_app Return None Unbind the service from the given application. See https://apidocs.cloudfoundry.org/280/service_bindings/delete_a_particular_service_binding.html Signature: def unbind_service_from_app ( app_name : str , bind_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes bind_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"unbind-service-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"bind_name\" : \"\" }, \"func\" : \"unbind_service_from_app\" , \"module\" : \"chaoscf.actions\" } } name : unbind-service-from-app provider : arguments : app_name : '' bind_name : '' func : unbind_service_from_app module : chaoscf.actions type : python type : action","title":"unbind_service_from_app"},{"location":"drivers/cloudfoundry/#unmap_route_from_app","text":"Type action Module chaoscf.actions Name unmap_route_from_app Return None Unmap a specific route from a given application. As Domains are deprecated in the Cloud Foundry API, they are not specified here. See https://apidocs.cloudfoundry.org/280/#domains--deprecated- See https://www.cloudfoundry.org/blog/coming-changes-app-manifest-simplification/ See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def unmap_route_from_app ( app_name : str , host_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes host_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"unmap-route-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"host_name\" : \"\" }, \"func\" : \"unmap_route_from_app\" , \"module\" : \"chaoscf.actions\" } } name : unmap-route-from-app provider : arguments : app_name : '' host_name : '' func : unmap_route_from_app module : chaoscf.actions type : python type : action","title":"unmap_route_from_app"},{"location":"drivers/cloudfoundry/#api","text":"","title":"api"},{"location":"drivers/cloudfoundry/#call_api","text":"Type Module chaoscf.api Name call_api Return None Perform a Cloud Foundry API call and return the full response to the caller. Signature: def call_api ( path : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], query : Dict [ str , Any ] = None , body : Dict [ str , Any ] = None , method : str = 'GET' , headers : Dict [ str , str ] = None ) -> requests . models . Response : pass Arguments: Name Type Default Required path string Yes query mapping null No body mapping null No method string \u201cGET\u201d No headers mapping null No Usage: { \"name\" : \"call-api\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"path\" : \"\" }, \"func\" : \"call_api\" , \"module\" : \"chaoscf.api\" } } name : call-api provider : arguments : path : '' func : call_api module : chaoscf.api type : python type : ''","title":"call_api"},{"location":"drivers/cloudfoundry/#get_app_by_name","text":"Type Module chaoscf.api Name get_app_by_name Return None Get the application with the given name. You may restrict the search by organization and/or space by providing the various according parameters. When passing the names, the function performs a lookup for each of them to fetch their GUID. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html Signature: def get_app_by_name ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required app_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"get_app_by_name\" , \"module\" : \"chaoscf.api\" } } name : get-app-by-name provider : arguments : app_name : '' func : get_app_by_name module : chaoscf.api type : python type : ''","title":"get_app_by_name"},{"location":"drivers/cloudfoundry/#get_app_instances","text":"Type Module chaoscf.api Name get_app_instances Return None Get all the instances of a started application. See https://apidocs.cloudfoundry.org/280/apps/get_the_instance_information_for_a_started_app.html Signature: def get_app_instances ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-instances\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" }, \"func\" : \"get_app_instances\" , \"module\" : \"chaoscf.api\" } } name : get-app-instances provider : arguments : app_name : '' func : get_app_instances module : chaoscf.api type : python type : ''","title":"get_app_instances"},{"location":"drivers/cloudfoundry/#get_app_routes_by_host","text":"Type Module chaoscf.api Name get_app_routes_by_host Return None Get all routes associated with the provided app and the given host. See https://apidocs.cloudfoundry.org/280/routes/list_all_routes.html Signature: def get_app_routes_by_host ( app_name : str , route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes route_host string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-routes-by-host\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"app_name\" : \"\" , \"route_host\" : \"\" }, \"func\" : \"get_app_routes_by_host\" , \"module\" : \"chaoscf.api\" } } name : get-app-routes-by-host provider : arguments : app_name : '' route_host : '' func : get_app_routes_by_host module : chaoscf.api type : python type : ''","title":"get_app_routes_by_host"},{"location":"drivers/cloudfoundry/#get_bind_by_name","text":"Type Module chaoscf.api Name get_bind_by_name Return None Get the service bind with the given name. You may restrict the search by organization and/or space by providing the various according parameters. When passing the names, the function performs a lookup for each of them to fetch their GUID. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html Signature: def get_bind_by_name ( bind_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required bind_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-bind-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"bind_name\" : \"\" }, \"func\" : \"get_bind_by_name\" , \"module\" : \"chaoscf.api\" } } name : get-bind-by-name provider : arguments : bind_name : '' func : get_bind_by_name module : chaoscf.api type : python type : ''","title":"get_bind_by_name"},{"location":"drivers/cloudfoundry/#get_org_by_name","text":"Type Module chaoscf.api Name get_org_by_name Return None Get the organization with the given name. Signature: def get_org_by_name ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"get-org-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"org_name\" : \"\" }, \"func\" : \"get_org_by_name\" , \"module\" : \"chaoscf.api\" } } name : get-org-by-name provider : arguments : org_name : '' func : get_org_by_name module : chaoscf.api type : python type : ''","title":"get_org_by_name"},{"location":"drivers/cloudfoundry/#get_routes_by_host","text":"Type Module chaoscf.api Name get_routes_by_host Return None Get all routes with given host. See https://apidocs.cloudfoundry.org/280/routes/list_all_routes.html Signature: def get_routes_by_host ( route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required route_host string Yes org_name string null No org_guid string null No Usage: { \"name\" : \"get-routes-by-host\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"route_host\" : \"\" }, \"func\" : \"get_routes_by_host\" , \"module\" : \"chaoscf.api\" } } name : get-routes-by-host provider : arguments : route_host : '' func : get_routes_by_host module : chaoscf.api type : python type : ''","title":"get_routes_by_host"},{"location":"drivers/cloudfoundry/#get_space_by_name","text":"Type Module chaoscf.api Name get_space_by_name Return None Get the space with the given name. You may restrict the search by organization by providing the various according parameters. When passing the name, the function performs a lookup for the org to fetch its GUID. Signature: def get_space_by_name ( space_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , org_guid = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required space_name string Yes org_name string null No org_guid null No Usage: { \"name\" : \"get-space-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"space_name\" : \"\" }, \"func\" : \"get_space_by_name\" , \"module\" : \"chaoscf.api\" } } name : get-space-by-name provider : arguments : space_name : '' func : get_space_by_name module : chaoscf.api type : python type : ''","title":"get_space_by_name"},{"location":"drivers/gce/","text":"Extension chaosgce \u00b6 Version 0.2.2 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-google-cloud This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . It targets the Google Cloud Engine platform. Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-google-cloud Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"type\" : \"action\" , \"name\" : \"swap-nodepool-for-a-new-one\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgce.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"secrets\" : [ \"gce\" ], \"arguments\" : { \"body\" : { \"nodePool\" : { \"config\" : { \"oauthScopes\" : [ \"gke-version-default\" , \"https://www.googleapis.com/auth/devstorage.read_only\" , \"https://www.googleapis.com/auth/logging.write\" , \"https://www.googleapis.com/auth/monitoring\" , \"https://www.googleapis.com/auth/service.management.readonly\" , \"https://www.googleapis.com/auth/servicecontrol\" , \"https://www.googleapis.com/auth/trace.append\" ] }, \"initialNodeCount\" : 3 , \"name\" : \"new-default-pool\" } } } } } That\u2019s it! Please explore the code to see existing probes and actions. Configuration \u00b6 Project and Cluster Information \u00b6 You can pass the context via the configuration section of your experiment: { \"configuration\" : { \"gce_project_id\" : \"...\" , \"gce_cluster_name\" : \"...\" , \"gce_region\" : \"...\" , \"gce_zone\" : \"...\" } } Note that most functions exposed in this package also take those values directly when you want specific values for them. Credentials \u00b6 This extension expects a service account with enough permissions to perform its operations. Please create such a service account manually (do not use the default one for your cluster if you can, so you\u2019ll be able to delete that service account if need be). Once you have created your service account, either keep the file on the same machine where you will be running the experiment from. Or, pass its content as part of the secrets section, although this is not recommended because your sensitive data will be quite visible. Here is the first way: { \"secrets\" : { \"gce\" : { \"service_account_file\" : \"/path/to/sa.json\" } } } While the embedded way looks like this: { \"secrets\" : { \"gce\" : { \"service_account_info\" : { \"type\" : \"service_account\" , \"project_id\" : \"...\" , \"private_key_id\" : \"...\" , \"private_key\" : \"...\" , \"client_email\" : \"...\" , \"client_id\" : \"...\" , \"auth_uri\" : \"https://accounts.google.com/o/oauth2/auth\" , \"token_uri\" : \"https://accounts.google.com/o/oauth2/token\" , \"auth_provider_x509_cert_url\" : \"https://www.googleapis.com/oauth2/v1/certs\" , \"client_x509_cert_url\" : \"https://www.googleapis.com/robot/v1/metadata/x509/....\" } } } } Putting it all together \u00b6 Here is a full example: { \"version\" : \"1.0.0\" , \"title\" : \"...\" , \"description\" : \"...\" , \"configuration\" : { \"gce_project_id\" : \"...\" , \"gce_cluster_name\" : \"...\" , \"gce_region\" : \"...\" , \"gce_zone\" : \"...\" }, \"secrets\" : { \"gce\" : { \"service_account_file\" : \"/path/to/sa.json\" } }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"swap-nodepool-for-a-new-one\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgce.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"secrets\" : [ \"gce\" ], \"arguments\" : { \"body\" : { \"nodePool\" : { \"config\" : { \"oauthScopes\" : [ \"gke-version-default\" , \"https://www.googleapis.com/auth/devstorage.read_only\" , \"https://www.googleapis.com/auth/logging.write\" , \"https://www.googleapis.com/auth/monitoring\" , \"https://www.googleapis.com/auth/service.management.readonly\" , \"https://www.googleapis.com/auth/servicecontrol\" , \"https://www.googleapis.com/auth/trace.append\" ] }, \"initialNodeCount\" : 3 , \"name\" : \"new-default-pool\" } } } } } ] } Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 nodepool \u00b6 create_new_nodepool \u00b6 Type action Module chaosgce.nodepool.actions Name create_new_nodepool Return None Create a new node pool in the given cluster/zone of the provided project. The node pool config must be passed a mapping to the body parameter and respect the REST API. If wait_until_complete is set to True (the default), the function will block until the node pool is ready. Otherwise, will return immediatly with the operation information. See: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools/create Signature: def create_new_nodepool ( body : Dict [ str , Any ], wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required body mapping Yes wait_until_complete boolean true No Usage: { \"name\" : \"create-new-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"body\" : {} }, \"func\" : \"create_new_nodepool\" , \"module\" : \"chaosgce.nodepool.actions\" } } name : create-new-nodepool provider : arguments : body : {} func : create_new_nodepool module : chaosgce.nodepool.actions type : python type : action delete_nodepool \u00b6 Type action Module chaosgce.nodepool.actions Name delete_nodepool Return None Delete node pool from the given cluster/zone of the provided project. If wait_until_complete is set to True (the default), the function will block until the node pool is deleted. Otherwise, will return immediatly with the operation information. See: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools/create Signature: def delete_nodepool ( node_pool_id : str , wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required node_pool_id string Yes wait_until_complete boolean true No Usage: { \"name\" : \"delete-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"node_pool_id\" : \"\" }, \"func\" : \"delete_nodepool\" , \"module\" : \"chaosgce.nodepool.actions\" } } name : delete-nodepool provider : arguments : node_pool_id : '' func : delete_nodepool module : chaosgce.nodepool.actions type : python type : action swap_nodepool \u00b6 Type action Module chaosgce.nodepool.actions Name swap_nodepool Return None Create a new nodepool, drain the old one so pods can be rescheduled on the new pool. Delete the old nodepool only delete_old_node_pool is set to True , which is not the default. Otherwise, leave the old node pool cordonned so it cannot be scheduled any longer. Signature: def swap_nodepool ( old_node_pool_id : str , new_nodepool_body : Dict [ str , Any ], wait_until_complete : bool = True , delete_old_node_pool : bool = False , drain_timeout : int = 120 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required old_node_pool_id string Yes new_nodepool_body mapping Yes wait_until_complete boolean true No delete_old_node_pool boolean false No drain_timeout integer 120 No Usage: { \"name\" : \"swap-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"new_nodepool_body\" : {}, \"old_node_pool_id\" : \"\" }, \"func\" : \"swap_nodepool\" , \"module\" : \"chaosgce.nodepool.actions\" } } name : swap-nodepool provider : arguments : new_nodepool_body : {} old_node_pool_id : '' func : swap_nodepool module : chaosgce.nodepool.actions type : python type : action","title":"GCE"},{"location":"drivers/gce/#extension-chaosgce","text":"Version 0.2.2 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-google-cloud This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . It targets the Google Cloud Engine platform.","title":"Extension chaosgce"},{"location":"drivers/gce/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-google-cloud","title":"Install"},{"location":"drivers/gce/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"type\" : \"action\" , \"name\" : \"swap-nodepool-for-a-new-one\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgce.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"secrets\" : [ \"gce\" ], \"arguments\" : { \"body\" : { \"nodePool\" : { \"config\" : { \"oauthScopes\" : [ \"gke-version-default\" , \"https://www.googleapis.com/auth/devstorage.read_only\" , \"https://www.googleapis.com/auth/logging.write\" , \"https://www.googleapis.com/auth/monitoring\" , \"https://www.googleapis.com/auth/service.management.readonly\" , \"https://www.googleapis.com/auth/servicecontrol\" , \"https://www.googleapis.com/auth/trace.append\" ] }, \"initialNodeCount\" : 3 , \"name\" : \"new-default-pool\" } } } } } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/gce/#configuration","text":"","title":"Configuration"},{"location":"drivers/gce/#project-and-cluster-information","text":"You can pass the context via the configuration section of your experiment: { \"configuration\" : { \"gce_project_id\" : \"...\" , \"gce_cluster_name\" : \"...\" , \"gce_region\" : \"...\" , \"gce_zone\" : \"...\" } } Note that most functions exposed in this package also take those values directly when you want specific values for them.","title":"Project and Cluster Information"},{"location":"drivers/gce/#credentials","text":"This extension expects a service account with enough permissions to perform its operations. Please create such a service account manually (do not use the default one for your cluster if you can, so you\u2019ll be able to delete that service account if need be). Once you have created your service account, either keep the file on the same machine where you will be running the experiment from. Or, pass its content as part of the secrets section, although this is not recommended because your sensitive data will be quite visible. Here is the first way: { \"secrets\" : { \"gce\" : { \"service_account_file\" : \"/path/to/sa.json\" } } } While the embedded way looks like this: { \"secrets\" : { \"gce\" : { \"service_account_info\" : { \"type\" : \"service_account\" , \"project_id\" : \"...\" , \"private_key_id\" : \"...\" , \"private_key\" : \"...\" , \"client_email\" : \"...\" , \"client_id\" : \"...\" , \"auth_uri\" : \"https://accounts.google.com/o/oauth2/auth\" , \"token_uri\" : \"https://accounts.google.com/o/oauth2/token\" , \"auth_provider_x509_cert_url\" : \"https://www.googleapis.com/oauth2/v1/certs\" , \"client_x509_cert_url\" : \"https://www.googleapis.com/robot/v1/metadata/x509/....\" } } } }","title":"Credentials"},{"location":"drivers/gce/#putting-it-all-together","text":"Here is a full example: { \"version\" : \"1.0.0\" , \"title\" : \"...\" , \"description\" : \"...\" , \"configuration\" : { \"gce_project_id\" : \"...\" , \"gce_cluster_name\" : \"...\" , \"gce_region\" : \"...\" , \"gce_zone\" : \"...\" }, \"secrets\" : { \"gce\" : { \"service_account_file\" : \"/path/to/sa.json\" } }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"swap-nodepool-for-a-new-one\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgce.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"secrets\" : [ \"gce\" ], \"arguments\" : { \"body\" : { \"nodePool\" : { \"config\" : { \"oauthScopes\" : [ \"gke-version-default\" , \"https://www.googleapis.com/auth/devstorage.read_only\" , \"https://www.googleapis.com/auth/logging.write\" , \"https://www.googleapis.com/auth/monitoring\" , \"https://www.googleapis.com/auth/service.management.readonly\" , \"https://www.googleapis.com/auth/servicecontrol\" , \"https://www.googleapis.com/auth/trace.append\" ] }, \"initialNodeCount\" : 3 , \"name\" : \"new-default-pool\" } } } } } ] }","title":"Putting it all together"},{"location":"drivers/gce/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/gce/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/gce/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/gce/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/gce/#nodepool","text":"","title":"nodepool"},{"location":"drivers/gce/#create_new_nodepool","text":"Type action Module chaosgce.nodepool.actions Name create_new_nodepool Return None Create a new node pool in the given cluster/zone of the provided project. The node pool config must be passed a mapping to the body parameter and respect the REST API. If wait_until_complete is set to True (the default), the function will block until the node pool is ready. Otherwise, will return immediatly with the operation information. See: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools/create Signature: def create_new_nodepool ( body : Dict [ str , Any ], wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required body mapping Yes wait_until_complete boolean true No Usage: { \"name\" : \"create-new-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"body\" : {} }, \"func\" : \"create_new_nodepool\" , \"module\" : \"chaosgce.nodepool.actions\" } } name : create-new-nodepool provider : arguments : body : {} func : create_new_nodepool module : chaosgce.nodepool.actions type : python type : action","title":"create_new_nodepool"},{"location":"drivers/gce/#delete_nodepool","text":"Type action Module chaosgce.nodepool.actions Name delete_nodepool Return None Delete node pool from the given cluster/zone of the provided project. If wait_until_complete is set to True (the default), the function will block until the node pool is deleted. Otherwise, will return immediatly with the operation information. See: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools/create Signature: def delete_nodepool ( node_pool_id : str , wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required node_pool_id string Yes wait_until_complete boolean true No Usage: { \"name\" : \"delete-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"node_pool_id\" : \"\" }, \"func\" : \"delete_nodepool\" , \"module\" : \"chaosgce.nodepool.actions\" } } name : delete-nodepool provider : arguments : node_pool_id : '' func : delete_nodepool module : chaosgce.nodepool.actions type : python type : action","title":"delete_nodepool"},{"location":"drivers/gce/#swap_nodepool","text":"Type action Module chaosgce.nodepool.actions Name swap_nodepool Return None Create a new nodepool, drain the old one so pods can be rescheduled on the new pool. Delete the old nodepool only delete_old_node_pool is set to True , which is not the default. Otherwise, leave the old node pool cordonned so it cannot be scheduled any longer. Signature: def swap_nodepool ( old_node_pool_id : str , new_nodepool_body : Dict [ str , Any ], wait_until_complete : bool = True , delete_old_node_pool : bool = False , drain_timeout : int = 120 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required old_node_pool_id string Yes new_nodepool_body mapping Yes wait_until_complete boolean true No delete_old_node_pool boolean false No drain_timeout integer 120 No Usage: { \"name\" : \"swap-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"new_nodepool_body\" : {}, \"old_node_pool_id\" : \"\" }, \"func\" : \"swap_nodepool\" , \"module\" : \"chaosgce.nodepool.actions\" } } name : swap-nodepool provider : arguments : new_nodepool_body : {} old_node_pool_id : '' func : swap_nodepool module : chaosgce.nodepool.actions type : python type : action","title":"swap_nodepool"},{"location":"drivers/humio/","text":"Extension chaoshumio \u00b6 Version 0.1.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-humio N/A Exported Activities \u00b6 notification \u00b6 notify \u00b6 Type Module chaoshumio.notification Name notify Return None Send a log message to the Humio ingest endpoint. The settings must contain: \"token\" : a slack API token \"url\" : the channel where to send this event notification If one of these two attributes is missing, no notification is sent. Signature: def notify ( settings : Dict [ str , Any ], event : Dict [ str , Any ]): pass Arguments: Name Type Default Required settings mapping Yes event mapping Yes Usage: { \"name\" : \"notify\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.notification\" , \"func\" : \"notify\" , \"arguments\" : { \"settings\" : {}, \"event\" : {} } } } name : notify provider : arguments : event : {} settings : {} func : notify module : chaoshumio.notification type : python type : ''","title":"Humio"},{"location":"drivers/humio/#extension-chaoshumio","text":"Version 0.1.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-humio N/A","title":"Extension chaoshumio"},{"location":"drivers/humio/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/humio/#notification","text":"","title":"notification"},{"location":"drivers/humio/#notify","text":"Type Module chaoshumio.notification Name notify Return None Send a log message to the Humio ingest endpoint. The settings must contain: \"token\" : a slack API token \"url\" : the channel where to send this event notification If one of these two attributes is missing, no notification is sent. Signature: def notify ( settings : Dict [ str , Any ], event : Dict [ str , Any ]): pass Arguments: Name Type Default Required settings mapping Yes event mapping Yes Usage: { \"name\" : \"notify\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.notification\" , \"func\" : \"notify\" , \"arguments\" : { \"settings\" : {}, \"event\" : {} } } } name : notify provider : arguments : event : {} settings : {} func : notify module : chaoshumio.notification type : python type : ''","title":"notify"},{"location":"drivers/kubernetes/","text":"Extension chaosk8s \u00b6 Version 0.19.1 Repository https://github.com/chaostoolkit/chaostoolkit-kubernetes This project contains activities, such as probes and actions, you can call from your experiment through the Chaos Toolkit. Install \u00b6 To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-kubernetes Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"name\" : \"all-our-microservices-should-be-healthy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"arguments\" : { \"name\" : \"myapp\" , \"ns\" : \"myns\" } } } , { \"type\" : \"action\" , \"name\" : \"terminate-db-pod\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"label_selector\" : \"app=my-app\" , \"name_pattern\" : \"my-app-[0-9]$\" , \"rand\" : true , \"ns\" : \"default\" } }, \"pauses\" : { \"after\" : 5 } } That\u2019s it! Notice how the action gives you the way to kill one pod randomly. Please explore the code to see existing probes and actions. Discovery \u00b6 You may use the Chaos Toolkit to discover the capabilities of this extension: $ chaos discover chaostoolkit-kubernetes --no-install Configuration \u00b6 This extension to the Chaos Toolkit can use the Kubernetes configuration found at the usual place in your HOME directory under ~/.kube/ , or, when run from a Pod in a Kubernetes cluster, it will use the local service account. In that case, make sure to set the CHAOSTOOLKIT_IN_POD environment variable to \"true\" . You can also pass the credentials via secrets as follows: { \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_HOST\" : \"http://somehost\" , \"KUBERNETES_API_KEY\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" } } } } Then in your probe or action: { \"name\" : \"all-our-microservices-should-be-healthy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"secrets\" : [ \"kubernetes\" ], \"arguments\" : { \"name\" : \"myapp\" , \"ns\" : \"myns\" } } } You may specify the Kubernetes context you want to use as follows: { \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_CONTEXT\" : \"minikube\" } } } Or via the environment: $ export KUBERNETES_CONTEXT=minikube In the same spirit, you can specify where to find your Kubernetes configuration with: $ export KUBECONFIG=some/path/config Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please fork this project, make your changes following the usual PEP 8 code style, add appropriate tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Exported Activities \u00b6 pod \u00b6 count_pods \u00b6 Type probe Module chaosk8s.pod.probes Name count_pods Return None Count the number of pods matching the given selector in a given phase , if one is given. Signature: def count_pods ( label_selector : str , phase : str = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required label_selector string Yes phase string null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"count-pods\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"label_selector\" : \"\" }, \"func\" : \"count_pods\" , \"module\" : \"chaosk8s.pod.probes\" } } name : count-pods provider : arguments : label_selector : '' func : count_pods module : chaosk8s.pod.probes type : python type : probe pods_in_phase \u00b6 Type probe Module chaosk8s.pod.probes Name pods_in_phase Return None Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def pods_in_phase ( label_selector : str , phase : str = 'Running' , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes phase string \u201cRunning\u201d No ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-in-phase\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"label_selector\" : \"\" }, \"func\" : \"pods_in_phase\" , \"module\" : \"chaosk8s.pod.probes\" } } name : pods-in-phase provider : arguments : label_selector : '' func : pods_in_phase module : chaosk8s.pod.probes type : python type : probe pods_not_in_phase \u00b6 Type probe Module chaosk8s.pod.probes Name pods_not_in_phase Return None Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed when the pod is in the given phase and should not have. Signature: def pods_not_in_phase ( label_selector : str , phase : str = 'Running' , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes phase string \u201cRunning\u201d No ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-not-in-phase\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"label_selector\" : \"\" }, \"func\" : \"pods_not_in_phase\" , \"module\" : \"chaosk8s.pod.probes\" } } name : pods-not-in-phase provider : arguments : label_selector : '' func : pods_not_in_phase module : chaosk8s.pod.probes type : python type : probe read_pod_logs \u00b6 Type probe Module chaosk8s.pod.probes Name read_pod_logs Return None Fetch logs for all the pods with the label \"name\" set to name and return a dictionary with the keys being the pod\u2019s name and the values the logs of said pod. If name is not provided, use only the label_selector instead. When your pod has several containers, you should also set container_name to clarify which container you want to read logs from. If you provide last , this returns the logs of the last N seconds until now. This can set to a fluent delta such as 10 minutes . You may also set from_previous to True to capture the logs of a previous pod\u2019s incarnation, if any. Signature: def read_pod_logs ( name : str = None , last : Union [ str , NoneType ] = None , ns : str = 'default' , from_previous : bool = False , label_selector : str = 'name in ({name})' , container_name : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , str ]: pass Arguments: Name Type Default Required name string null No last object null No ns string \u201cdefault\u201d No from_previous boolean false No label_selector string \u201cname in ({name})\u201d No container_name string null No Usage: { \"name\" : \"read-pod-logs\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"read_pod_logs\" , \"module\" : \"chaosk8s.pod.probes\" } } name : read-pod-logs provider : func : read_pod_logs module : chaosk8s.pod.probes type : python type : probe terminate_pods \u00b6 Type action Module chaosk8s.pod.actions Name terminate_pods Return None Terminate a pod gracefully. Select the appropriate pods by label and/or name patterns. Whenever a pattern is provided for the name, all pods retrieved will be filtered out if their name do not match the given pattern. If neither label_selector nor name_pattern are provided, all pods in the namespace will be selected for termination. If all is set to True , all matching pods will be terminated. Value of qty varies based on mode . If mode is set to fixed , then qty refers to number of pods to be terminated. If mode is set to percentage , then qty refers to percentage of pods, from 1 to 100, to be terminated. Default mode is fixed and default qty is 1 . If rand is set to True , n random pods will be terminated Otherwise, the first retrieved n pods will be terminated. If grace_period is greater than or equal to 0, it will be used as the grace period (in seconds) to terminate the pods. Otherwise, the default pod\u2019s grace period will be used. Signature: def terminate_pods ( label_selector : str = None , name_pattern : str = None , all : bool = False , rand : bool = False , mode : str = 'fixed' , qty : int = 1 , grace_period : int = - 1 , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No name_pattern string null No all boolean false No rand boolean false No mode string \u201cfixed\u201d No qty integer 1 No grace_period integer -1 No ns string \u201cdefault\u201d No Usage: { \"name\" : \"terminate-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"terminate_pods\" , \"module\" : \"chaosk8s.pod.actions\" } } name : terminate-pods provider : func : terminate_pods module : chaosk8s.pod.actions type : python type : action actions \u00b6 kill_microservice \u00b6 Type action Module chaosk8s.actions Name kill_microservice Return None Kill a microservice by name in the namespace ns . The microservice is killed by deleting the deployment for it without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def kill_microservice ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"kill-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"kill_microservice\" , \"module\" : \"chaosk8s.actions\" } } name : kill-microservice provider : arguments : name : '' func : kill_microservice module : chaosk8s.actions type : python type : action remove_service_endpoint \u00b6 Type action Module chaosk8s.actions Name remove_service_endpoint Return None Remove the service endpoint that sits in front of microservices (pods). Signature: def remove_service_endpoint ( name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-service-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"remove_service_endpoint\" , \"module\" : \"chaosk8s.actions\" } } name : remove-service-endpoint provider : arguments : name : '' func : remove_service_endpoint module : chaosk8s.actions type : python type : action scale_microservice \u00b6 Type action Module chaosk8s.actions Name scale_microservice Return None Scale a deployment up or down. The name is the name of the deployment. Signature: def scale_microservice ( name : str , replicas : int , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes replicas integer Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"scale-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" , \"replicas\" : 0 }, \"func\" : \"scale_microservice\" , \"module\" : \"chaosk8s.actions\" } } name : scale-microservice provider : arguments : name : '' replicas : 0 func : scale_microservice module : chaosk8s.actions type : python type : action start_microservice \u00b6 Type action Module chaosk8s.actions Name start_microservice Return None Start a microservice described by the deployment config, which must be the path to the JSON or YAML representation of the deployment. Signature: def start_microservice ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"start-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"spec_path\" : \"\" }, \"func\" : \"start_microservice\" , \"module\" : \"chaosk8s.actions\" } } name : start-microservice provider : arguments : spec_path : '' func : start_microservice module : chaosk8s.actions type : python type : action node \u00b6 cordon_node \u00b6 Type action Module chaosk8s.node.actions Name cordon_node Return None Cordon nodes matching the given label or name, so that no pods are scheduled on them any longer. Signature: def cordon_node ( name : str = None , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No label_selector string null No Usage: { \"name\" : \"cordon-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"cordon_node\" , \"module\" : \"chaosk8s.node.actions\" } } name : cordon-node provider : func : cordon_node module : chaosk8s.node.actions type : python type : action create_node \u00b6 Type action Module chaosk8s.node.actions Name create_node Return None Create one new node in the cluster. Due to the way things work on certain cloud providers, you won\u2019t be able to use this meaningfully on them. For instance on GCE, this will likely fail. See also: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency Signature: def create_node ( meta : Dict [ str , Any ] = None , spec : Dict [ str , Any ] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> kubernetes . client . models . v1_node . V1Node : pass Arguments: Name Type Default Required meta mapping null No spec mapping null No Usage: { \"name\" : \"create-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"create_node\" , \"module\" : \"chaosk8s.node.actions\" } } name : create-node provider : func : create_node module : chaosk8s.node.actions type : python type : action delete_nodes \u00b6 Type action Module chaosk8s.node.actions Name delete_nodes Return None Delete nodes gracefully. Select the appropriate nodes by label. Nodes are not drained beforehand so we can see how cluster behaves. Nodes cannot be restarted, they are really deleted. Please be careful when using this action. On certain cloud providers, you also need to delete the underneath VM instance as well afterwards. This is the case on GCE for instance. If all is set to True , all nodes will be terminated. If rand is set to True , one random node will be terminated. If \u0300 count is set to a positive number, only a upto count nodes (randomly picked) will be terminated. Otherwise, the first retrieved node will be terminated. Signature: def delete_nodes ( label_selector : str = None , all : bool = False , rand : bool = False , count : int = None , grace_period_seconds : int = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No all boolean false No rand boolean false No count integer null No grace_period_seconds integer null No Usage: { \"name\" : \"delete-nodes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"delete_nodes\" , \"module\" : \"chaosk8s.node.actions\" } } name : delete-nodes provider : func : delete_nodes module : chaosk8s.node.actions type : python type : action drain_nodes \u00b6 Type action Module chaosk8s.node.actions Name drain_nodes Return None Drain nodes matching the given label or name, so that no pods are scheduled on them any longer and running pods are evicted. It does a similar job to kubectl drain --ignore-daemonsets or kubectl drain --delete-local-data --ignore-daemonsets if delete_pods_with_local_storage is set to True . There is no equivalent to the kubectl drain --force flag. You probably want to call uncordon from in your experiment\u2019s rollbacks. Signature: def drain_nodes ( name : str = None , label_selector : str = None , delete_pods_with_local_storage : bool = False , timeout : int = 120 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string null No label_selector string null No delete_pods_with_local_storage boolean false No timeout integer 120 No Usage: { \"name\" : \"drain-nodes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"drain_nodes\" , \"module\" : \"chaosk8s.node.actions\" } } name : drain-nodes provider : func : drain_nodes module : chaosk8s.node.actions type : python type : action get_nodes \u00b6 Type probe Module chaosk8s.node.probes Name get_nodes Return None List all Kubernetes worker nodes in your cluster. You may filter nodes by specifying a label selector. Signature: def get_nodes ( label_selector : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No Usage: { \"name\" : \"get-nodes\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"get_nodes\" , \"module\" : \"chaosk8s.node.probes\" } } name : get-nodes provider : func : get_nodes module : chaosk8s.node.probes type : python type : probe uncordon_node \u00b6 Type action Module chaosk8s.node.actions Name uncordon_node Return None Uncordon nodes matching the given label name, so that pods can be scheduled on them again. Signature: def uncordon_node ( name : str = None , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No label_selector string null No Usage: { \"name\" : \"uncordon-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"uncordon_node\" , \"module\" : \"chaosk8s.node.actions\" } } name : uncordon-node provider : func : uncordon_node module : chaosk8s.node.actions type : python type : action probes \u00b6 all_microservices_healthy \u00b6 Type probe Module chaosk8s.probes Name all_microservices_healthy Return None Check all microservices in the system are running and available. Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def all_microservices_healthy ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Tuple [ Dict [ str , Any ], Dict [ str , Any ]]: pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"all-microservices-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"all_microservices_healthy\" , \"module\" : \"chaosk8s.probes\" } } name : all-microservices-healthy provider : func : all_microservices_healthy module : chaosk8s.probes type : python type : probe deployment_is_not_fully_available \u00b6 Type probe Module chaosk8s.probes Name deployment_is_not_fully_available Return None Wait until the deployment gets into an intermediate state where not all expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def deployment_is_not_fully_available ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No timeout integer 30 No Usage: { \"name\" : \"deployment-is-not-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"deployment_is_not_fully_available\" , \"module\" : \"chaosk8s.probes\" } } name : deployment-is-not-fully-available provider : arguments : name : '' func : deployment_is_not_fully_available module : chaosk8s.probes type : python type : probe microservice_available_and_healthy \u00b6 Type probe Module chaosk8s.probes Name microservice_available_and_healthy Return None Lookup a deployment by name in the namespace ns . The selected resources are matched by the given label_selector . Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def microservice_available_and_healthy ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"microservice-available-and-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"microservice_available_and_healthy\" , \"module\" : \"chaosk8s.probes\" } } name : microservice-available-and-healthy provider : arguments : name : '' func : microservice_available_and_healthy module : chaosk8s.probes type : python type : probe microservice_is_not_available \u00b6 Type probe Module chaosk8s.probes Name microservice_is_not_available Return None Lookup pods with a name label set to the given name in the specified ns . Raises :exc: chaoslib.exceptions.ActivityFailed when one of the pods with the specified name is in the \"Running\" phase. Signature: def microservice_is_not_available ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"microservice-is-not-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"microservice_is_not_available\" , \"module\" : \"chaosk8s.probes\" } } name : microservice-is-not-available provider : arguments : name : '' func : microservice_is_not_available module : chaosk8s.probes type : python type : probe read_microservices_logs \u00b6 Type probe Module chaosk8s.probes Name read_microservices_logs Return None Fetch logs for all the pods with the label \"name\" set to name and return a dictionary with the keys being the pod\u2019s name and the values the logs of said pod. If name is not provided, use only the label_selector instead. When your pod has several containers, you should also set container_name to clarify which container you want to read logs from. If you provide last , this returns the logs of the last N seconds until now. This can set to a fluent delta such as 10 minutes . You may also set from_previous to True to capture the logs of a previous pod\u2019s incarnation, if any. Signature: def read_microservices_logs ( name : str = None , last : Union [ str , NoneType ] = None , ns : str = 'default' , from_previous : bool = False , label_selector : str = 'name in ({name})' , container_name : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , str ]: pass Arguments: Name Type Default Required name string null No last object null No ns string \u201cdefault\u201d No from_previous boolean false No label_selector string \u201cname in ({name})\u201d No container_name string null No Usage: { \"name\" : \"read-microservices-logs\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"read_microservices_logs\" , \"module\" : \"chaosk8s.probes\" } } name : read-microservices-logs provider : func : read_microservices_logs module : chaosk8s.probes type : python type : probe service_endpoint_is_initialized \u00b6 Type probe Module chaosk8s.probes Name service_endpoint_is_initialized Return None Lookup a service endpoint by its name and raises :exc: FailedProbe when the service was not found or not initialized. Signature: def service_endpoint_is_initialized ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"service-endpoint-is-initialized\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"service_endpoint_is_initialized\" , \"module\" : \"chaosk8s.probes\" } } name : service-endpoint-is-initialized provider : arguments : name : '' func : service_endpoint_is_initialized module : chaosk8s.probes type : python type : probe","title":"Kubernetes"},{"location":"drivers/kubernetes/#extension-chaosk8s","text":"Version 0.19.1 Repository https://github.com/chaostoolkit/chaostoolkit-kubernetes This project contains activities, such as probes and actions, you can call from your experiment through the Chaos Toolkit.","title":"Extension chaosk8s"},{"location":"drivers/kubernetes/#install","text":"To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-kubernetes","title":"Install"},{"location":"drivers/kubernetes/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"name\" : \"all-our-microservices-should-be-healthy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"arguments\" : { \"name\" : \"myapp\" , \"ns\" : \"myns\" } } } , { \"type\" : \"action\" , \"name\" : \"terminate-db-pod\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"label_selector\" : \"app=my-app\" , \"name_pattern\" : \"my-app-[0-9]$\" , \"rand\" : true , \"ns\" : \"default\" } }, \"pauses\" : { \"after\" : 5 } } That\u2019s it! Notice how the action gives you the way to kill one pod randomly. Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/kubernetes/#discovery","text":"You may use the Chaos Toolkit to discover the capabilities of this extension: $ chaos discover chaostoolkit-kubernetes --no-install","title":"Discovery"},{"location":"drivers/kubernetes/#configuration","text":"This extension to the Chaos Toolkit can use the Kubernetes configuration found at the usual place in your HOME directory under ~/.kube/ , or, when run from a Pod in a Kubernetes cluster, it will use the local service account. In that case, make sure to set the CHAOSTOOLKIT_IN_POD environment variable to \"true\" . You can also pass the credentials via secrets as follows: { \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_HOST\" : \"http://somehost\" , \"KUBERNETES_API_KEY\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" } } } } Then in your probe or action: { \"name\" : \"all-our-microservices-should-be-healthy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"secrets\" : [ \"kubernetes\" ], \"arguments\" : { \"name\" : \"myapp\" , \"ns\" : \"myns\" } } } You may specify the Kubernetes context you want to use as follows: { \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_CONTEXT\" : \"minikube\" } } } Or via the environment: $ export KUBERNETES_CONTEXT=minikube In the same spirit, you can specify where to find your Kubernetes configuration with: $ export KUBECONFIG=some/path/config","title":"Configuration"},{"location":"drivers/kubernetes/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please fork this project, make your changes following the usual PEP 8 code style, add appropriate tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/kubernetes/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/kubernetes/#pod","text":"","title":"pod"},{"location":"drivers/kubernetes/#count_pods","text":"Type probe Module chaosk8s.pod.probes Name count_pods Return None Count the number of pods matching the given selector in a given phase , if one is given. Signature: def count_pods ( label_selector : str , phase : str = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required label_selector string Yes phase string null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"count-pods\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"label_selector\" : \"\" }, \"func\" : \"count_pods\" , \"module\" : \"chaosk8s.pod.probes\" } } name : count-pods provider : arguments : label_selector : '' func : count_pods module : chaosk8s.pod.probes type : python type : probe","title":"count_pods"},{"location":"drivers/kubernetes/#pods_in_phase","text":"Type probe Module chaosk8s.pod.probes Name pods_in_phase Return None Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def pods_in_phase ( label_selector : str , phase : str = 'Running' , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes phase string \u201cRunning\u201d No ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-in-phase\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"label_selector\" : \"\" }, \"func\" : \"pods_in_phase\" , \"module\" : \"chaosk8s.pod.probes\" } } name : pods-in-phase provider : arguments : label_selector : '' func : pods_in_phase module : chaosk8s.pod.probes type : python type : probe","title":"pods_in_phase"},{"location":"drivers/kubernetes/#pods_not_in_phase","text":"Type probe Module chaosk8s.pod.probes Name pods_not_in_phase Return None Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed when the pod is in the given phase and should not have. Signature: def pods_not_in_phase ( label_selector : str , phase : str = 'Running' , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes phase string \u201cRunning\u201d No ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-not-in-phase\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"label_selector\" : \"\" }, \"func\" : \"pods_not_in_phase\" , \"module\" : \"chaosk8s.pod.probes\" } } name : pods-not-in-phase provider : arguments : label_selector : '' func : pods_not_in_phase module : chaosk8s.pod.probes type : python type : probe","title":"pods_not_in_phase"},{"location":"drivers/kubernetes/#read_pod_logs","text":"Type probe Module chaosk8s.pod.probes Name read_pod_logs Return None Fetch logs for all the pods with the label \"name\" set to name and return a dictionary with the keys being the pod\u2019s name and the values the logs of said pod. If name is not provided, use only the label_selector instead. When your pod has several containers, you should also set container_name to clarify which container you want to read logs from. If you provide last , this returns the logs of the last N seconds until now. This can set to a fluent delta such as 10 minutes . You may also set from_previous to True to capture the logs of a previous pod\u2019s incarnation, if any. Signature: def read_pod_logs ( name : str = None , last : Union [ str , NoneType ] = None , ns : str = 'default' , from_previous : bool = False , label_selector : str = 'name in ({name})' , container_name : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , str ]: pass Arguments: Name Type Default Required name string null No last object null No ns string \u201cdefault\u201d No from_previous boolean false No label_selector string \u201cname in ({name})\u201d No container_name string null No Usage: { \"name\" : \"read-pod-logs\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"read_pod_logs\" , \"module\" : \"chaosk8s.pod.probes\" } } name : read-pod-logs provider : func : read_pod_logs module : chaosk8s.pod.probes type : python type : probe","title":"read_pod_logs"},{"location":"drivers/kubernetes/#terminate_pods","text":"Type action Module chaosk8s.pod.actions Name terminate_pods Return None Terminate a pod gracefully. Select the appropriate pods by label and/or name patterns. Whenever a pattern is provided for the name, all pods retrieved will be filtered out if their name do not match the given pattern. If neither label_selector nor name_pattern are provided, all pods in the namespace will be selected for termination. If all is set to True , all matching pods will be terminated. Value of qty varies based on mode . If mode is set to fixed , then qty refers to number of pods to be terminated. If mode is set to percentage , then qty refers to percentage of pods, from 1 to 100, to be terminated. Default mode is fixed and default qty is 1 . If rand is set to True , n random pods will be terminated Otherwise, the first retrieved n pods will be terminated. If grace_period is greater than or equal to 0, it will be used as the grace period (in seconds) to terminate the pods. Otherwise, the default pod\u2019s grace period will be used. Signature: def terminate_pods ( label_selector : str = None , name_pattern : str = None , all : bool = False , rand : bool = False , mode : str = 'fixed' , qty : int = 1 , grace_period : int = - 1 , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No name_pattern string null No all boolean false No rand boolean false No mode string \u201cfixed\u201d No qty integer 1 No grace_period integer -1 No ns string \u201cdefault\u201d No Usage: { \"name\" : \"terminate-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"terminate_pods\" , \"module\" : \"chaosk8s.pod.actions\" } } name : terminate-pods provider : func : terminate_pods module : chaosk8s.pod.actions type : python type : action","title":"terminate_pods"},{"location":"drivers/kubernetes/#actions","text":"","title":"actions"},{"location":"drivers/kubernetes/#kill_microservice","text":"Type action Module chaosk8s.actions Name kill_microservice Return None Kill a microservice by name in the namespace ns . The microservice is killed by deleting the deployment for it without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def kill_microservice ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"kill-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"kill_microservice\" , \"module\" : \"chaosk8s.actions\" } } name : kill-microservice provider : arguments : name : '' func : kill_microservice module : chaosk8s.actions type : python type : action","title":"kill_microservice"},{"location":"drivers/kubernetes/#remove_service_endpoint","text":"Type action Module chaosk8s.actions Name remove_service_endpoint Return None Remove the service endpoint that sits in front of microservices (pods). Signature: def remove_service_endpoint ( name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-service-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"remove_service_endpoint\" , \"module\" : \"chaosk8s.actions\" } } name : remove-service-endpoint provider : arguments : name : '' func : remove_service_endpoint module : chaosk8s.actions type : python type : action","title":"remove_service_endpoint"},{"location":"drivers/kubernetes/#scale_microservice","text":"Type action Module chaosk8s.actions Name scale_microservice Return None Scale a deployment up or down. The name is the name of the deployment. Signature: def scale_microservice ( name : str , replicas : int , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes replicas integer Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"scale-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" , \"replicas\" : 0 }, \"func\" : \"scale_microservice\" , \"module\" : \"chaosk8s.actions\" } } name : scale-microservice provider : arguments : name : '' replicas : 0 func : scale_microservice module : chaosk8s.actions type : python type : action","title":"scale_microservice"},{"location":"drivers/kubernetes/#start_microservice","text":"Type action Module chaosk8s.actions Name start_microservice Return None Start a microservice described by the deployment config, which must be the path to the JSON or YAML representation of the deployment. Signature: def start_microservice ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"start-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"spec_path\" : \"\" }, \"func\" : \"start_microservice\" , \"module\" : \"chaosk8s.actions\" } } name : start-microservice provider : arguments : spec_path : '' func : start_microservice module : chaosk8s.actions type : python type : action","title":"start_microservice"},{"location":"drivers/kubernetes/#node","text":"","title":"node"},{"location":"drivers/kubernetes/#cordon_node","text":"Type action Module chaosk8s.node.actions Name cordon_node Return None Cordon nodes matching the given label or name, so that no pods are scheduled on them any longer. Signature: def cordon_node ( name : str = None , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No label_selector string null No Usage: { \"name\" : \"cordon-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"cordon_node\" , \"module\" : \"chaosk8s.node.actions\" } } name : cordon-node provider : func : cordon_node module : chaosk8s.node.actions type : python type : action","title":"cordon_node"},{"location":"drivers/kubernetes/#create_node","text":"Type action Module chaosk8s.node.actions Name create_node Return None Create one new node in the cluster. Due to the way things work on certain cloud providers, you won\u2019t be able to use this meaningfully on them. For instance on GCE, this will likely fail. See also: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency Signature: def create_node ( meta : Dict [ str , Any ] = None , spec : Dict [ str , Any ] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> kubernetes . client . models . v1_node . V1Node : pass Arguments: Name Type Default Required meta mapping null No spec mapping null No Usage: { \"name\" : \"create-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"create_node\" , \"module\" : \"chaosk8s.node.actions\" } } name : create-node provider : func : create_node module : chaosk8s.node.actions type : python type : action","title":"create_node"},{"location":"drivers/kubernetes/#delete_nodes","text":"Type action Module chaosk8s.node.actions Name delete_nodes Return None Delete nodes gracefully. Select the appropriate nodes by label. Nodes are not drained beforehand so we can see how cluster behaves. Nodes cannot be restarted, they are really deleted. Please be careful when using this action. On certain cloud providers, you also need to delete the underneath VM instance as well afterwards. This is the case on GCE for instance. If all is set to True , all nodes will be terminated. If rand is set to True , one random node will be terminated. If \u0300 count is set to a positive number, only a upto count nodes (randomly picked) will be terminated. Otherwise, the first retrieved node will be terminated. Signature: def delete_nodes ( label_selector : str = None , all : bool = False , rand : bool = False , count : int = None , grace_period_seconds : int = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No all boolean false No rand boolean false No count integer null No grace_period_seconds integer null No Usage: { \"name\" : \"delete-nodes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"delete_nodes\" , \"module\" : \"chaosk8s.node.actions\" } } name : delete-nodes provider : func : delete_nodes module : chaosk8s.node.actions type : python type : action","title":"delete_nodes"},{"location":"drivers/kubernetes/#drain_nodes","text":"Type action Module chaosk8s.node.actions Name drain_nodes Return None Drain nodes matching the given label or name, so that no pods are scheduled on them any longer and running pods are evicted. It does a similar job to kubectl drain --ignore-daemonsets or kubectl drain --delete-local-data --ignore-daemonsets if delete_pods_with_local_storage is set to True . There is no equivalent to the kubectl drain --force flag. You probably want to call uncordon from in your experiment\u2019s rollbacks. Signature: def drain_nodes ( name : str = None , label_selector : str = None , delete_pods_with_local_storage : bool = False , timeout : int = 120 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string null No label_selector string null No delete_pods_with_local_storage boolean false No timeout integer 120 No Usage: { \"name\" : \"drain-nodes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"drain_nodes\" , \"module\" : \"chaosk8s.node.actions\" } } name : drain-nodes provider : func : drain_nodes module : chaosk8s.node.actions type : python type : action","title":"drain_nodes"},{"location":"drivers/kubernetes/#get_nodes","text":"Type probe Module chaosk8s.node.probes Name get_nodes Return None List all Kubernetes worker nodes in your cluster. You may filter nodes by specifying a label selector. Signature: def get_nodes ( label_selector : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No Usage: { \"name\" : \"get-nodes\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"get_nodes\" , \"module\" : \"chaosk8s.node.probes\" } } name : get-nodes provider : func : get_nodes module : chaosk8s.node.probes type : python type : probe","title":"get_nodes"},{"location":"drivers/kubernetes/#uncordon_node","text":"Type action Module chaosk8s.node.actions Name uncordon_node Return None Uncordon nodes matching the given label name, so that pods can be scheduled on them again. Signature: def uncordon_node ( name : str = None , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No label_selector string null No Usage: { \"name\" : \"uncordon-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"uncordon_node\" , \"module\" : \"chaosk8s.node.actions\" } } name : uncordon-node provider : func : uncordon_node module : chaosk8s.node.actions type : python type : action","title":"uncordon_node"},{"location":"drivers/kubernetes/#probes","text":"","title":"probes"},{"location":"drivers/kubernetes/#all_microservices_healthy","text":"Type probe Module chaosk8s.probes Name all_microservices_healthy Return None Check all microservices in the system are running and available. Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def all_microservices_healthy ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Tuple [ Dict [ str , Any ], Dict [ str , Any ]]: pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"all-microservices-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"all_microservices_healthy\" , \"module\" : \"chaosk8s.probes\" } } name : all-microservices-healthy provider : func : all_microservices_healthy module : chaosk8s.probes type : python type : probe","title":"all_microservices_healthy"},{"location":"drivers/kubernetes/#deployment_is_not_fully_available","text":"Type probe Module chaosk8s.probes Name deployment_is_not_fully_available Return None Wait until the deployment gets into an intermediate state where not all expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def deployment_is_not_fully_available ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No timeout integer 30 No Usage: { \"name\" : \"deployment-is-not-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"deployment_is_not_fully_available\" , \"module\" : \"chaosk8s.probes\" } } name : deployment-is-not-fully-available provider : arguments : name : '' func : deployment_is_not_fully_available module : chaosk8s.probes type : python type : probe","title":"deployment_is_not_fully_available"},{"location":"drivers/kubernetes/#microservice_available_and_healthy","text":"Type probe Module chaosk8s.probes Name microservice_available_and_healthy Return None Lookup a deployment by name in the namespace ns . The selected resources are matched by the given label_selector . Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def microservice_available_and_healthy ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"microservice-available-and-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"microservice_available_and_healthy\" , \"module\" : \"chaosk8s.probes\" } } name : microservice-available-and-healthy provider : arguments : name : '' func : microservice_available_and_healthy module : chaosk8s.probes type : python type : probe","title":"microservice_available_and_healthy"},{"location":"drivers/kubernetes/#microservice_is_not_available","text":"Type probe Module chaosk8s.probes Name microservice_is_not_available Return None Lookup pods with a name label set to the given name in the specified ns . Raises :exc: chaoslib.exceptions.ActivityFailed when one of the pods with the specified name is in the \"Running\" phase. Signature: def microservice_is_not_available ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"microservice-is-not-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"microservice_is_not_available\" , \"module\" : \"chaosk8s.probes\" } } name : microservice-is-not-available provider : arguments : name : '' func : microservice_is_not_available module : chaosk8s.probes type : python type : probe","title":"microservice_is_not_available"},{"location":"drivers/kubernetes/#read_microservices_logs","text":"Type probe Module chaosk8s.probes Name read_microservices_logs Return None Fetch logs for all the pods with the label \"name\" set to name and return a dictionary with the keys being the pod\u2019s name and the values the logs of said pod. If name is not provided, use only the label_selector instead. When your pod has several containers, you should also set container_name to clarify which container you want to read logs from. If you provide last , this returns the logs of the last N seconds until now. This can set to a fluent delta such as 10 minutes . You may also set from_previous to True to capture the logs of a previous pod\u2019s incarnation, if any. Signature: def read_microservices_logs ( name : str = None , last : Union [ str , NoneType ] = None , ns : str = 'default' , from_previous : bool = False , label_selector : str = 'name in ({name})' , container_name : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , str ]: pass Arguments: Name Type Default Required name string null No last object null No ns string \u201cdefault\u201d No from_previous boolean false No label_selector string \u201cname in ({name})\u201d No container_name string null No Usage: { \"name\" : \"read-microservices-logs\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"func\" : \"read_microservices_logs\" , \"module\" : \"chaosk8s.probes\" } } name : read-microservices-logs provider : func : read_microservices_logs module : chaosk8s.probes type : python type : probe","title":"read_microservices_logs"},{"location":"drivers/kubernetes/#service_endpoint_is_initialized","text":"Type probe Module chaosk8s.probes Name service_endpoint_is_initialized Return None Lookup a service endpoint by its name and raises :exc: FailedProbe when the service was not found or not initialized. Signature: def service_endpoint_is_initialized ( name : str , ns : str = 'default' , label_selector : str = 'name in ({name})' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"service-endpoint-is-initialized\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"arguments\" : { \"name\" : \"\" }, \"func\" : \"service_endpoint_is_initialized\" , \"module\" : \"chaosk8s.probes\" } } name : service-endpoint-is-initialized provider : arguments : name : '' func : service_endpoint_is_initialized module : chaosk8s.probes type : python type : probe","title":"service_endpoint_is_initialized"},{"location":"drivers/opentracing/","text":"Extension chaostracing \u00b6 Version 0.1.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-opentracing This project is an extension for the Chaos Toolkit for OpenTracing . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-opentracing Usage \u00b6 Currently, this extension only provides control support to send traces to your provider during the execution of the experiment. It does not yet expose any probes or actions per-se. To use this control, add the following section to your experiment, at the top-level: { \"configuration\" : { \"tracing_provider\" : \"jaeger\" , \"tracing_host\" : \"127.0.0.1\" , \"tracing_port\" : 6831 }, \"controls\" : [ { \"name\" : \"opentracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] } This will automatically create a Jaeger client to emit traces onto the address 127.0.0.1:6831 . Use from other extensions \u00b6 You may also access the tracer from other extensions as follows: import opentracing def some_function ( ... ): opentracing . tracer As not all Open Tracing providers support yet to fetch the active span from the tracer (Open Tracing 2 specification), we attach the following attributes to the tracer instance: tracer . experiment_span # span during the lifetime of the experiment tracer . hypothesis_span # span during the lifetime of the hypothesis tracer . method_span # span during the lifetime of the method tracer . rollback_span # span during the lifetime of the rollback tracer . activity_span # span during the lifetime of an activity For instance, assuming you have an extension that makes a HTTP call you want to trace specifically, you could do this from your extension\u2019s code: import opentracing import requests def my_activity ( ... ): headers = {} tracer = opentracing . tracer parent_span = tracer . activity_span span = tracer . start_span ( \"my-inner-span\" , child_of = parent_span ) span . set_tag ( 'http.method' , 'GET' ) span . set_tag ( 'http.url' , url ) span . set_tag ( 'span.kind' , 'client' ) span . tracer . inject ( span , 'http_headers' , headers ) r = requests . get ( url , headers = headers ) span . set_tag ( 'http.status_code' , r . status_code ) span . finish () Because the opentracing exposes a noop tracer when non has been initialized, it should be safe to have that code in your extensions without having to determine if the extension has been enabled in the experiment. Open Tracing Provider Support \u00b6 For now, only the Jaeger tracer is supported but other backends will be added as need be in the future. Jaeger tracer \u00b6 To install the necessary dependencies for the Jaeger tracer, please run: $ pip install chaostoolkit-opentracing[jaeger] Unfortunately, the Jaeger client does not yet support Open Tracing 2.0. Test \u00b6 To run the tests for the project execute the following: $ pytest Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Exported Controls \u00b6 This package exports controls covering the following phases of the execution of an experiment: Level Before After Experiment True True Steady-state Hypothesis True True Method True True Rollback True True Activities True True To use this control module, please add the following section to your experiment: { \"name\" : \"chaostracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } name : chaostracing provider : module : chaostracing.control type : python This block may also be enabled at any other level (steady-state hypothesis or activity) to focus only on that level. When enabled at the experiment level, by default, all sub-levels are also applied unless you set the automatic properties to false .","title":"Open Tracing"},{"location":"drivers/opentracing/#extension-chaostracing","text":"Version 0.1.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-opentracing This project is an extension for the Chaos Toolkit for OpenTracing .","title":"Extension chaostracing"},{"location":"drivers/opentracing/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-opentracing","title":"Install"},{"location":"drivers/opentracing/#usage","text":"Currently, this extension only provides control support to send traces to your provider during the execution of the experiment. It does not yet expose any probes or actions per-se. To use this control, add the following section to your experiment, at the top-level: { \"configuration\" : { \"tracing_provider\" : \"jaeger\" , \"tracing_host\" : \"127.0.0.1\" , \"tracing_port\" : 6831 }, \"controls\" : [ { \"name\" : \"opentracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] } This will automatically create a Jaeger client to emit traces onto the address 127.0.0.1:6831 .","title":"Usage"},{"location":"drivers/opentracing/#use-from-other-extensions","text":"You may also access the tracer from other extensions as follows: import opentracing def some_function ( ... ): opentracing . tracer As not all Open Tracing providers support yet to fetch the active span from the tracer (Open Tracing 2 specification), we attach the following attributes to the tracer instance: tracer . experiment_span # span during the lifetime of the experiment tracer . hypothesis_span # span during the lifetime of the hypothesis tracer . method_span # span during the lifetime of the method tracer . rollback_span # span during the lifetime of the rollback tracer . activity_span # span during the lifetime of an activity For instance, assuming you have an extension that makes a HTTP call you want to trace specifically, you could do this from your extension\u2019s code: import opentracing import requests def my_activity ( ... ): headers = {} tracer = opentracing . tracer parent_span = tracer . activity_span span = tracer . start_span ( \"my-inner-span\" , child_of = parent_span ) span . set_tag ( 'http.method' , 'GET' ) span . set_tag ( 'http.url' , url ) span . set_tag ( 'span.kind' , 'client' ) span . tracer . inject ( span , 'http_headers' , headers ) r = requests . get ( url , headers = headers ) span . set_tag ( 'http.status_code' , r . status_code ) span . finish () Because the opentracing exposes a noop tracer when non has been initialized, it should be safe to have that code in your extensions without having to determine if the extension has been enabled in the experiment.","title":"Use from other extensions"},{"location":"drivers/opentracing/#open-tracing-provider-support","text":"For now, only the Jaeger tracer is supported but other backends will be added as need be in the future.","title":"Open Tracing Provider Support"},{"location":"drivers/opentracing/#jaeger-tracer","text":"To install the necessary dependencies for the Jaeger tracer, please run: $ pip install chaostoolkit-opentracing[jaeger] Unfortunately, the Jaeger client does not yet support Open Tracing 2.0.","title":"Jaeger tracer"},{"location":"drivers/opentracing/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/opentracing/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/opentracing/#exported-controls","text":"This package exports controls covering the following phases of the execution of an experiment: Level Before After Experiment True True Steady-state Hypothesis True True Method True True Rollback True True Activities True True To use this control module, please add the following section to your experiment: { \"name\" : \"chaostracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } name : chaostracing provider : module : chaostracing.control type : python This block may also be enabled at any other level (steady-state hypothesis or activity) to focus only on that level. When enabled at the experiment level, by default, all sub-levels are also applied unless you set the automatic properties to false .","title":"Exported Controls"},{"location":"drivers/overview/","text":"Drivers Overview \u00b6 Chaos Toolkit drivers extend the toolkit to be able to cause chaos and probe different types of systems. You can create your own drivers privately or publicly to customize the toolkit for your own needs. The following extensons have been created by and contributed back to the open source community as publicly available drivers: Extension Name Description chaosaws Probes and Actions for Amazon Web Services chaosazure Probes and Actions for Microsoft Azure chaoscf Probes and Actions for Pivotal Cloud Foundry chaosgce Probes and Actions for Google Cloud Engine chaoshumio Notification and controls for logging to Humio chaosk8s Probes and Actions for Kubernetes chaosprometheus Probes for Prometheus chaosspring Probes and Actions for Spring Boot chaostoxi Probes and Actions for Toxi Proxy chaosopentracing Controls tracing experiment\u2019s executions","title":"Overview"},{"location":"drivers/overview/#drivers-overview","text":"Chaos Toolkit drivers extend the toolkit to be able to cause chaos and probe different types of systems. You can create your own drivers privately or publicly to customize the toolkit for your own needs. The following extensons have been created by and contributed back to the open source community as publicly available drivers: Extension Name Description chaosaws Probes and Actions for Amazon Web Services chaosazure Probes and Actions for Microsoft Azure chaoscf Probes and Actions for Pivotal Cloud Foundry chaosgce Probes and Actions for Google Cloud Engine chaoshumio Notification and controls for logging to Humio chaosk8s Probes and Actions for Kubernetes chaosprometheus Probes for Prometheus chaosspring Probes and Actions for Spring Boot chaostoxi Probes and Actions for Toxi Proxy chaosopentracing Controls tracing experiment\u2019s executions","title":"Drivers Overview"},{"location":"drivers/prometheus/","text":"Extension chaosprometheus \u00b6 Version 0.3.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-prometheus N/A Exported Activities \u00b6 probes \u00b6 query \u00b6 Type probe Module chaosprometheus.probes Name query Return mapping Run an instant query against a Prometheus server and returns its result as-is. Signature: def query ( query : str , when : str = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required query string Yes when string null No timeout number null No Usage: { \"name\" : \"query\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query\" , \"arguments\" : { \"query\" : \"\" } } } name : query provider : arguments : query : '' func : query module : chaosprometheus.probes type : python type : probe query_interval \u00b6 Type probe Module chaosprometheus.probes Name query_interval Return mapping Run a range query against a Prometheus server and returns its result as-is. The start and end arguments can be a RFC 3339 date or expressed more colloquially such as \"5 minutes ago\" . Signature: def query_interval ( query : str , start : str , end : str , step : int = 1 , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required query string Yes start string Yes end string Yes step integer 1 No timeout number null No Usage: { \"name\" : \"query-interval\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"arguments\" : { \"query\" : \"\" , \"start\" : \"\" , \"end\" : \"\" } } } name : query-interval provider : arguments : end : '' query : '' start : '' func : query_interval module : chaosprometheus.probes type : python type : probe","title":"Prometheus"},{"location":"drivers/prometheus/#extension-chaosprometheus","text":"Version 0.3.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-prometheus N/A","title":"Extension chaosprometheus"},{"location":"drivers/prometheus/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/prometheus/#probes","text":"","title":"probes"},{"location":"drivers/prometheus/#query","text":"Type probe Module chaosprometheus.probes Name query Return mapping Run an instant query against a Prometheus server and returns its result as-is. Signature: def query ( query : str , when : str = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required query string Yes when string null No timeout number null No Usage: { \"name\" : \"query\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query\" , \"arguments\" : { \"query\" : \"\" } } } name : query provider : arguments : query : '' func : query module : chaosprometheus.probes type : python type : probe","title":"query"},{"location":"drivers/prometheus/#query_interval","text":"Type probe Module chaosprometheus.probes Name query_interval Return mapping Run a range query against a Prometheus server and returns its result as-is. The start and end arguments can be a RFC 3339 date or expressed more colloquially such as \"5 minutes ago\" . Signature: def query_interval ( query : str , start : str , end : str , step : int = 1 , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required query string Yes start string Yes end string Yes step integer 1 No timeout number null No Usage: { \"name\" : \"query-interval\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"arguments\" : { \"query\" : \"\" , \"start\" : \"\" , \"end\" : \"\" } } } name : query-interval provider : arguments : end : '' query : '' start : '' func : query_interval module : chaosprometheus.probes type : python type : probe","title":"query_interval"},{"location":"drivers/spring/","text":"Extension chaosspring \u00b6 Version 0.1.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-spring N/A Exported Activities \u00b6 actions \u00b6 change_assaults_configuration \u00b6 Type action Module chaosspring.actions Name change_assaults_configuration Return string Change Assaults configuration on a specific service. Signature: def change_assaults_configuration ( base_url : str , assaults_configuration : Dict [ str , Any ], timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes assaults_configuration mapping Yes timeout number null No Usage: { \"name\" : \"change-assaults-configuration\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"change_assaults_configuration\" , \"arguments\" : { \"base_url\" : \"\" , \"assaults_configuration\" : {} } } } name : change-assaults-configuration provider : arguments : assaults_configuration : {} base_url : '' func : change_assaults_configuration module : chaosspring.actions type : python type : action disable_chaosmonkey \u00b6 Type action Module chaosspring.actions Name disable_chaosmonkey Return string Disable Chaos Monkey on a specific service. Signature: def disable_chaosmonkey ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"disable-chaosmonkey\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"disable_chaosmonkey\" , \"arguments\" : { \"base_url\" : \"\" } } } name : disable-chaosmonkey provider : arguments : base_url : '' func : disable_chaosmonkey module : chaosspring.actions type : python type : action enable_chaosmonkey \u00b6 Type action Module chaosspring.actions Name enable_chaosmonkey Return string Enable Chaos Monkey on a specific service. Signature: def enable_chaosmonkey ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"enable-chaosmonkey\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"enable_chaosmonkey\" , \"arguments\" : { \"base_url\" : \"\" } } } name : enable-chaosmonkey provider : arguments : base_url : '' func : enable_chaosmonkey module : chaosspring.actions type : python type : action probes \u00b6 assaults_configuration \u00b6 Type probe Module chaosspring.probes Name assaults_configuration Return mapping Get the current assaults configuration from the specified service. Signature: def assaults_configuration ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"assaults-configuration\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"assaults_configuration\" , \"arguments\" : { \"base_url\" : \"\" } } } name : assaults-configuration provider : arguments : base_url : '' func : assaults_configuration module : chaosspring.probes type : python type : probe chaosmonkey_enabled \u00b6 Type probe Module chaosspring.probes Name chaosmonkey_enabled Return boolean Enquire whether Chaos Monkey is enabled on the specified service. Signature: def chaosmonkey_enabled ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"chaosmonkey-enabled\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"chaosmonkey_enabled\" , \"arguments\" : { \"base_url\" : \"\" } } } name : chaosmonkey-enabled provider : arguments : base_url : '' func : chaosmonkey_enabled module : chaosspring.probes type : python type : probe watcher_configuration \u00b6 Type probe Module chaosspring.probes Name watcher_configuration Return mapping Get the current watcher configuration from the specified service. Signature: def watcher_configuration ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"watcher-configuration\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"watcher_configuration\" , \"arguments\" : { \"base_url\" : \"\" } } } name : watcher-configuration provider : arguments : base_url : '' func : watcher_configuration module : chaosspring.probes type : python type : probe","title":"Spring"},{"location":"drivers/spring/#extension-chaosspring","text":"Version 0.1.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-spring N/A","title":"Extension chaosspring"},{"location":"drivers/spring/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/spring/#actions","text":"","title":"actions"},{"location":"drivers/spring/#change_assaults_configuration","text":"Type action Module chaosspring.actions Name change_assaults_configuration Return string Change Assaults configuration on a specific service. Signature: def change_assaults_configuration ( base_url : str , assaults_configuration : Dict [ str , Any ], timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes assaults_configuration mapping Yes timeout number null No Usage: { \"name\" : \"change-assaults-configuration\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"change_assaults_configuration\" , \"arguments\" : { \"base_url\" : \"\" , \"assaults_configuration\" : {} } } } name : change-assaults-configuration provider : arguments : assaults_configuration : {} base_url : '' func : change_assaults_configuration module : chaosspring.actions type : python type : action","title":"change_assaults_configuration"},{"location":"drivers/spring/#disable_chaosmonkey","text":"Type action Module chaosspring.actions Name disable_chaosmonkey Return string Disable Chaos Monkey on a specific service. Signature: def disable_chaosmonkey ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"disable-chaosmonkey\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"disable_chaosmonkey\" , \"arguments\" : { \"base_url\" : \"\" } } } name : disable-chaosmonkey provider : arguments : base_url : '' func : disable_chaosmonkey module : chaosspring.actions type : python type : action","title":"disable_chaosmonkey"},{"location":"drivers/spring/#enable_chaosmonkey","text":"Type action Module chaosspring.actions Name enable_chaosmonkey Return string Enable Chaos Monkey on a specific service. Signature: def enable_chaosmonkey ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"enable-chaosmonkey\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"enable_chaosmonkey\" , \"arguments\" : { \"base_url\" : \"\" } } } name : enable-chaosmonkey provider : arguments : base_url : '' func : enable_chaosmonkey module : chaosspring.actions type : python type : action","title":"enable_chaosmonkey"},{"location":"drivers/spring/#probes","text":"","title":"probes"},{"location":"drivers/spring/#assaults_configuration","text":"Type probe Module chaosspring.probes Name assaults_configuration Return mapping Get the current assaults configuration from the specified service. Signature: def assaults_configuration ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"assaults-configuration\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"assaults_configuration\" , \"arguments\" : { \"base_url\" : \"\" } } } name : assaults-configuration provider : arguments : base_url : '' func : assaults_configuration module : chaosspring.probes type : python type : probe","title":"assaults_configuration"},{"location":"drivers/spring/#chaosmonkey_enabled","text":"Type probe Module chaosspring.probes Name chaosmonkey_enabled Return boolean Enquire whether Chaos Monkey is enabled on the specified service. Signature: def chaosmonkey_enabled ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"chaosmonkey-enabled\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"chaosmonkey_enabled\" , \"arguments\" : { \"base_url\" : \"\" } } } name : chaosmonkey-enabled provider : arguments : base_url : '' func : chaosmonkey_enabled module : chaosspring.probes type : python type : probe","title":"chaosmonkey_enabled"},{"location":"drivers/spring/#watcher_configuration","text":"Type probe Module chaosspring.probes Name watcher_configuration Return mapping Get the current watcher configuration from the specified service. Signature: def watcher_configuration ( base_url : str , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required base_url string Yes timeout number null No Usage: { \"name\" : \"watcher-configuration\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"watcher_configuration\" , \"arguments\" : { \"base_url\" : \"\" } } } name : watcher-configuration provider : arguments : base_url : '' func : watcher_configuration module : chaosspring.probes type : python type : probe","title":"watcher_configuration"},{"location":"drivers/toxiproxy/","text":"","title":"ToxiProxy"},{"location":"reference/concepts/","text":"Chaos Engineering Concepts in the Chaos Toolkit \u00b6 If you haven\u2019t already, we strongly recommend reading the fantastic Chaos Engineering book from O\u2019Reilly Media. This book will give you some fantastic background on the whole Chaos Engineering discipline, and it\u2019s free! Chaos Engineering is a discipline that allows you to surface weaknesses, and eventually build confidence, in complex and often distributed systems. The Chaos Toolkit aims to give you the simplest experience for writing and running your own Chaos Engineering experiments. The main concepts are all expressed in an experiment definition, of which the following is an example from the Chaos Toolkit Samples project: { \"version\" : \"1.0.0\" , \"title\" : \"System is resilient to provider's failures\" , \"description\" : \"Can our consumer survive gracefully a provider's failure?\" , \"tags\" : [ \"service\" , \"kubernetes\" , \"spring\" ], \"steady-state-hypothesis\" : { \"title\" : \"Services are all available and healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"all-services-are-healthy\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"all_microservices_healthy\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"stop-provider-service\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"kill_microservice\" , \"arguments\" : { \"name\" : \"my-provider-service\" } }, \"pauses\" : { \"after\" : 10 } }, { \"ref\" : \"all-services-are-healthy\" }, { \"type\" : \"probe\" , \"name\" : \"consumer-service-must-still-respond\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://192.168.42.58:31018/invokeConsumedService\" } } ], \"rollbacks\" : [] } The key concepts of the Chaos Toolkit are Experiments , Steady State Hypothesis and the experiment\u2019s Method . The Method contains a combination of Probes and Actions . Experiments \u00b6 A Chaos Toolkit experiment is provided in a single file and is currently expressed in JSON. Steady State Hypothesis \u00b6 A Steady State Hypothesis describes \u201cwhat normal looks like\u201d for your system in order for the experiment to surface information about weaknesses when compared against the declared \u201cnormal\u201d tolerances of what is measured. The Chaos Toolkit uses the Steady State Hypothesis for two purposes. It is used as a check before an experiment is run that the target system is in a recognised normal state. It is also used as the template for comparison of the state of your system after the experiment has been run, forming the results provided by the experiment\u2019s report. Method \u00b6 An experiment\u2019s activities are contained within its Method block. Probes \u00b6 A probe is a way of observing a particular set of conditions in the system that is undergoing experimentation. Actions \u00b6 An action is a particular activity that needs to be enacted on the system under experimentation. Rollbacks \u00b6 An experiment may define a sequence of actions that revert what was undone during the experiment.","title":"Concepts"},{"location":"reference/concepts/#chaos-engineering-concepts-in-the-chaos-toolkit","text":"If you haven\u2019t already, we strongly recommend reading the fantastic Chaos Engineering book from O\u2019Reilly Media. This book will give you some fantastic background on the whole Chaos Engineering discipline, and it\u2019s free! Chaos Engineering is a discipline that allows you to surface weaknesses, and eventually build confidence, in complex and often distributed systems. The Chaos Toolkit aims to give you the simplest experience for writing and running your own Chaos Engineering experiments. The main concepts are all expressed in an experiment definition, of which the following is an example from the Chaos Toolkit Samples project: { \"version\" : \"1.0.0\" , \"title\" : \"System is resilient to provider's failures\" , \"description\" : \"Can our consumer survive gracefully a provider's failure?\" , \"tags\" : [ \"service\" , \"kubernetes\" , \"spring\" ], \"steady-state-hypothesis\" : { \"title\" : \"Services are all available and healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"all-services-are-healthy\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"all_microservices_healthy\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"stop-provider-service\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"kill_microservice\" , \"arguments\" : { \"name\" : \"my-provider-service\" } }, \"pauses\" : { \"after\" : 10 } }, { \"ref\" : \"all-services-are-healthy\" }, { \"type\" : \"probe\" , \"name\" : \"consumer-service-must-still-respond\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://192.168.42.58:31018/invokeConsumedService\" } } ], \"rollbacks\" : [] } The key concepts of the Chaos Toolkit are Experiments , Steady State Hypothesis and the experiment\u2019s Method . The Method contains a combination of Probes and Actions .","title":"Chaos Engineering Concepts in the Chaos Toolkit"},{"location":"reference/concepts/#experiments","text":"A Chaos Toolkit experiment is provided in a single file and is currently expressed in JSON.","title":"Experiments"},{"location":"reference/concepts/#steady-state-hypothesis","text":"A Steady State Hypothesis describes \u201cwhat normal looks like\u201d for your system in order for the experiment to surface information about weaknesses when compared against the declared \u201cnormal\u201d tolerances of what is measured. The Chaos Toolkit uses the Steady State Hypothesis for two purposes. It is used as a check before an experiment is run that the target system is in a recognised normal state. It is also used as the template for comparison of the state of your system after the experiment has been run, forming the results provided by the experiment\u2019s report.","title":"Steady State Hypothesis"},{"location":"reference/concepts/#method","text":"An experiment\u2019s activities are contained within its Method block.","title":"Method"},{"location":"reference/concepts/#probes","text":"A probe is a way of observing a particular set of conditions in the system that is undergoing experimentation.","title":"Probes"},{"location":"reference/concepts/#actions","text":"An action is a particular activity that needs to be enacted on the system under experimentation.","title":"Actions"},{"location":"reference/concepts/#rollbacks","text":"An experiment may define a sequence of actions that revert what was undone during the experiment.","title":"Rollbacks"},{"location":"reference/contributing/","text":"The Chaos Toolkit is a free and open source tool and a community-driven set of projects . The community\u2019s input is what makes this project special and a success. Your input could take the form of raising issues , voting for issues , starring projects , joining us on our community Slack team , submitting pull requests , or even suggesting whole new extension projects . Whatever you can contribute, we\u2019re listening and want you to help us drive the project forward . The Chaos Toolkit Incubator \u00b6 New potential projects should be first incubated in the Chaos Toolkit Incubator until they are ready to be moved into the main Chaos Toolkit suite of projects . Conditions for graduating a project from the Incubator to the main suite of projects include: Correct Licensing and Certification of Origin. A popular starred and used extension to the Chaos Toolkit. Active and prompt project issue resolution. How to submit your own project to the incubator? \u00b6 The incubator is a place for community projects to be collected. If you think your extension makes sense as a community project, please don\u2019t hesitate to suggest it. The best place to start is on the community Slack team to announce it. Generally speaking, you should consider the followings: Can your project be made publicly available? Think it should respect the Developer Certificate of Origin Does it serve your own purpose or can it be used by anyone? What license do you want to set on it? We tend to prefer permissive licenses that are recognized by the Open Source project , such as Apache or BSD Will you be able to provide basic support to the project after you have submitted it? We are not talking about enterprise support but merely basic issues overview and bug fixes from time to time Notice also that we deal with contributors on a repository basis. Collaborators are external contributors with little permissions to the org and write permissions to the repositories they contribute to. We suggest that accounts should have 2FA enabled. This reduces the security surface risks in case a contributor account is breached. Licensing and Certification of Origin \u00b6 Every project in the Chaos Toolkit and the Chaos Toolkit Incubator is licensed under the Apache License, Version 2.0 and abides by the Developer Certificate of Origin on all accepted commits to the master branch.","title":"Contributing to the Chaos Toolkit"},{"location":"reference/contributing/#the-chaos-toolkit-incubator","text":"New potential projects should be first incubated in the Chaos Toolkit Incubator until they are ready to be moved into the main Chaos Toolkit suite of projects . Conditions for graduating a project from the Incubator to the main suite of projects include: Correct Licensing and Certification of Origin. A popular starred and used extension to the Chaos Toolkit. Active and prompt project issue resolution.","title":"The Chaos Toolkit Incubator"},{"location":"reference/contributing/#how-to-submit-your-own-project-to-the-incubator","text":"The incubator is a place for community projects to be collected. If you think your extension makes sense as a community project, please don\u2019t hesitate to suggest it. The best place to start is on the community Slack team to announce it. Generally speaking, you should consider the followings: Can your project be made publicly available? Think it should respect the Developer Certificate of Origin Does it serve your own purpose or can it be used by anyone? What license do you want to set on it? We tend to prefer permissive licenses that are recognized by the Open Source project , such as Apache or BSD Will you be able to provide basic support to the project after you have submitted it? We are not talking about enterprise support but merely basic issues overview and bug fixes from time to time Notice also that we deal with contributors on a repository basis. Collaborators are external contributors with little permissions to the org and write permissions to the repositories they contribute to. We suggest that accounts should have 2FA enabled. This reduces the security surface risks in case a contributor account is breached.","title":"How to submit your own project to the incubator?"},{"location":"reference/contributing/#licensing-and-certification-of-origin","text":"Every project in the Chaos Toolkit and the Chaos Toolkit Incubator is licensed under the Apache License, Version 2.0 and abides by the Developer Certificate of Origin on all accepted commits to the master branch.","title":"Licensing and Certification of Origin"},{"location":"reference/contributors/","text":"The Chaos Toolkit is a community-driven, free and open source collection of core projects that are gratefully contributed to by: Chaos Toolkit Chaos Toolkit Library Chaos Toolkit Reporting Chaos Toolkit Documentation Chaos Toolkit Tutorials The Chaos Toolkit is also sponsored by the following: ChaosIQ.io - ChaosIQ provides expert training , consultancy and products to help you successfully get the advantages of Chaos Engineering in your own organisations.","title":"Contributors"},{"location":"reference/introduction/","text":"Once you\u2019ve got your hands dirty with the tutorials it\u2019s time to start using the Chaos Toolkit for yourself in your own teams and with your own systems. Whether you\u2019re exploring the specific commands in the Chaos Toolkit\u2019s workflow, looking to add a new third-party integration, or even looking into how to extend the Chaos Toolkit for your own specific chaos engineering needs, this reference documentation should be your first port of call for the information you need. Concepts - The key concepts in the Chaos Toolkit Workflow - The Chaos Toolkit Workflow Usage - Reference on the core and additional commands available Open API - Guide to the Open API for Chaos Engineering experiments Extending the Chaos Toolkit - Ways to extend the Chaos Toolkit for your own, specific needs Developing the Chaos Toolkit - Get involved in developing the free and open source Chaos Toolkit projects.","title":"Introduction"},{"location":"reference/tutorial/","text":"A simple Walkthrough \u00b6 When you practice chaos engineering, you are discovering how your system reacts following certain conditions you inject. By doing this in a controlled fashion, you may learn how to change the system accordingly. This tutorial will quickly give you a tour of the basic elements of an experiment. Tip You will find interactive tutorials on the KataCoda platform as well. Get Ready \u00b6 Before you can run the experiment against your system, you will need to have it setup. Get the Code \u00b6 You can fetch the code as follows: $ git clone https://github.com/chaostoolkit/chaostoolkit-documentation-code This particular tutorial is under tutorials/a-simple-walkthrough . Install the Chaos Toolkit \u00b6 You must install the Chaos Toolkit and its dependencies for the purpose of this tutorial. While we suggest you go through the install section, it boils down to: $ pip install -U chaostoolkit Third-party binaries \u00b6 The experiment will use the following binaries, make sure you have them in your PATH: openssl pkill Install the Application dependencies \u00b6 Our application is made of a simple set of two microservices that converse with each other over HTTPS. As you should already run Python 3 for the toolkit itself, we assume you are set accordingly, please install only the application dependencies: $ pip install -U -r requirements.txt Your First Experiment \u00b6 Explore a Potential Weakness \u00b6 So, looking at our application, what could we consider as of interest to discover through an experiment? Well, we are using HTTPS between the two services in our application, what if the certificate expired? Tip In such a simple setup, we appreciate that things will likely break and, in general there is no point to run an experiment when you already know the outcome. However, let\u2019s humor ourselves for the sake of learning the basics behind the Chaos Toolkit. We can intuit things will fall apart if the sunset service cannot talk the astre service but, should the chain be part of much more complex graph of services, it could be difficult to fully understand all the branches that would be affected nor how badly. So, it may still be useful to experiment by injecting an expired certificate. Define the Steady State Hypothesis \u00b6 You can only learn if you know where you start from and what a good baseline for your application is. Here we assume two things: the services are running we can call the sunset service to retrieve the sunset time for a given city During our experiment, we will vary the conditions of the system and expect the state to remain valid. Changing the Conditions \u00b6 In this tutorial, we are going to set an expired certificate and restart the services. We will then call our application and see how it responds. Declare an Experiment to Observe the Weakness \u00b6 At this stage, we can create an experiment that tells how the system behaves when a certificate expires. { \"version\" : \"1.0.0\" , \"title\" : \"What is the impact of an expired certificate on our application chain?\" , \"description\" : \"If a certificate expires, we should gracefully deal with the issue.\" , \"tags\" : [ \"tls\" ], \"steady-state-hypothesis\" : { \"title\" : \"Application responds\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"the-astre-service-must-be-running\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"astre.pid\" } } }, { \"type\" : \"probe\" , \"name\" : \"the-sunset-service-must-be-running\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"sunset.pid\" } } }, { \"type\" : \"probe\" , \"name\" : \"we-can-request-sunset\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 3 , \"verify_tls\" : false , \"url\" : \"https://localhost:8443/city/Paris\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"swap-to-expired-cert\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"cp\" , \"arguments\" : \"expired-cert.pem cert.pem\" } }, { \"type\" : \"probe\" , \"name\" : \"read-tls-cert-expiry-date\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"openssl\" , \"arguments\" : \"x509 -enddate -noout -in cert.pem\" } }, { \"type\" : \"action\" , \"name\" : \"restart-astre-service-to-pick-up-certificate\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"pkill\" , \"arguments\" : \"--echo -HUP -F astre.pid\" } }, { \"type\" : \"action\" , \"name\" : \"restart-sunset-service-to-pick-up-certificate\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"pkill\" , \"arguments\" : \"--echo -HUP -F sunset.pid\" }, \"pauses\" : { \"after\" : 1 } } ], \"rollbacks\" : [ { \"type\" : \"action\" , \"name\" : \"swap-to-vald-cert\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"cp\" , \"arguments\" : \"valid-cert.pem cert.pem\" } }, { \"ref\" : \"restart-astre-service-to-pick-up-certificate\" }, { \"ref\" : \"restart-sunset-service-to-pick-up-certificate\" } ] } The Various Sections of an Experiment \u00b6 Let\u2019s now go through the experiment blocks. The steady state hypothesis declares the various probes that will be applied as part of the hypothesis check. The hypothesis is played twice. The first time before we do anything else to ensure the system is indeed in a normal state, here we check the services are running by looking up their PID files and we call the sunset service which should respond OK. The second time the hypothesis is applied is after the conditions were changed in the system, to validate it is still in a normal state. The method is the block which changes the conditions of our system/application. Here, we swap the valid certificate for an expired one and restart the services by sending them a SIGHUP signal. Finally, the rollback section (which is optional) tries to remediate to the changes we made, in this case by swapping back to the valid certificate. Different Kinds of Activities \u00b6 It is interesting to notice that the hypothesis uses probes while rollbacks are made of actions only. The method may use both. The reason is that the hypothesis is only about querying the system while rollbacks act on it. Finally, it is often useful to query the system while we change the conditions, for future analysis. Probes and Actions are activities that do not differ in the way they work, it\u2019s only their goal that differs. You can create activities that make HTTP calls, execute processes or perform more complex operations through extensions (often implemented in Python). This tutorial showcases a bit of all of those. Tolerances in the Hypothesis \u00b6 Hypothesis probes expect a tolerance property which tells the Chaos Toolkit how to validate a certain aspect of the state. In our example, tolerances are rather simple. We check file exists and that a HTTP request returns a status code of 200 . Richer tolerances can be created by using regex or jsonpath. Run the Experiment \u00b6 Start the Experiment without the Application \u00b6 To run the experiment, simply execute the following command: $ chaos run experiment.json [2018-05-14 18:38:04 INFO] Validating the experiment's syntax [2018-05-14 18:38:04 INFO] Experiment looks valid [2018-05-14 18:38:04 INFO] Running experiment: What is the impact of an expired certificate on our application chain? [2018-05-14 18:38:04 INFO] Steady state hypothesis: Application responds [2018-05-14 18:38:04 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:38:04 CRITICAL] Steady state probe 'the-astre-service-must-be-running' is not in the given tolerance so failing this experiment [2018-05-14 18:38:04 INFO] Let's rollback... [2018-05-14 18:38:04 INFO] Rollback: swap-to-vald-cert [2018-05-14 18:38:04 INFO] Action: swap-to-vald-cert [2018-05-14 18:38:04 INFO] Rollback: None [2018-05-14 18:38:04 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:38:04 INFO] Rollback: None [2018-05-14 18:38:04 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:38:04 INFO] Pausing after activity for 1s... [2018-05-14 18:38:05 INFO] Experiment ended with status: failed Because we ran this command before we even started our application, our steady-state hypothesis failed and bailed the experiment immediately. Note that the rollbacks will run anyway. They are only bypassed when you send a SIGINT or SIGTERM signal to the chaos process because the toolkit assumes you may want to review your system. Start the Application \u00b6 You may now run the application. First, copy the valid certificate as follows: $ cp valid-cert.pem cert.pem Next, start the services, in one terminal: $ python3 astre.py [14/May/2018:16:11:09] ENGINE Listening for SIGTERM. [14/May/2018:16:11:09] ENGINE Listening for SIGHUP. [14/May/2018:16:11:09] ENGINE Listening for SIGUSR1. [14/May/2018:16:11:09] ENGINE Bus STARTING [14/May/2018:16:11:09] ENGINE Serving on https://127.0.0.1:8444 [14/May/2018:16:11:09] ENGINE Bus STARTE Then, in another terminal: $ python3 sunset.py [14/May/2018:16:13:58] ENGINE Listening for SIGTERM. [14/May/2018:16:13:58] ENGINE Listening for SIGHUP. [14/May/2018:16:13:58] ENGINE Listening for SIGUSR1. [14/May/2018:16:13:58] ENGINE Bus STARTING [14/May/2018:16:13:58] ENGINE Serving on https://127.0.0.1:8443 [14/May/2018:16:13:58] ENGINE Bus STARTED Now you may perform a simple call: $ curl -k https://localhost:8443/city/Paris The sunset will occur at 2018-05-14T21:23:09+02:00 in Paris What happens is that the sunset service performs a call to the astre service for the data and simply render them to you, as plain text. Both services are chained together over HTTPS. Run the Experiment \u00b6 Now your application is running, execute the experiment once again: $ chaos run experiment.json [2018-05-14 18:41:09 INFO] Validating the experiment's syntax [2018-05-14 18:41:09 INFO] Experiment looks valid [2018-05-14 18:41:09 INFO] Running experiment: What is the impact of an expired certificate on our application chain? [2018-05-14 18:41:09 INFO] Steady state hypothesis: Application responds [2018-05-14 18:41:09 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:41:09 INFO] Probe: the-sunset-service-must-be-running [2018-05-14 18:41:09 INFO] Probe: we-can-request-sunset [2018-05-14 18:41:09 INFO] Steady state hypothesis is met! [2018-05-14 18:41:09 INFO] Action: swap-to-expired-cert [2018-05-14 18:41:09 INFO] Probe: read-tls-cert-expiry-date [2018-05-14 18:41:09 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:41:09 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:41:09 INFO] Pausing after activity for 1s... [2018-05-14 18:41:10 INFO] Steady state hypothesis: Application responds [2018-05-14 18:41:10 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:41:10 INFO] Probe: the-sunset-service-must-be-running [2018-05-14 18:41:10 INFO] Probe: we-can-request-sunset [2018-05-14 18:41:10 CRITICAL] Steady state probe 'we-can-request-sunset' is not in the given tolerance so failing this experiment [2018-05-14 18:41:10 INFO] Let's rollback... [2018-05-14 18:41:10 INFO] Rollback: swap-to-vald-cert [2018-05-14 18:41:10 INFO] Action: swap-to-vald-cert [2018-05-14 18:41:10 INFO] Rollback: None [2018-05-14 18:41:10 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:41:10 INFO] Rollback: None [2018-05-14 18:41:10 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:41:10 INFO] Pausing after activity for 1s... [2018-05-14 18:41:11 INFO] Experiment ended with status: failed Each activity is run in the order it appears in the experiment. Notice now how the hypothesis is not met after we swapped the certificates. But, we learn something interesting, even if expected, using an expired certificate does not prevent our services to even start. Report on your Findings \u00b6 Review the Journal of the Run \u00b6 You may now review the journal generated by the run: $ cat journal.json It contains the activities runs and the output of each of them. Generate a Report \u00b6 You can generate a PDF (or HTML, markdown\u2026) report from the journal if you install the chaostoolkit-reporting plugin first: $ chaos report --export-format = pdf journal.json report.pdf Learnings and Responses \u00b6 In this experiment, we proved what we guessed initially, that an expired certificate will create trouble and break the application for our users. What could be the responses? Use a circuit-breaker to provide a more meaningful, and controlled, answer to the caller Prevent the service to start when the certificate it uses is expired Put some monitoring in place on our certificates and trigger an alert when they get close to their end date Move to Let\u2019s Encrypt and renew our certs automatically For each of these potential responses, you could create an experiment should they unearth potential new questions. Next? \u00b6 An experiment is never the end game. The flow should be continuous and you should create and run experiments regularly.","title":"Get Started with the Chaos Toolkit"},{"location":"reference/tutorial/#a-simple-walkthrough","text":"When you practice chaos engineering, you are discovering how your system reacts following certain conditions you inject. By doing this in a controlled fashion, you may learn how to change the system accordingly. This tutorial will quickly give you a tour of the basic elements of an experiment. Tip You will find interactive tutorials on the KataCoda platform as well.","title":"A simple Walkthrough"},{"location":"reference/tutorial/#get-ready","text":"Before you can run the experiment against your system, you will need to have it setup.","title":"Get Ready"},{"location":"reference/tutorial/#get-the-code","text":"You can fetch the code as follows: $ git clone https://github.com/chaostoolkit/chaostoolkit-documentation-code This particular tutorial is under tutorials/a-simple-walkthrough .","title":"Get the Code"},{"location":"reference/tutorial/#install-the-chaos-toolkit","text":"You must install the Chaos Toolkit and its dependencies for the purpose of this tutorial. While we suggest you go through the install section, it boils down to: $ pip install -U chaostoolkit","title":"Install the Chaos Toolkit"},{"location":"reference/tutorial/#third-party-binaries","text":"The experiment will use the following binaries, make sure you have them in your PATH: openssl pkill","title":"Third-party binaries"},{"location":"reference/tutorial/#install-the-application-dependencies","text":"Our application is made of a simple set of two microservices that converse with each other over HTTPS. As you should already run Python 3 for the toolkit itself, we assume you are set accordingly, please install only the application dependencies: $ pip install -U -r requirements.txt","title":"Install the Application dependencies"},{"location":"reference/tutorial/#your-first-experiment","text":"","title":"Your First Experiment"},{"location":"reference/tutorial/#explore-a-potential-weakness","text":"So, looking at our application, what could we consider as of interest to discover through an experiment? Well, we are using HTTPS between the two services in our application, what if the certificate expired? Tip In such a simple setup, we appreciate that things will likely break and, in general there is no point to run an experiment when you already know the outcome. However, let\u2019s humor ourselves for the sake of learning the basics behind the Chaos Toolkit. We can intuit things will fall apart if the sunset service cannot talk the astre service but, should the chain be part of much more complex graph of services, it could be difficult to fully understand all the branches that would be affected nor how badly. So, it may still be useful to experiment by injecting an expired certificate.","title":"Explore a Potential Weakness"},{"location":"reference/tutorial/#define-the-steady-state-hypothesis","text":"You can only learn if you know where you start from and what a good baseline for your application is. Here we assume two things: the services are running we can call the sunset service to retrieve the sunset time for a given city During our experiment, we will vary the conditions of the system and expect the state to remain valid.","title":"Define the Steady State Hypothesis"},{"location":"reference/tutorial/#changing-the-conditions","text":"In this tutorial, we are going to set an expired certificate and restart the services. We will then call our application and see how it responds.","title":"Changing the Conditions"},{"location":"reference/tutorial/#declare-an-experiment-to-observe-the-weakness","text":"At this stage, we can create an experiment that tells how the system behaves when a certificate expires. { \"version\" : \"1.0.0\" , \"title\" : \"What is the impact of an expired certificate on our application chain?\" , \"description\" : \"If a certificate expires, we should gracefully deal with the issue.\" , \"tags\" : [ \"tls\" ], \"steady-state-hypothesis\" : { \"title\" : \"Application responds\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"the-astre-service-must-be-running\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"astre.pid\" } } }, { \"type\" : \"probe\" , \"name\" : \"the-sunset-service-must-be-running\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"sunset.pid\" } } }, { \"type\" : \"probe\" , \"name\" : \"we-can-request-sunset\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 3 , \"verify_tls\" : false , \"url\" : \"https://localhost:8443/city/Paris\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"swap-to-expired-cert\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"cp\" , \"arguments\" : \"expired-cert.pem cert.pem\" } }, { \"type\" : \"probe\" , \"name\" : \"read-tls-cert-expiry-date\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"openssl\" , \"arguments\" : \"x509 -enddate -noout -in cert.pem\" } }, { \"type\" : \"action\" , \"name\" : \"restart-astre-service-to-pick-up-certificate\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"pkill\" , \"arguments\" : \"--echo -HUP -F astre.pid\" } }, { \"type\" : \"action\" , \"name\" : \"restart-sunset-service-to-pick-up-certificate\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"pkill\" , \"arguments\" : \"--echo -HUP -F sunset.pid\" }, \"pauses\" : { \"after\" : 1 } } ], \"rollbacks\" : [ { \"type\" : \"action\" , \"name\" : \"swap-to-vald-cert\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"cp\" , \"arguments\" : \"valid-cert.pem cert.pem\" } }, { \"ref\" : \"restart-astre-service-to-pick-up-certificate\" }, { \"ref\" : \"restart-sunset-service-to-pick-up-certificate\" } ] }","title":"Declare an Experiment to Observe the Weakness"},{"location":"reference/tutorial/#the-various-sections-of-an-experiment","text":"Let\u2019s now go through the experiment blocks. The steady state hypothesis declares the various probes that will be applied as part of the hypothesis check. The hypothesis is played twice. The first time before we do anything else to ensure the system is indeed in a normal state, here we check the services are running by looking up their PID files and we call the sunset service which should respond OK. The second time the hypothesis is applied is after the conditions were changed in the system, to validate it is still in a normal state. The method is the block which changes the conditions of our system/application. Here, we swap the valid certificate for an expired one and restart the services by sending them a SIGHUP signal. Finally, the rollback section (which is optional) tries to remediate to the changes we made, in this case by swapping back to the valid certificate.","title":"The Various Sections of an Experiment"},{"location":"reference/tutorial/#different-kinds-of-activities","text":"It is interesting to notice that the hypothesis uses probes while rollbacks are made of actions only. The method may use both. The reason is that the hypothesis is only about querying the system while rollbacks act on it. Finally, it is often useful to query the system while we change the conditions, for future analysis. Probes and Actions are activities that do not differ in the way they work, it\u2019s only their goal that differs. You can create activities that make HTTP calls, execute processes or perform more complex operations through extensions (often implemented in Python). This tutorial showcases a bit of all of those.","title":"Different Kinds of Activities"},{"location":"reference/tutorial/#tolerances-in-the-hypothesis","text":"Hypothesis probes expect a tolerance property which tells the Chaos Toolkit how to validate a certain aspect of the state. In our example, tolerances are rather simple. We check file exists and that a HTTP request returns a status code of 200 . Richer tolerances can be created by using regex or jsonpath.","title":"Tolerances in the Hypothesis"},{"location":"reference/tutorial/#run-the-experiment","text":"","title":"Run the Experiment"},{"location":"reference/tutorial/#start-the-experiment-without-the-application","text":"To run the experiment, simply execute the following command: $ chaos run experiment.json [2018-05-14 18:38:04 INFO] Validating the experiment's syntax [2018-05-14 18:38:04 INFO] Experiment looks valid [2018-05-14 18:38:04 INFO] Running experiment: What is the impact of an expired certificate on our application chain? [2018-05-14 18:38:04 INFO] Steady state hypothesis: Application responds [2018-05-14 18:38:04 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:38:04 CRITICAL] Steady state probe 'the-astre-service-must-be-running' is not in the given tolerance so failing this experiment [2018-05-14 18:38:04 INFO] Let's rollback... [2018-05-14 18:38:04 INFO] Rollback: swap-to-vald-cert [2018-05-14 18:38:04 INFO] Action: swap-to-vald-cert [2018-05-14 18:38:04 INFO] Rollback: None [2018-05-14 18:38:04 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:38:04 INFO] Rollback: None [2018-05-14 18:38:04 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:38:04 INFO] Pausing after activity for 1s... [2018-05-14 18:38:05 INFO] Experiment ended with status: failed Because we ran this command before we even started our application, our steady-state hypothesis failed and bailed the experiment immediately. Note that the rollbacks will run anyway. They are only bypassed when you send a SIGINT or SIGTERM signal to the chaos process because the toolkit assumes you may want to review your system.","title":"Start the Experiment without the Application"},{"location":"reference/tutorial/#start-the-application","text":"You may now run the application. First, copy the valid certificate as follows: $ cp valid-cert.pem cert.pem Next, start the services, in one terminal: $ python3 astre.py [14/May/2018:16:11:09] ENGINE Listening for SIGTERM. [14/May/2018:16:11:09] ENGINE Listening for SIGHUP. [14/May/2018:16:11:09] ENGINE Listening for SIGUSR1. [14/May/2018:16:11:09] ENGINE Bus STARTING [14/May/2018:16:11:09] ENGINE Serving on https://127.0.0.1:8444 [14/May/2018:16:11:09] ENGINE Bus STARTE Then, in another terminal: $ python3 sunset.py [14/May/2018:16:13:58] ENGINE Listening for SIGTERM. [14/May/2018:16:13:58] ENGINE Listening for SIGHUP. [14/May/2018:16:13:58] ENGINE Listening for SIGUSR1. [14/May/2018:16:13:58] ENGINE Bus STARTING [14/May/2018:16:13:58] ENGINE Serving on https://127.0.0.1:8443 [14/May/2018:16:13:58] ENGINE Bus STARTED Now you may perform a simple call: $ curl -k https://localhost:8443/city/Paris The sunset will occur at 2018-05-14T21:23:09+02:00 in Paris What happens is that the sunset service performs a call to the astre service for the data and simply render them to you, as plain text. Both services are chained together over HTTPS.","title":"Start the Application"},{"location":"reference/tutorial/#run-the-experiment_1","text":"Now your application is running, execute the experiment once again: $ chaos run experiment.json [2018-05-14 18:41:09 INFO] Validating the experiment's syntax [2018-05-14 18:41:09 INFO] Experiment looks valid [2018-05-14 18:41:09 INFO] Running experiment: What is the impact of an expired certificate on our application chain? [2018-05-14 18:41:09 INFO] Steady state hypothesis: Application responds [2018-05-14 18:41:09 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:41:09 INFO] Probe: the-sunset-service-must-be-running [2018-05-14 18:41:09 INFO] Probe: we-can-request-sunset [2018-05-14 18:41:09 INFO] Steady state hypothesis is met! [2018-05-14 18:41:09 INFO] Action: swap-to-expired-cert [2018-05-14 18:41:09 INFO] Probe: read-tls-cert-expiry-date [2018-05-14 18:41:09 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:41:09 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:41:09 INFO] Pausing after activity for 1s... [2018-05-14 18:41:10 INFO] Steady state hypothesis: Application responds [2018-05-14 18:41:10 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:41:10 INFO] Probe: the-sunset-service-must-be-running [2018-05-14 18:41:10 INFO] Probe: we-can-request-sunset [2018-05-14 18:41:10 CRITICAL] Steady state probe 'we-can-request-sunset' is not in the given tolerance so failing this experiment [2018-05-14 18:41:10 INFO] Let's rollback... [2018-05-14 18:41:10 INFO] Rollback: swap-to-vald-cert [2018-05-14 18:41:10 INFO] Action: swap-to-vald-cert [2018-05-14 18:41:10 INFO] Rollback: None [2018-05-14 18:41:10 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:41:10 INFO] Rollback: None [2018-05-14 18:41:10 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:41:10 INFO] Pausing after activity for 1s... [2018-05-14 18:41:11 INFO] Experiment ended with status: failed Each activity is run in the order it appears in the experiment. Notice now how the hypothesis is not met after we swapped the certificates. But, we learn something interesting, even if expected, using an expired certificate does not prevent our services to even start.","title":"Run the Experiment"},{"location":"reference/tutorial/#report-on-your-findings","text":"","title":"Report on your Findings"},{"location":"reference/tutorial/#review-the-journal-of-the-run","text":"You may now review the journal generated by the run: $ cat journal.json It contains the activities runs and the output of each of them.","title":"Review the Journal of the Run"},{"location":"reference/tutorial/#generate-a-report","text":"You can generate a PDF (or HTML, markdown\u2026) report from the journal if you install the chaostoolkit-reporting plugin first: $ chaos report --export-format = pdf journal.json report.pdf","title":"Generate a Report"},{"location":"reference/tutorial/#learnings-and-responses","text":"In this experiment, we proved what we guessed initially, that an expired certificate will create trouble and break the application for our users. What could be the responses? Use a circuit-breaker to provide a more meaningful, and controlled, answer to the caller Prevent the service to start when the certificate it uses is expired Put some monitoring in place on our certificates and trigger an alert when they get close to their end date Move to Let\u2019s Encrypt and renew our certs automatically For each of these potential responses, you could create an experiment should they unearth potential new questions.","title":"Learnings and Responses"},{"location":"reference/tutorial/#next","text":"An experiment is never the end game. The flow should be continuous and you should create and run experiments regularly.","title":"Next?"},{"location":"reference/workflow/","text":"Chaos Engineering is about building experiments that you and your team can then learn from as you decide what weaknesses to guard against in your production systems. You can then execute those automated experiments as continuously as possible to discover and explore further weaknesses if they arise over time in your system. To enable and speed up the exploration and implementation of these learning loops through Chaos Engineering the Chaos Toolkit implements a specific workflow through a set of commands that can be run using the Chaos Toolkit\u2019s CLI: discover - Used to discover the capabilities of your target systems and the levels within those systems init - Takes what has been discovered and then helps you initialise a new experiment definition . run - Takes an experiment definition and executes it. report - Takes the output from an experiment\u2019s execution and produces a report for every stakeholder interested in the experiment\u2019s outcome. This workflow and all of the above commands can be explored in the Chaos Toolkit\u2019s freely available online tutorials.","title":"Workflow"},{"location":"reference/api/experiment/","text":"An Open API for Chaos Engineering Experiments \u00b6 Info The current specification has not reached its 1.0.0 stable version yet. Make sure to join the discussion to provide any feedback you might have. Introduction \u00b6 The purpose of this specification is to formalize the elements of a Chaos Engineering experiment and offer a way to federate the community around a common syntax and semantic. As a fairly recent field, Chaos Engineering is a dynamic and its foundations are still emerging. However, it appears certain concepts are settling down enough to start agreeing on a shared understanding. This specification is not prescriptive and does not aim at forcing the community into one direction, rather it strives at providing a common vocabulary that new practitioners can easily make sense of. It is necessary to appreciate that this document does not specify what tools, such as the Chaos Monkey or similar, should look like. Instead, this document specifies how Chaos Engineering Experiment could be described, shared and conducted collaboratively. Conventions Used in This Document \u00b6 The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d, \u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this document are to be interpreted as defined in RFC 7159 . Other formats \u00b6 While this specification uses JSON to define its elements, implementations may allow loading from other formats, such as YAML . As long as the output of such format respects the specification herein. Chaos Engineering Elements \u00b6 Overview \u00b6 An Experiment is one possible description of the principles of the Chaos Engineering . The intention of such a description is to provide shared understanding around a hypothesis on how to discover system\u2019s behavior under certain conditions. An Experiment declares a steady state hypothesis , alongside probes to validate this steady state is met, and a method as a sequence actions and probes , to interact and query the system respectively. By using a variety of probes , experiments should gather information to sense behaviors in the system, potentially leading to systemic patterns that can be stabilized. Experiment \u00b6 A Chaos Engineering experiment, or simply an experiment, describes both the elements and the order in which they should be applied. An experiment is a JSON object. An experiment MUST declare: a version property a title property a description property a steady-state-hypothesis property a method property The version property MUST be \"0.1.0\" . The experiment\u2019s title and description are meant for humans and therefore should be as descriptive as possible to clarify the experiment\u2019s rationale. Title and description are JSON strings with no maximum length. An experiment SHOULD also declare: a rollbacks property An experiment MAY finally declare: a tags property a secrets property an extension property a contributions property a controls property Tags provide a way of categorizing experiments. It is a sequence of JSON strings. Extensions define opaque payloads for vendors to carry valuable information. Contribution describes valuable properties of the target system, such as \u201creliability\u201d or \u201cdurability\u201d, that an experiment contribute to. This information can be aggregated together with other experiments\u2019 contributions to better appreciate where the focus is put and where it is not. Controls describe out-of-band capabilities applied during the experiment\u2019s execution. Steady State Hypothesis \u00b6 The Steady State Hypothesis element describes what normal looks like in your system before the Method element is applied. If the steady state is not met, the Method element is not applied and the experiment MUST bail out. The Steady State Hypothesis element is a JSON object. Steady State Hypothesis element MUST declare: a title property a probes property The title is meant for humans and therefore should clarify the rationale for this hypothesis. Each Probe MUST define a tolerance property that acting as a gate mechanism for the experiment to carry on or bail. Any Probe that does not fall into the tolerance zone MUST fail the experiment. Steady State Hypothesis element MAY declare: a controls property Controls describe out-of-band capabilities applied during the experiment\u2019s execution. Steady State Probe Tolerance \u00b6 Probes of the Steady State Hypothesis MUST declare an additional property named tolerance . The tolerance property\u2019s value MUST be one of: a scalar: JSON string, number (an integer), boolean a sequence of scalars: JSON string, number, boolean an object In the case of a scalar or the sequence, the tolerance validation MUST be strict. The value returned by the Probe MUST be checked against the scalar value. The experiment MUST bail when both fail to match. When the tolerance is a sequence. If it has only two values, those two values represent a lower and upper bound within which the Probe returned value must fall (inclusive). When the sequence has more than two elements, the Probe returned value must be contained in that sequence. When the tolerance is an object, it MUST have a type property which MUST be one of the followings: \"probe\" , \"regex\" or \"jsonpath\" . When the type property is \"probe\" , the object MUST be a Probe that is applied. The probe should take two arguments, value and secrets where the value is the Probe returned value and secrets a Secret object or null . Its returned status MUST be successful for the tolerance to be considered valid. When the type property is \"regex\" , the object MUST have a pattern property which MUST be a valid regular expression. The tolerance succeeds if the Probe returned value is matched against the pattern. When the type property is \"jsonpath\" , the object MUST have a path property which MUST be a valid JSON Path . In addition, the object MAY have a expect property which is used to compare each value matched by the JSON Path to that value. The expect property value MUST be a scalar. When the expect property is not present, the tolerance succeeds if the JSON Path matched at least one item. In addition, when the Probe returned value is an object with a \u0300 status property, the tested value is the value of that property. Some examples of tolerance properties. A boolean tolerance: \"tolerance\" : true A integer tolerance: \"tolerance\" : 8 A string tolerance: \"tolerance\" : \"OK\" A sequence tolerance with lower and upper bounds: \"tolerance\" : [ 4 , 9 ] A sequence tolerance, the value must be contained in that sequence: \"tolerance\" : [ 4 , 9 , 78 ] A Probe tolerance: \"tolerance\" : { \"type\" : \"probe\" , \"name\" : \"should-exist\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"some/file\" } } } A regex tolerance: \"tolerance\" : { \"type\" : \"regex\" , \"pattern\" : \"[0-9]{3}\" } A jsonpath tolerance: \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"foo[*].baz\" } A jsonpath tolerance with an expected value to match: \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"foo[*].baz\" , \"expect\" : 4 } Contributions \u00b6 Contributions describe the valuable system properties an experiment targets as well as how much they contributes to it. Those properties usually refer to aspects stakeholders care about. Aggregated they offer a powerful metric about the effort and focus on building confidence across the system. Contributions are declared under the top-level contributions property as an object. Properties of that object MUST be JSON strings representing the name of a contribution. The values MUST be the weight of a given contribution and MUST be one of \"high\" , \"medium\" , \"low\" or \"none\" . The \"none\" value is not the same as a missing contribution from the contributions object. That value marks explicitly that a given contribution is not addressed by an experiment. A missing contribution means impact via this experiment is unknown for this contribution. Here is a contribution example: \"contributions\" : { \"reliability\" : \"high\" , \"security\" : \"none\" , \"scalability\" : \"medium\" } This sample tells us that the experiment contributes mainly to exploring reliability of the system and moderately to its scability. However, it is explicit here this experiment does not address security. On the other hand: \"contributions\" : { \"reliability\" : \"high\" , \"scalability\" : \"medium\" } This tells us the same about reliability and scalability but we can\u2019t presume anything about security. Method \u00b6 The Method describes the sequence of Probe and Action elements to apply. The Method is declared under method property at the top-level of the experiment. The method MUST have at least one element but this can be either a Probe or an Action . The elements MUST be applied in the order they are declared. Probe \u00b6 A Probe collects information from the system during the experiment. A Probe is a JSON object. A Probe is declared fully or reference another Probe through the ref property. When declared fully, a Probe MUST declare: a type property a name property a provider property The type property MUST be the JSON string \"probe\" . The name property is a free-form JSON string that MAY be considered as an identifier within the experiment. It MAY also declare: a secret property a configuration property a background property a controls property The secret property MUST be a JSON string referencing an identifier declared in the top-level secrets property . It is assumed that when not declared, the Probe requires no secrets. The configuration property MUST be a JSON string referencing an identifier declared in the top-level configuration property . It is assumed that when not declared, the Probe requires no configuration. The background property MUST be a JSON boolean value either true or false . It is assumed that, when that property is not declared, it is set to false . When that property is set to true it indicates the Probe MUST not block and the next Action or Probe should immediately be applied. When a Probe references another Probe in the Experiment, the Probe MUST declare a single property called ref . The ref property MUST be a JSON string which MUST be the name of a declared Probe. Controls describe out-of-band capabilities applied during the experiment\u2019s execution. Action \u00b6 An Action performs an operation against the system. An Action collects information from the system during the experiment. An Action is a JSON object. An Action is declared fully or reference another Action through the ref property. When declared fully, a Action MUST declare: a type property a name property a provider property a controls property The type property MUST be the JSON string \"action\" . The name property is a free-form JSON string that MAY be considered as an identifier within the experiment. It MAY also declare: a secret property a configuration property a background property a pauses property The secret property MUST be a JSON string referencing an identifier declared in the top-level secrets property . It is assumed that when not declared, the Action requires no secrets. The configuration property MUST be a JSON string referencing an identifier declared in the top-level configuration property . It is assumed that when not declared, the Action requires no configuration. The background property MUST be a JSON boolean value either true or false . It is assumed that, when that property is not declared, it is set to false . When that property is set to true it indicates the Action MUST not block and the next Action or Probe should immediately be applied. The pauses property MUST be a JSON object which MAY have one or the two following properties: before after In both cases, the value MUST be JSON number indicating the number of seconds to wait before continuing. The before pause MUST be performed before the Action while the after MUST be performed afterwards. When a Action references another Action in the Experiment, the Action MUST declare a single property called ref . The ref property MUST be a JSON string which MUST be the name of a declared Action. Controls describe out-of-band capabilities applied during the experiment\u2019s execution. Action or Probe Provider \u00b6 A provider MUST be a JSON object which MUST declare a type property that decides the other expected properties. The type property MUST be one of \"python\" , \"http\" or \"process\" . Info This specification only mentions those three providers but it could grow to support more , such as \"go\" , \"rust\" or \"grpc\" \u2026 Python Provider \u00b6 A Python Provider declares a Python function to be applied. A Python Provider MUST declare the following: a module property a func property It SHOULD also declare an arguments property when the function expects them. The module property is the fully qualified module exposing the function. It MUST be a JSON string. The func property is the name of the function to apply. It MUST be a JSON string. When provided, the arguments property MUST be a JSON object which properties are the names of the function\u2019s arguments . When a function\u2019s signature has default values for some of its arguments, those MAY be omitted from the arguments object. In that case, those default values will be used. Argument values MUST be valid JSON entities. HTTP Provider \u00b6 A HTTP Provider declares a URL to be called. A HTTP Provider MUST declare the following: a url property The url property MUST be a JSON string representing a URL as per RFC 3986 . In addition, the provider object MAY declare any of the followings: a method property a headers property a expected_status property a arguments property a timeout property The method property MUST be a JSON string, such as \"POST\" , as per RFC 7231 . It defaults to \"GET\" . The headers property MUST be a JSON object which properties are header names and values are header values, as per RFC 7231 . When provided, the arguments property MUST be a JSON object which properties are parameters of the HTTP request. When method is \"GET\" , the arguments are mapped as a query-string of the URL. Otherwise, the arguments are passed as the request body\u2019s data and the encoding depends on the \"Content-Type\" provided in the headers object. The timeout property MUST be either a JSON number specifying how long the request should take to complete. Or a JSON array that MUST made of two JSON numbers, the first one indicating the connection timeout, the second the request timeout to respond. The HTTP provider MUST return an object with the following properties: status which MUST be a valid HTTP returned code as defined in RFC 7231 headers which MUST be an object body which MUST be a string Process Provider \u00b6 A Process Provider declares a process to be called. A Process Provider MUST declare the following: a path property The path property MUST be a JSON string of a path to an executable. In addition, the provider object MAY declare any of the followings: a arguments property a timeout property The arguments property MUST be a JSON array which defines the process arguments. Those arguments are passed in order to the process arguments. The timeout property MUST be a JSON number specifying how long the process should take to complete. The Process provider MUST return an object with the following properties: status which MUST be a scalar of the process return code stdout which MUST be bytes sequence encoded with the UTF-8 encoding representing the stdout payload of the process stderr which MUST be bytes sequence encoded with the UTF-8 encoding representing the stderr payload of the process Rollbacks \u00b6 Rollbacks declare the sequence of actions that attempt to put the system back to its initial state. The experiment MAY declare a single rollbacks property which is a JSON array consisting of Actions . A failed rollback MUST not bail the sequence of rollbacks. Secrets \u00b6 Secrets declare values that need to be passed on to Actions or Probes in a secure manner. The secrets property MUST be a JSON object. Its properties are identifiers referenced by Actions and Probes . The value of each identifier is a JSON object which properties are the secrets keys and the properties values are the secrets values. Referenced secrets MUST be injected into probes and actions when they are applied. Probes and actions MUST NOT modify the secrets. Secrets MUST be passed a mapping of keys and values to probes and actions. An example of a secrets element at the top-level: { \"secrets\" : { \"kubernetes\" : { \"token\" : \"XYZ\" } } } This can then referenced from probes or actions: { \"type\" : \"probe\" , \"secrets\" : \"kubernetes\" } Inline Secrets \u00b6 Secrets MAY be inlined in the Experiment directly. Environment Secrets \u00b6 Secrets MAY be retrieved from the environment. In that case, they must be declared as a JSON object with a type property set to \"env\" . The environment variable MUST be declared in the key property as a JSON string. { \"secrets\" : { \"kubernetes\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"KUBERNETES_TOKEN\" } } } } Vault Secrets \u00b6 Secrets MAY be retrieved from a HashiCorp vault instance . In that case, they must be declared as a JSON object with a type property set to \"vault\" . The path to the key MUST be declared in the key property as a JSON string. { \"secrets\" : { \"myapp\" : { \"token\" : { \"type\" : \"vault\" , \"key\" : \"secrets/something\" } } } } Configuration \u00b6 Configuration is meant to provide runtime values to actions and probes . The configuration element MUST be a JSON object. The value of each property MUST be a JSON string or object which properties are considered the configuration lookup. Configuration must be passed to all Probes and actions requiring it. Probes and actions MUST NOT modify the configuration. Configurations MUST be passed a mapping of keys and values to probes and actions. An example of a configuration element at the top-level: { \"configuration\" : { \"some_service\" : \"http://127.0.0.1:8080\" , \"vault_addr\" : { \"type\" : \"env\" , \"key\" : \"VAULT_ADDR\" } } } Inline Configurations \u00b6 Configurations MAY be inlined in the Experiment directly. Environment Configurations \u00b6 Configurations MAY be retrieved from the environment. In that case, they must be declared as a JSON object with a type property set to \"env\" . The environment variable MUST be declared in the key property as a JSON string. { \"configuration\" : { \"vault_address\" : { \"type\" : \"env\" , \"key\" : \"VAULT_ADDR\" } } } Variable Substitution \u00b6 Probes and Actions argument values MAY be dynamically resolved at runtime. Dynamic values MUST follow the syntax ${name} where name is an identifier declared in either the Configuration or Secrets sections. When name is declared in both sections, the Configuration section MUST take precedence. Dynamic values MUST be substituted before being passed to Probes or Actions. Other values, such as the HTTP Probe url, MAY be substituted as well. Controls \u00b6 Controls describe out-of-band capabilities applied when the experiment is executed. Controls are used to declare operations that should be carried by external tools. Controls MAY be declared at each of the following levels: experiment steady-state-hypothesis activity Controls MUST be applied before and after each of those levels. Schematically, this looks like this: apply experiment control before experiment starts start experiment apply steady state control before steady-state probes are started start steady-state processing apply activity control before each probe is applied run each probe apply activity control after each probe is applied apply steady state control after steady-state probes have completed apply steady state control before method activities are started start method processing apply activity control before each activity is applied run each activity apply activity control after each activity is applied apply steady state control after method activities have completed apply steady state control before rollback activities are started start rollback processing apply activity control before each activity is applied run each activity apply activity control after each activity is applied apply steady state control after rollback activities have completed apply experiment control after experiment completes Controls MAY be omitted anywhere and MUST NOT be applied at a level they are not declared. Controls MUST NOT fail the experiment\u2019s execution due to unforeseen conditions. Controls are declared with the controls property which is set to a JSON array. An item of that array MUST be a control, which is a JSON object which MUST have the following properties: a name property which MUST be a JSON string a provider property MUST be a JSON object The provider object indicates which implementation of the control to use. It MUST declare the following properties: a type JSON string which MUST be \"python\" a module JSON string when the type property is \"python\" . It MUST be a a Python module dotted path implementing the control interface A control object MAY also declare the following property: a scope property MUST be a JSON string automatic , a JSON boolean which MUST be true by default (when omitted) The scope value MUST be one of \"before\" or \"after\" . When the scope property is omitted, the control MUST be applied before and after. When the scope property is set, the control MUST be applied only on that scope. When the automatic property is set to false , it MUST be understood that the control cannot be applied anywhere but where it is declared. Examples of Controls: Just a generic declaration of a control at the top-level of the experiment: \"controls\" : [ { \"name\" : \"tracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Another control by applied only as post-control: \"controls\" : [ { \"name\" : \"tracing\" , \"scope\" : \"post\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Finally, a top-level level control not applied anywhere else down the tree: \"controls\" : [ { \"name\" : \"tracing\" , \"automatic\" : false , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Extensions \u00b6 An Experiment MAY declare an extensions property which MUST be an array of objects. Each object MUST declare a non-empty name property. Extensions are used in two scenarios: future core features that need to be ironed out by the community first vendor specific payload In both cases, their actual usage is runtime dependent, this specification does not declare any meaning to an extension. Below is an example of an Extension: { \"extensions\" : [{ \"name\" : \"vendorX\" , \"data\" : \"...\" }] } Examples \u00b6 The following examples MUST NOT be considered normative. Minimal Experiment \u00b6 Here is an example of the most minimal experiment: { \"version\" : \"1.0.0\" , \"title\" : \"Moving a file from under our feet is forgivable\" , \"description\" : \"Our application should re-create a file that was removed\" , \"contributions\" : { \"reliability\" : \"high\" , \"availability\" : \"high\" }, \"steady-state-hypothesis\" : { \"title\" : \"The file must be around first\" , \"probes\" : [ { \"type\" : \"python\" , \"name\" : \"file-must-exist\" , \"tolerance\" : true , \"provider\" : { \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"some/file\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"file-be-gone\" , \"provider\" : { \"module\" : \"os.path\" , \"func\" : \"remove\" , \"arguments\" : { \"path\" : \"some/file\" } }, \"pauses\" : { \"after\" : 5 } }, { \"ref\" : \"file-must-exist\" } ] } For reference, here is the YAML equivalent (which is not official but respects the specification herein): --- version : 1.0.0 title : Moving a file from under our feet is forgivable description : Our application should re-create a file that was removed contributions : reliability : high availability : high steady-state-hypothesis : title : The file must be around first probes : - type : python name : file-must-exist tolerance : true provider : module : os.path func : exists arguments : path : some/file method : - type : action name : file-be-gone provider : module : os.path func : remove arguments : path : some/file pauses : after : 5 - ref : file-must-exist More Complex Experiment \u00b6 Below is an example of a fully featured experiment that uses various extensions to perform actions, probing and steady-state hypothesis validation. { \"version\" : \"1.0.0\" , \"title\" : \"Are our users impacted by the loss of a function?\" , \"description\" : \"While users query the Astre function, they should not be impacted if one instance goes down.\" , \"contributions\" : { \"reliability\" : \"high\" , \"availability\" : \"high\" , \"performance\" : \"medium\" , \"security\" : \"none\" }, \"tags\" : [ \"kubernetes\" , \"openfaas\" , \"cloudnative\" ], \"configuration\" : { \"prometheus_base_url\" : \"http://demo.foo.bar\" }, \"secrets\" : { \"global\" : { \"auth\" : \"Basic XYZ\" } }, \"controls\" : [ { \"name\" : \"tracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ], \"steady-state-hypothesis\" : { \"title\" : \"Function is available\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"function-must-exist\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"secrets\" : [ \"faas\" ], \"url\" : \"http://demo.foo.bar/system/function/astre\" , \"headers\" : { \"Authorization\" : \"${auth}\" } } }, { \"type\" : \"probe\" , \"name\" : \"function-must-respond\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : [ 3 , 5 ], \"secrets\" : [ \"global\" ], \"url\" : \"http://demo.foo.bar/function/astre\" , \"method\" : \"POST\" , \"headers\" : { \"Content-Type\" : \"application/json\" , \"Authorization\" : \"${auth}\" }, \"arguments\" : { \"city\" : \"Paris\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"simulate-user-traffic\" , \"background\" : true , \"provider\" : { \"type\" : \"process\" , \"path\" : \"vegeta\" , \"arguments\" : \"-cpus 2 attack -targets=data/scenario.txt -workers=2 -connections=1 -rate=3 -timeout=3s -duration=30s -output=result.bin\" } }, { \"type\" : \"action\" , \"name\" : \"terminate-one-function\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"ns\" : \"openfaas-fn\" , \"label_selector\" : \"faas_function=astre\" , \"rand\" : true } }, \"pauses\" : { \"before\" : 5 } }, { \"type\" : \"probe\" , \"name\" : \"fetch-openfaas-gateway-logs\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"read_pod_logs\" , \"arguments\" : { \"label_selector\" : \"app=gateway\" , \"last\" : \"35s\" , \"ns\" : \"openfaas\" } } }, { \"type\" : \"probe\" , \"name\" : \"query-total-function-invocation\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"secrets\" : [ \"global\" ], \"arguments\" : { \"query\" : \"gateway_function_invocation_total{function_name='astre'}\" , \"start\" : \"1 minute ago\" , \"end\" : \"now\" , \"step\" : 1 } } } ], \"rollbacks\" : [] } The equivalent YAML serialization: --- version : 1.0.0 title : Are our users impacted by the loss of a function? description : While users query the Astre function, they should not be impacted if one instance goes down. contributions : reliability : high availability : high performance : medium security : none tags : - kubernetes - openfaas - cloudnative configuration : prometheus_base_url : http://demo.foo.bar secrets : global : auth : Basic XYZ controls : - name : tracing provider : type : python module : chaostracing.control steady-state-hypothesis : title : Function is available probes : - type : probe name : function-must-exist tolerance : 200 provider : type : http secrets : - faas url : http://demo.foo.bar/system/function/astre headers : Authorization : \"${auth}\" - type : probe name : function-must-respond tolerance : 200 provider : type : http timeout : - 3 - 5 secrets : - global url : http://demo.foo.bar/function/astre method : POST headers : Content-Type : application/json Authorization : \"${auth}\" arguments : city : Paris method : - type : action name : simulate-user-traffic background : true provider : type : process path : vegeta arguments : \"-cpus 2 attack -targets=data/scenario.txt -workers=2 -connections=1 -rate=3 -timeout=3s -duration=30s -output=result.bin\" - type : action name : terminate-one-function provider : type : python module : chaosk8s.pod.actions func : terminate_pods arguments : ns : openfaas-fn label_selector : faas_function=astre rand : true pauses : before : 5 - type : probe name : fetch-openfaas-gateway-logs provider : type : python module : chaosk8s.pod.probes func : read_pod_logs arguments : label_selector : app=gateway last : 35s ns : openfaas - type : probe name : query-total-function-invocation provider : type : python module : chaosprometheus.probes func : query_interval secrets : - global arguments : query : gateway_function_invocation_total{function_name='astre'} start : 1 minute ago end : now step : 1 rollbacks : []","title":"Experiment"},{"location":"reference/api/experiment/#an-open-api-for-chaos-engineering-experiments","text":"Info The current specification has not reached its 1.0.0 stable version yet. Make sure to join the discussion to provide any feedback you might have.","title":"An Open API for Chaos Engineering Experiments"},{"location":"reference/api/experiment/#introduction","text":"The purpose of this specification is to formalize the elements of a Chaos Engineering experiment and offer a way to federate the community around a common syntax and semantic. As a fairly recent field, Chaos Engineering is a dynamic and its foundations are still emerging. However, it appears certain concepts are settling down enough to start agreeing on a shared understanding. This specification is not prescriptive and does not aim at forcing the community into one direction, rather it strives at providing a common vocabulary that new practitioners can easily make sense of. It is necessary to appreciate that this document does not specify what tools, such as the Chaos Monkey or similar, should look like. Instead, this document specifies how Chaos Engineering Experiment could be described, shared and conducted collaboratively.","title":"Introduction"},{"location":"reference/api/experiment/#conventions-used-in-this-document","text":"The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d, \u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this document are to be interpreted as defined in RFC 7159 .","title":"Conventions Used in This Document"},{"location":"reference/api/experiment/#other-formats","text":"While this specification uses JSON to define its elements, implementations may allow loading from other formats, such as YAML . As long as the output of such format respects the specification herein.","title":"Other formats"},{"location":"reference/api/experiment/#chaos-engineering-elements","text":"","title":"Chaos Engineering Elements"},{"location":"reference/api/experiment/#overview","text":"An Experiment is one possible description of the principles of the Chaos Engineering . The intention of such a description is to provide shared understanding around a hypothesis on how to discover system\u2019s behavior under certain conditions. An Experiment declares a steady state hypothesis , alongside probes to validate this steady state is met, and a method as a sequence actions and probes , to interact and query the system respectively. By using a variety of probes , experiments should gather information to sense behaviors in the system, potentially leading to systemic patterns that can be stabilized.","title":"Overview"},{"location":"reference/api/experiment/#experiment","text":"A Chaos Engineering experiment, or simply an experiment, describes both the elements and the order in which they should be applied. An experiment is a JSON object. An experiment MUST declare: a version property a title property a description property a steady-state-hypothesis property a method property The version property MUST be \"0.1.0\" . The experiment\u2019s title and description are meant for humans and therefore should be as descriptive as possible to clarify the experiment\u2019s rationale. Title and description are JSON strings with no maximum length. An experiment SHOULD also declare: a rollbacks property An experiment MAY finally declare: a tags property a secrets property an extension property a contributions property a controls property Tags provide a way of categorizing experiments. It is a sequence of JSON strings. Extensions define opaque payloads for vendors to carry valuable information. Contribution describes valuable properties of the target system, such as \u201creliability\u201d or \u201cdurability\u201d, that an experiment contribute to. This information can be aggregated together with other experiments\u2019 contributions to better appreciate where the focus is put and where it is not. Controls describe out-of-band capabilities applied during the experiment\u2019s execution.","title":"Experiment"},{"location":"reference/api/experiment/#steady-state-hypothesis","text":"The Steady State Hypothesis element describes what normal looks like in your system before the Method element is applied. If the steady state is not met, the Method element is not applied and the experiment MUST bail out. The Steady State Hypothesis element is a JSON object. Steady State Hypothesis element MUST declare: a title property a probes property The title is meant for humans and therefore should clarify the rationale for this hypothesis. Each Probe MUST define a tolerance property that acting as a gate mechanism for the experiment to carry on or bail. Any Probe that does not fall into the tolerance zone MUST fail the experiment. Steady State Hypothesis element MAY declare: a controls property Controls describe out-of-band capabilities applied during the experiment\u2019s execution.","title":"Steady State Hypothesis"},{"location":"reference/api/experiment/#steady-state-probe-tolerance","text":"Probes of the Steady State Hypothesis MUST declare an additional property named tolerance . The tolerance property\u2019s value MUST be one of: a scalar: JSON string, number (an integer), boolean a sequence of scalars: JSON string, number, boolean an object In the case of a scalar or the sequence, the tolerance validation MUST be strict. The value returned by the Probe MUST be checked against the scalar value. The experiment MUST bail when both fail to match. When the tolerance is a sequence. If it has only two values, those two values represent a lower and upper bound within which the Probe returned value must fall (inclusive). When the sequence has more than two elements, the Probe returned value must be contained in that sequence. When the tolerance is an object, it MUST have a type property which MUST be one of the followings: \"probe\" , \"regex\" or \"jsonpath\" . When the type property is \"probe\" , the object MUST be a Probe that is applied. The probe should take two arguments, value and secrets where the value is the Probe returned value and secrets a Secret object or null . Its returned status MUST be successful for the tolerance to be considered valid. When the type property is \"regex\" , the object MUST have a pattern property which MUST be a valid regular expression. The tolerance succeeds if the Probe returned value is matched against the pattern. When the type property is \"jsonpath\" , the object MUST have a path property which MUST be a valid JSON Path . In addition, the object MAY have a expect property which is used to compare each value matched by the JSON Path to that value. The expect property value MUST be a scalar. When the expect property is not present, the tolerance succeeds if the JSON Path matched at least one item. In addition, when the Probe returned value is an object with a \u0300 status property, the tested value is the value of that property. Some examples of tolerance properties. A boolean tolerance: \"tolerance\" : true A integer tolerance: \"tolerance\" : 8 A string tolerance: \"tolerance\" : \"OK\" A sequence tolerance with lower and upper bounds: \"tolerance\" : [ 4 , 9 ] A sequence tolerance, the value must be contained in that sequence: \"tolerance\" : [ 4 , 9 , 78 ] A Probe tolerance: \"tolerance\" : { \"type\" : \"probe\" , \"name\" : \"should-exist\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"some/file\" } } } A regex tolerance: \"tolerance\" : { \"type\" : \"regex\" , \"pattern\" : \"[0-9]{3}\" } A jsonpath tolerance: \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"foo[*].baz\" } A jsonpath tolerance with an expected value to match: \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"foo[*].baz\" , \"expect\" : 4 }","title":"Steady State Probe Tolerance"},{"location":"reference/api/experiment/#contributions","text":"Contributions describe the valuable system properties an experiment targets as well as how much they contributes to it. Those properties usually refer to aspects stakeholders care about. Aggregated they offer a powerful metric about the effort and focus on building confidence across the system. Contributions are declared under the top-level contributions property as an object. Properties of that object MUST be JSON strings representing the name of a contribution. The values MUST be the weight of a given contribution and MUST be one of \"high\" , \"medium\" , \"low\" or \"none\" . The \"none\" value is not the same as a missing contribution from the contributions object. That value marks explicitly that a given contribution is not addressed by an experiment. A missing contribution means impact via this experiment is unknown for this contribution. Here is a contribution example: \"contributions\" : { \"reliability\" : \"high\" , \"security\" : \"none\" , \"scalability\" : \"medium\" } This sample tells us that the experiment contributes mainly to exploring reliability of the system and moderately to its scability. However, it is explicit here this experiment does not address security. On the other hand: \"contributions\" : { \"reliability\" : \"high\" , \"scalability\" : \"medium\" } This tells us the same about reliability and scalability but we can\u2019t presume anything about security.","title":"Contributions"},{"location":"reference/api/experiment/#method","text":"The Method describes the sequence of Probe and Action elements to apply. The Method is declared under method property at the top-level of the experiment. The method MUST have at least one element but this can be either a Probe or an Action . The elements MUST be applied in the order they are declared.","title":"Method"},{"location":"reference/api/experiment/#probe","text":"A Probe collects information from the system during the experiment. A Probe is a JSON object. A Probe is declared fully or reference another Probe through the ref property. When declared fully, a Probe MUST declare: a type property a name property a provider property The type property MUST be the JSON string \"probe\" . The name property is a free-form JSON string that MAY be considered as an identifier within the experiment. It MAY also declare: a secret property a configuration property a background property a controls property The secret property MUST be a JSON string referencing an identifier declared in the top-level secrets property . It is assumed that when not declared, the Probe requires no secrets. The configuration property MUST be a JSON string referencing an identifier declared in the top-level configuration property . It is assumed that when not declared, the Probe requires no configuration. The background property MUST be a JSON boolean value either true or false . It is assumed that, when that property is not declared, it is set to false . When that property is set to true it indicates the Probe MUST not block and the next Action or Probe should immediately be applied. When a Probe references another Probe in the Experiment, the Probe MUST declare a single property called ref . The ref property MUST be a JSON string which MUST be the name of a declared Probe. Controls describe out-of-band capabilities applied during the experiment\u2019s execution.","title":"Probe"},{"location":"reference/api/experiment/#action","text":"An Action performs an operation against the system. An Action collects information from the system during the experiment. An Action is a JSON object. An Action is declared fully or reference another Action through the ref property. When declared fully, a Action MUST declare: a type property a name property a provider property a controls property The type property MUST be the JSON string \"action\" . The name property is a free-form JSON string that MAY be considered as an identifier within the experiment. It MAY also declare: a secret property a configuration property a background property a pauses property The secret property MUST be a JSON string referencing an identifier declared in the top-level secrets property . It is assumed that when not declared, the Action requires no secrets. The configuration property MUST be a JSON string referencing an identifier declared in the top-level configuration property . It is assumed that when not declared, the Action requires no configuration. The background property MUST be a JSON boolean value either true or false . It is assumed that, when that property is not declared, it is set to false . When that property is set to true it indicates the Action MUST not block and the next Action or Probe should immediately be applied. The pauses property MUST be a JSON object which MAY have one or the two following properties: before after In both cases, the value MUST be JSON number indicating the number of seconds to wait before continuing. The before pause MUST be performed before the Action while the after MUST be performed afterwards. When a Action references another Action in the Experiment, the Action MUST declare a single property called ref . The ref property MUST be a JSON string which MUST be the name of a declared Action. Controls describe out-of-band capabilities applied during the experiment\u2019s execution.","title":"Action"},{"location":"reference/api/experiment/#action-or-probe-provider","text":"A provider MUST be a JSON object which MUST declare a type property that decides the other expected properties. The type property MUST be one of \"python\" , \"http\" or \"process\" . Info This specification only mentions those three providers but it could grow to support more , such as \"go\" , \"rust\" or \"grpc\" \u2026","title":"Action or Probe Provider"},{"location":"reference/api/experiment/#python-provider","text":"A Python Provider declares a Python function to be applied. A Python Provider MUST declare the following: a module property a func property It SHOULD also declare an arguments property when the function expects them. The module property is the fully qualified module exposing the function. It MUST be a JSON string. The func property is the name of the function to apply. It MUST be a JSON string. When provided, the arguments property MUST be a JSON object which properties are the names of the function\u2019s arguments . When a function\u2019s signature has default values for some of its arguments, those MAY be omitted from the arguments object. In that case, those default values will be used. Argument values MUST be valid JSON entities.","title":"Python Provider"},{"location":"reference/api/experiment/#http-provider","text":"A HTTP Provider declares a URL to be called. A HTTP Provider MUST declare the following: a url property The url property MUST be a JSON string representing a URL as per RFC 3986 . In addition, the provider object MAY declare any of the followings: a method property a headers property a expected_status property a arguments property a timeout property The method property MUST be a JSON string, such as \"POST\" , as per RFC 7231 . It defaults to \"GET\" . The headers property MUST be a JSON object which properties are header names and values are header values, as per RFC 7231 . When provided, the arguments property MUST be a JSON object which properties are parameters of the HTTP request. When method is \"GET\" , the arguments are mapped as a query-string of the URL. Otherwise, the arguments are passed as the request body\u2019s data and the encoding depends on the \"Content-Type\" provided in the headers object. The timeout property MUST be either a JSON number specifying how long the request should take to complete. Or a JSON array that MUST made of two JSON numbers, the first one indicating the connection timeout, the second the request timeout to respond. The HTTP provider MUST return an object with the following properties: status which MUST be a valid HTTP returned code as defined in RFC 7231 headers which MUST be an object body which MUST be a string","title":"HTTP Provider"},{"location":"reference/api/experiment/#process-provider","text":"A Process Provider declares a process to be called. A Process Provider MUST declare the following: a path property The path property MUST be a JSON string of a path to an executable. In addition, the provider object MAY declare any of the followings: a arguments property a timeout property The arguments property MUST be a JSON array which defines the process arguments. Those arguments are passed in order to the process arguments. The timeout property MUST be a JSON number specifying how long the process should take to complete. The Process provider MUST return an object with the following properties: status which MUST be a scalar of the process return code stdout which MUST be bytes sequence encoded with the UTF-8 encoding representing the stdout payload of the process stderr which MUST be bytes sequence encoded with the UTF-8 encoding representing the stderr payload of the process","title":"Process Provider"},{"location":"reference/api/experiment/#rollbacks","text":"Rollbacks declare the sequence of actions that attempt to put the system back to its initial state. The experiment MAY declare a single rollbacks property which is a JSON array consisting of Actions . A failed rollback MUST not bail the sequence of rollbacks.","title":"Rollbacks"},{"location":"reference/api/experiment/#secrets","text":"Secrets declare values that need to be passed on to Actions or Probes in a secure manner. The secrets property MUST be a JSON object. Its properties are identifiers referenced by Actions and Probes . The value of each identifier is a JSON object which properties are the secrets keys and the properties values are the secrets values. Referenced secrets MUST be injected into probes and actions when they are applied. Probes and actions MUST NOT modify the secrets. Secrets MUST be passed a mapping of keys and values to probes and actions. An example of a secrets element at the top-level: { \"secrets\" : { \"kubernetes\" : { \"token\" : \"XYZ\" } } } This can then referenced from probes or actions: { \"type\" : \"probe\" , \"secrets\" : \"kubernetes\" }","title":"Secrets"},{"location":"reference/api/experiment/#inline-secrets","text":"Secrets MAY be inlined in the Experiment directly.","title":"Inline Secrets"},{"location":"reference/api/experiment/#environment-secrets","text":"Secrets MAY be retrieved from the environment. In that case, they must be declared as a JSON object with a type property set to \"env\" . The environment variable MUST be declared in the key property as a JSON string. { \"secrets\" : { \"kubernetes\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"KUBERNETES_TOKEN\" } } } }","title":"Environment Secrets"},{"location":"reference/api/experiment/#vault-secrets","text":"Secrets MAY be retrieved from a HashiCorp vault instance . In that case, they must be declared as a JSON object with a type property set to \"vault\" . The path to the key MUST be declared in the key property as a JSON string. { \"secrets\" : { \"myapp\" : { \"token\" : { \"type\" : \"vault\" , \"key\" : \"secrets/something\" } } } }","title":"Vault Secrets"},{"location":"reference/api/experiment/#configuration","text":"Configuration is meant to provide runtime values to actions and probes . The configuration element MUST be a JSON object. The value of each property MUST be a JSON string or object which properties are considered the configuration lookup. Configuration must be passed to all Probes and actions requiring it. Probes and actions MUST NOT modify the configuration. Configurations MUST be passed a mapping of keys and values to probes and actions. An example of a configuration element at the top-level: { \"configuration\" : { \"some_service\" : \"http://127.0.0.1:8080\" , \"vault_addr\" : { \"type\" : \"env\" , \"key\" : \"VAULT_ADDR\" } } }","title":"Configuration"},{"location":"reference/api/experiment/#inline-configurations","text":"Configurations MAY be inlined in the Experiment directly.","title":"Inline Configurations"},{"location":"reference/api/experiment/#environment-configurations","text":"Configurations MAY be retrieved from the environment. In that case, they must be declared as a JSON object with a type property set to \"env\" . The environment variable MUST be declared in the key property as a JSON string. { \"configuration\" : { \"vault_address\" : { \"type\" : \"env\" , \"key\" : \"VAULT_ADDR\" } } }","title":"Environment Configurations"},{"location":"reference/api/experiment/#variable-substitution","text":"Probes and Actions argument values MAY be dynamically resolved at runtime. Dynamic values MUST follow the syntax ${name} where name is an identifier declared in either the Configuration or Secrets sections. When name is declared in both sections, the Configuration section MUST take precedence. Dynamic values MUST be substituted before being passed to Probes or Actions. Other values, such as the HTTP Probe url, MAY be substituted as well.","title":"Variable Substitution"},{"location":"reference/api/experiment/#controls","text":"Controls describe out-of-band capabilities applied when the experiment is executed. Controls are used to declare operations that should be carried by external tools. Controls MAY be declared at each of the following levels: experiment steady-state-hypothesis activity Controls MUST be applied before and after each of those levels. Schematically, this looks like this: apply experiment control before experiment starts start experiment apply steady state control before steady-state probes are started start steady-state processing apply activity control before each probe is applied run each probe apply activity control after each probe is applied apply steady state control after steady-state probes have completed apply steady state control before method activities are started start method processing apply activity control before each activity is applied run each activity apply activity control after each activity is applied apply steady state control after method activities have completed apply steady state control before rollback activities are started start rollback processing apply activity control before each activity is applied run each activity apply activity control after each activity is applied apply steady state control after rollback activities have completed apply experiment control after experiment completes Controls MAY be omitted anywhere and MUST NOT be applied at a level they are not declared. Controls MUST NOT fail the experiment\u2019s execution due to unforeseen conditions. Controls are declared with the controls property which is set to a JSON array. An item of that array MUST be a control, which is a JSON object which MUST have the following properties: a name property which MUST be a JSON string a provider property MUST be a JSON object The provider object indicates which implementation of the control to use. It MUST declare the following properties: a type JSON string which MUST be \"python\" a module JSON string when the type property is \"python\" . It MUST be a a Python module dotted path implementing the control interface A control object MAY also declare the following property: a scope property MUST be a JSON string automatic , a JSON boolean which MUST be true by default (when omitted) The scope value MUST be one of \"before\" or \"after\" . When the scope property is omitted, the control MUST be applied before and after. When the scope property is set, the control MUST be applied only on that scope. When the automatic property is set to false , it MUST be understood that the control cannot be applied anywhere but where it is declared. Examples of Controls: Just a generic declaration of a control at the top-level of the experiment: \"controls\" : [ { \"name\" : \"tracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Another control by applied only as post-control: \"controls\" : [ { \"name\" : \"tracing\" , \"scope\" : \"post\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Finally, a top-level level control not applied anywhere else down the tree: \"controls\" : [ { \"name\" : \"tracing\" , \"automatic\" : false , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ]","title":"Controls"},{"location":"reference/api/experiment/#extensions","text":"An Experiment MAY declare an extensions property which MUST be an array of objects. Each object MUST declare a non-empty name property. Extensions are used in two scenarios: future core features that need to be ironed out by the community first vendor specific payload In both cases, their actual usage is runtime dependent, this specification does not declare any meaning to an extension. Below is an example of an Extension: { \"extensions\" : [{ \"name\" : \"vendorX\" , \"data\" : \"...\" }] }","title":"Extensions"},{"location":"reference/api/experiment/#examples","text":"The following examples MUST NOT be considered normative.","title":"Examples"},{"location":"reference/api/experiment/#minimal-experiment","text":"Here is an example of the most minimal experiment: { \"version\" : \"1.0.0\" , \"title\" : \"Moving a file from under our feet is forgivable\" , \"description\" : \"Our application should re-create a file that was removed\" , \"contributions\" : { \"reliability\" : \"high\" , \"availability\" : \"high\" }, \"steady-state-hypothesis\" : { \"title\" : \"The file must be around first\" , \"probes\" : [ { \"type\" : \"python\" , \"name\" : \"file-must-exist\" , \"tolerance\" : true , \"provider\" : { \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"some/file\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"file-be-gone\" , \"provider\" : { \"module\" : \"os.path\" , \"func\" : \"remove\" , \"arguments\" : { \"path\" : \"some/file\" } }, \"pauses\" : { \"after\" : 5 } }, { \"ref\" : \"file-must-exist\" } ] } For reference, here is the YAML equivalent (which is not official but respects the specification herein): --- version : 1.0.0 title : Moving a file from under our feet is forgivable description : Our application should re-create a file that was removed contributions : reliability : high availability : high steady-state-hypothesis : title : The file must be around first probes : - type : python name : file-must-exist tolerance : true provider : module : os.path func : exists arguments : path : some/file method : - type : action name : file-be-gone provider : module : os.path func : remove arguments : path : some/file pauses : after : 5 - ref : file-must-exist","title":"Minimal Experiment"},{"location":"reference/api/experiment/#more-complex-experiment","text":"Below is an example of a fully featured experiment that uses various extensions to perform actions, probing and steady-state hypothesis validation. { \"version\" : \"1.0.0\" , \"title\" : \"Are our users impacted by the loss of a function?\" , \"description\" : \"While users query the Astre function, they should not be impacted if one instance goes down.\" , \"contributions\" : { \"reliability\" : \"high\" , \"availability\" : \"high\" , \"performance\" : \"medium\" , \"security\" : \"none\" }, \"tags\" : [ \"kubernetes\" , \"openfaas\" , \"cloudnative\" ], \"configuration\" : { \"prometheus_base_url\" : \"http://demo.foo.bar\" }, \"secrets\" : { \"global\" : { \"auth\" : \"Basic XYZ\" } }, \"controls\" : [ { \"name\" : \"tracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ], \"steady-state-hypothesis\" : { \"title\" : \"Function is available\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"function-must-exist\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"secrets\" : [ \"faas\" ], \"url\" : \"http://demo.foo.bar/system/function/astre\" , \"headers\" : { \"Authorization\" : \"${auth}\" } } }, { \"type\" : \"probe\" , \"name\" : \"function-must-respond\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : [ 3 , 5 ], \"secrets\" : [ \"global\" ], \"url\" : \"http://demo.foo.bar/function/astre\" , \"method\" : \"POST\" , \"headers\" : { \"Content-Type\" : \"application/json\" , \"Authorization\" : \"${auth}\" }, \"arguments\" : { \"city\" : \"Paris\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"simulate-user-traffic\" , \"background\" : true , \"provider\" : { \"type\" : \"process\" , \"path\" : \"vegeta\" , \"arguments\" : \"-cpus 2 attack -targets=data/scenario.txt -workers=2 -connections=1 -rate=3 -timeout=3s -duration=30s -output=result.bin\" } }, { \"type\" : \"action\" , \"name\" : \"terminate-one-function\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"ns\" : \"openfaas-fn\" , \"label_selector\" : \"faas_function=astre\" , \"rand\" : true } }, \"pauses\" : { \"before\" : 5 } }, { \"type\" : \"probe\" , \"name\" : \"fetch-openfaas-gateway-logs\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"read_pod_logs\" , \"arguments\" : { \"label_selector\" : \"app=gateway\" , \"last\" : \"35s\" , \"ns\" : \"openfaas\" } } }, { \"type\" : \"probe\" , \"name\" : \"query-total-function-invocation\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"secrets\" : [ \"global\" ], \"arguments\" : { \"query\" : \"gateway_function_invocation_total{function_name='astre'}\" , \"start\" : \"1 minute ago\" , \"end\" : \"now\" , \"step\" : 1 } } } ], \"rollbacks\" : [] } The equivalent YAML serialization: --- version : 1.0.0 title : Are our users impacted by the loss of a function? description : While users query the Astre function, they should not be impacted if one instance goes down. contributions : reliability : high availability : high performance : medium security : none tags : - kubernetes - openfaas - cloudnative configuration : prometheus_base_url : http://demo.foo.bar secrets : global : auth : Basic XYZ controls : - name : tracing provider : type : python module : chaostracing.control steady-state-hypothesis : title : Function is available probes : - type : probe name : function-must-exist tolerance : 200 provider : type : http secrets : - faas url : http://demo.foo.bar/system/function/astre headers : Authorization : \"${auth}\" - type : probe name : function-must-respond tolerance : 200 provider : type : http timeout : - 3 - 5 secrets : - global url : http://demo.foo.bar/function/astre method : POST headers : Content-Type : application/json Authorization : \"${auth}\" arguments : city : Paris method : - type : action name : simulate-user-traffic background : true provider : type : process path : vegeta arguments : \"-cpus 2 attack -targets=data/scenario.txt -workers=2 -connections=1 -rate=3 -timeout=3s -duration=30s -output=result.bin\" - type : action name : terminate-one-function provider : type : python module : chaosk8s.pod.actions func : terminate_pods arguments : ns : openfaas-fn label_selector : faas_function=astre rand : true pauses : before : 5 - type : probe name : fetch-openfaas-gateway-logs provider : type : python module : chaosk8s.pod.probes func : read_pod_logs arguments : label_selector : app=gateway last : 35s ns : openfaas - type : probe name : query-total-function-invocation provider : type : python module : chaosprometheus.probes func : query_interval secrets : - global arguments : query : gateway_function_invocation_total{function_name='astre'} start : 1 minute ago end : now step : 1 rollbacks : []","title":"More Complex Experiment"},{"location":"reference/api/journal/","text":"Experiment Journal \u00b6 Introduction \u00b6 This document describes the syntax and grammar of a Chaos Engineering experiment\u2019s output, called a journal. One should be able to walkthrough the experiment\u2019s run through its journal alone. This specification makes sense in regards to the Experiment specification itself. It is indeed a mirror to that document. Conventions Used in This Document \u00b6 The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d, \u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this document are to be interpreted as defined in RFC 7159 . Other formats \u00b6 While this specification uses JSON to define its elements, implementations may allow loading from other formats, such as YAML . As long as the output of such format respects the specification herein. Journal Elements \u00b6 Overview \u00b6 A Journal is one potential output of a Chaos Engineering experiment . The objective of such journal is to collect all events that took place during the experiment\u2019s run. The journal contains static information, such as the experiment that was run, as well as runtime entries. Format \u00b6 A journal is a JSON object. Required Properties \u00b6 A journal MUST declare: a experiment property a status property a start property a end property a duration property a deviated property The experiment property MUST be a copy of the run experiment as-is and is therefore a JSON object. It MUST follow the Experiment definition. The \u0300 status property MUST be a JSON string, one of: \"completed\" : when the experiment runs fully. It does not indicate the activities in the experiment succeeded, only that they were executed as expected \"failed\" : when one of the activity reports a failed condition \"aborted\" : when the experiment breaks for unforeseen reason \"interrupted\" : when the experiment is interrupted (for instance after a signal is received) Note It is important to understand the \"completed\" status expresses that everything ran all the way. An action may not have resulted in what the operator wanted but it did not fail. Always review the entire journal to fully appreciate the actual outcome of the experiment. There are two reasons it could be marked as \"failed\" . Either a tolerance failed or if an extension made a check for a condition. So, for instance, let\u2019s say the extension made a HTTP call to your service, that call returned a 400 rather than 200. If the extension was not designed to care for this difference, then the status will be marked as \"completed\" . However, if the extension validated the HTTP response, it may have decided to fail the action which would lead to a \u0300 \u201cfailed\u201d` status. The \"aborted\" and \"interrupted\" are different, the former means of a crash somehow (say, because of a bug). The latter indicates a signal was received. Both MUST bail the entire process. The deviated property MUST be a boolean flag that MUST be set to true when the steady-state was executed after the experimental method but reported that, at least, one of its probes failed to match the expected tolerance. The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. Recommended Properties \u00b6 In addition to those required properties, the journal SHOULD also declare the followings: a steady_states property a run property a rollbacks property The steady_states property MUST be a JSON object defining the result of the steady state hypothesis outcome. The run property MUST be a JSON array defining the result of each activity in the method element of the experiment. The rollbacks property MUST be a JSON array defining the result of each action in the rollbacks element of the experiment. Optional Properties \u00b6 In addition to those required properties, the journal MAY also declare the followings: a platform property a node property The platform property MUST be a JSON string defining the machine on which the experiment was executed. The content is free form but may be similar to the output of the uname -a command. The node property MUST be a JSON string representing the name of the machine where the experiment was run. The content is free form. Steady State \u00b6 The steady_states property holds the outcomes of the steady state hypothesis. The steady_states property MAY declare the following properties: a before property a after property The before property MUST be a JSON object describing the outcome of the hypothesis run before the method is executed. The after property MUST be a JSON object describing the outcome of the hypothesis run after the method is executed. Notice that either of those properties MAY be missing if they were not run. Steady State Outcomes \u00b6 Both the before and after properties follow the same definition. a steady_state_met property a probes property The steady_state_met property MUST be a JSON boolean. It MUST be true if the steady state hypothesis was met, false otherwise. A steady state is met when all its probes matched their tolerance. A steady state is not met at the first non-matching tolerance probe. The probes property MUST be a JSON array of probes results. Each probe result MUST declare the following properties: a activity property a status property a start property a end property a duration property a tolerance_met property a output property The activity property MUST be a JSON object, a raw copy of the executed probe . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The tolerance_met MUST be a JSON boolean indicating if the probe matched its tolerance or not. The output MUST be a JSON string or null . In addition, the probe result MAY contain an additional property: a exception property This property is set when the probe failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace. Run \u00b6 The run property holds the outcomes of the method element. The run property MUST be a JSON array of activity results. Each activity result MUST declare the following properties: a activity property a status property a start property a end property a duration property a output property The activity property MUST be a JSON object, a raw copy of the executed probe or action . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The output MUST be a JSON string or null . In addition, the activity result MAY contain an additional property: a exception property This property is set when the activity failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace. Rollbacks \u00b6 The rollbacks property holds the outcomes of the rollbacks element. The rollbacks property MUST be a JSON array of action results. Each action result MUST declare the following properties: a activity property a status property a start property a end property a duration property a output property The activity property MUST be a JSON object, a raw copy of the executed action . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The output MUST be a JSON string or null . In addition, the activity result MAY contain an additional property: a exception property This property is set when the action failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace. Rollbacks MUST NOT to be applied when the experiment status is \"interrupted\" .","title":"Journal"},{"location":"reference/api/journal/#experiment-journal","text":"","title":"Experiment Journal"},{"location":"reference/api/journal/#introduction","text":"This document describes the syntax and grammar of a Chaos Engineering experiment\u2019s output, called a journal. One should be able to walkthrough the experiment\u2019s run through its journal alone. This specification makes sense in regards to the Experiment specification itself. It is indeed a mirror to that document.","title":"Introduction"},{"location":"reference/api/journal/#conventions-used-in-this-document","text":"The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d, \u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this document are to be interpreted as defined in RFC 7159 .","title":"Conventions Used in This Document"},{"location":"reference/api/journal/#other-formats","text":"While this specification uses JSON to define its elements, implementations may allow loading from other formats, such as YAML . As long as the output of such format respects the specification herein.","title":"Other formats"},{"location":"reference/api/journal/#journal-elements","text":"","title":"Journal Elements"},{"location":"reference/api/journal/#overview","text":"A Journal is one potential output of a Chaos Engineering experiment . The objective of such journal is to collect all events that took place during the experiment\u2019s run. The journal contains static information, such as the experiment that was run, as well as runtime entries.","title":"Overview"},{"location":"reference/api/journal/#format","text":"A journal is a JSON object.","title":"Format"},{"location":"reference/api/journal/#required-properties","text":"A journal MUST declare: a experiment property a status property a start property a end property a duration property a deviated property The experiment property MUST be a copy of the run experiment as-is and is therefore a JSON object. It MUST follow the Experiment definition. The \u0300 status property MUST be a JSON string, one of: \"completed\" : when the experiment runs fully. It does not indicate the activities in the experiment succeeded, only that they were executed as expected \"failed\" : when one of the activity reports a failed condition \"aborted\" : when the experiment breaks for unforeseen reason \"interrupted\" : when the experiment is interrupted (for instance after a signal is received) Note It is important to understand the \"completed\" status expresses that everything ran all the way. An action may not have resulted in what the operator wanted but it did not fail. Always review the entire journal to fully appreciate the actual outcome of the experiment. There are two reasons it could be marked as \"failed\" . Either a tolerance failed or if an extension made a check for a condition. So, for instance, let\u2019s say the extension made a HTTP call to your service, that call returned a 400 rather than 200. If the extension was not designed to care for this difference, then the status will be marked as \"completed\" . However, if the extension validated the HTTP response, it may have decided to fail the action which would lead to a \u0300 \u201cfailed\u201d` status. The \"aborted\" and \"interrupted\" are different, the former means of a crash somehow (say, because of a bug). The latter indicates a signal was received. Both MUST bail the entire process. The deviated property MUST be a boolean flag that MUST be set to true when the steady-state was executed after the experimental method but reported that, at least, one of its probes failed to match the expected tolerance. The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime.","title":"Required Properties"},{"location":"reference/api/journal/#recommended-properties","text":"In addition to those required properties, the journal SHOULD also declare the followings: a steady_states property a run property a rollbacks property The steady_states property MUST be a JSON object defining the result of the steady state hypothesis outcome. The run property MUST be a JSON array defining the result of each activity in the method element of the experiment. The rollbacks property MUST be a JSON array defining the result of each action in the rollbacks element of the experiment.","title":"Recommended Properties"},{"location":"reference/api/journal/#optional-properties","text":"In addition to those required properties, the journal MAY also declare the followings: a platform property a node property The platform property MUST be a JSON string defining the machine on which the experiment was executed. The content is free form but may be similar to the output of the uname -a command. The node property MUST be a JSON string representing the name of the machine where the experiment was run. The content is free form.","title":"Optional Properties"},{"location":"reference/api/journal/#steady-state","text":"The steady_states property holds the outcomes of the steady state hypothesis. The steady_states property MAY declare the following properties: a before property a after property The before property MUST be a JSON object describing the outcome of the hypothesis run before the method is executed. The after property MUST be a JSON object describing the outcome of the hypothesis run after the method is executed. Notice that either of those properties MAY be missing if they were not run.","title":"Steady State"},{"location":"reference/api/journal/#steady-state-outcomes","text":"Both the before and after properties follow the same definition. a steady_state_met property a probes property The steady_state_met property MUST be a JSON boolean. It MUST be true if the steady state hypothesis was met, false otherwise. A steady state is met when all its probes matched their tolerance. A steady state is not met at the first non-matching tolerance probe. The probes property MUST be a JSON array of probes results. Each probe result MUST declare the following properties: a activity property a status property a start property a end property a duration property a tolerance_met property a output property The activity property MUST be a JSON object, a raw copy of the executed probe . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The tolerance_met MUST be a JSON boolean indicating if the probe matched its tolerance or not. The output MUST be a JSON string or null . In addition, the probe result MAY contain an additional property: a exception property This property is set when the probe failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace.","title":"Steady State Outcomes"},{"location":"reference/api/journal/#run","text":"The run property holds the outcomes of the method element. The run property MUST be a JSON array of activity results. Each activity result MUST declare the following properties: a activity property a status property a start property a end property a duration property a output property The activity property MUST be a JSON object, a raw copy of the executed probe or action . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The output MUST be a JSON string or null . In addition, the activity result MAY contain an additional property: a exception property This property is set when the activity failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace.","title":"Run"},{"location":"reference/api/journal/#rollbacks","text":"The rollbacks property holds the outcomes of the rollbacks element. The rollbacks property MUST be a JSON array of action results. Each action result MUST declare the following properties: a activity property a status property a start property a end property a duration property a output property The activity property MUST be a JSON object, a raw copy of the executed action . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The output MUST be a JSON string or null . In addition, the activity result MAY contain an additional property: a exception property This property is set when the action failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace. Rollbacks MUST NOT to be applied when the experiment status is \"interrupted\" .","title":"Rollbacks"},{"location":"reference/developing/core/","text":"Core Projects \u00b6 The Chaos Toolkit is made of several projects that work together to provide its service. chaostoolkit \u00b6 The chaostoolkit project is the command-line interface (CLI), in other words the command executed by users to run their experiments. That project tries to remain as shallow as possible, only providing the user interface commands by gluing other projects together. This project is implemented in Python 3. chaostoolkit-lib \u00b6 The chaostoolkit-lib project is the core library which implements the core concepts of the Chaos Toolkit. This project is implemented in Python 3. chaostoolkit-documentation \u00b6 The chaostoolkit-documehtation is the documentation source and renderer of the Chaos Toolkit. Namely, that project generates the website you are currently reading. This project is implemented in Python 3 by generating HTML from Markdown documents.","title":"Core Projects"},{"location":"reference/developing/core/#core-projects","text":"The Chaos Toolkit is made of several projects that work together to provide its service.","title":"Core Projects"},{"location":"reference/developing/core/#chaostoolkit","text":"The chaostoolkit project is the command-line interface (CLI), in other words the command executed by users to run their experiments. That project tries to remain as shallow as possible, only providing the user interface commands by gluing other projects together. This project is implemented in Python 3.","title":"chaostoolkit"},{"location":"reference/developing/core/#chaostoolkit-lib","text":"The chaostoolkit-lib project is the core library which implements the core concepts of the Chaos Toolkit. This project is implemented in Python 3.","title":"chaostoolkit-lib"},{"location":"reference/developing/core/#chaostoolkit-documentation","text":"The chaostoolkit-documehtation is the documentation source and renderer of the Chaos Toolkit. Namely, that project generates the website you are currently reading. This project is implemented in Python 3 by generating HTML from Markdown documents.","title":"chaostoolkit-documentation"},{"location":"reference/developing/extensions/","text":"Extension Projects \u00b6 In addition to the core projects, the Chaos Toolkit manages some extension projects which provide probes and/or actions for experiments. Official Extensions \u00b6 chaostoolkit-kubernetes \u00b6 The chaostoolkit-kubernetes project implements probes and actions for experiments targetting a Kubernetes cluster. Those activities are implemented as Python functions. This project is implemented in Python 3. Incubating Extensions \u00b6 These extensions are under work and not mature yet to be part of the core of the Chaos Toolkit. chaostoolkit-gremlin \u00b6 The chaostoolkit-gremlin project implements actions for experiments exploring resource failures (CPU, Memory, Network\u2026) in their system through the Gremlin, Inc. services. Those activities are implemented as Python functions talking to the Gremlin API . This project is implemented in Python 3. chaostoolkit-prometheus \u00b6 The chaostoolkit-prometheus project implements probes to fetch information from your system through Prometheus . Those probes are implemented as Python functions talking to the Prometheus API . This project is implemented in Python 3. chaostoolkit-aws \u00b6 The chaostoolkit-aws project implements actions and probes for experiments exploring chaos engineering against your AWS environment. Those activities are implemented as Python functions talking to the AWS API . This project is implemented in Python 3. chaostoolkit-cloud-foundry \u00b6 The chaostoolkit-cloud-foundry project implements actions and probes for experiments exploring chaos engineering against your Cloud Foundry environment. Those activities are implemented as Python functions talking to the Cloud Foundry API . This project is implemented in Python 3. chaostoolkit-slack \u00b6 The chaostoolkit-slack project implements the notification interface to push Chaos Toolkit events to Slack channels. This project is implemented in Python 3.","title":"Extension Projects"},{"location":"reference/developing/extensions/#extension-projects","text":"In addition to the core projects, the Chaos Toolkit manages some extension projects which provide probes and/or actions for experiments.","title":"Extension Projects"},{"location":"reference/developing/extensions/#official-extensions","text":"","title":"Official Extensions"},{"location":"reference/developing/extensions/#chaostoolkit-kubernetes","text":"The chaostoolkit-kubernetes project implements probes and actions for experiments targetting a Kubernetes cluster. Those activities are implemented as Python functions. This project is implemented in Python 3.","title":"chaostoolkit-kubernetes"},{"location":"reference/developing/extensions/#incubating-extensions","text":"These extensions are under work and not mature yet to be part of the core of the Chaos Toolkit.","title":"Incubating Extensions"},{"location":"reference/developing/extensions/#chaostoolkit-gremlin","text":"The chaostoolkit-gremlin project implements actions for experiments exploring resource failures (CPU, Memory, Network\u2026) in their system through the Gremlin, Inc. services. Those activities are implemented as Python functions talking to the Gremlin API . This project is implemented in Python 3.","title":"chaostoolkit-gremlin"},{"location":"reference/developing/extensions/#chaostoolkit-prometheus","text":"The chaostoolkit-prometheus project implements probes to fetch information from your system through Prometheus . Those probes are implemented as Python functions talking to the Prometheus API . This project is implemented in Python 3.","title":"chaostoolkit-prometheus"},{"location":"reference/developing/extensions/#chaostoolkit-aws","text":"The chaostoolkit-aws project implements actions and probes for experiments exploring chaos engineering against your AWS environment. Those activities are implemented as Python functions talking to the AWS API . This project is implemented in Python 3.","title":"chaostoolkit-aws"},{"location":"reference/developing/extensions/#chaostoolkit-cloud-foundry","text":"The chaostoolkit-cloud-foundry project implements actions and probes for experiments exploring chaos engineering against your Cloud Foundry environment. Those activities are implemented as Python functions talking to the Cloud Foundry API . This project is implemented in Python 3.","title":"chaostoolkit-cloud-foundry"},{"location":"reference/developing/extensions/#chaostoolkit-slack","text":"The chaostoolkit-slack project implements the notification interface to push Chaos Toolkit events to Slack channels. This project is implemented in Python 3.","title":"chaostoolkit-slack"},{"location":"reference/developing/guidelines/","text":"Developer Guidelines \u00b6 Contributors to the Chaos Toolkit are always welcome. This guide describes the general elements you probably need to know to get started. Once past those elements, you should dive into the code of each project and come discuss on our Slack . Overview \u00b6 Programming Environment \u00b6 The programming environment really is up to you. However, since the Chaos Toolkit is implemented in Python so make sure to have the right tooling for it. The most basics are: Python 3.5+ installed. Right now, we officially support 3.5 and 3.6 but there should not be harm in using 3.7 as long as it can gracefully degrade down to 3.5 A virtual environment so you can deploy the dependencies in a specific environment If you\u2019re not familiar with Python, you will find a few helpful books online, such The Hitchhiker\u2019s Guide to Python . The Ultimate Trick \u00b6 Whenever you code on one of the projects, you should run the following command so that the project you are hacking on is part of your virtual environment without being installed: (chaostk) $ cd <project-name> (chaostk) $ python setup.py develop Sometimes, your virtual env may be borked and not point to your development directory. In that case, make sure to remove any previously installed version of the project: (chaostk) $ pip uninstall <project-name> Then make sure your virtual environment point at your local directory with: (chaostk) $ pip freeze GitHub \u00b6 The Chaos Toolkit projects are hosted on GitHub . If you wish to contribute , you will need to have an account there. The general workflow is to fork the project you wish to contribute to, make your changes in a dedicated branch, rebase against the original master and finally submit a pull-request to the project with a clear description of the what and why. Chaos Toolkit Projects At A Glance \u00b6 The Chaos Toolkit is made of several projects. The core ones are: chaostoolkit : the CLI chaostoolkit-lib : the core library that propels the CLI Basically, those projects represent the Chaos Toolkit itself. However, the toolkit is naked without extensions. The currently core extensions are: chaostoolkit-kubernetes In addition, there are a bunch of incubating projects . Creating an Extension \u00b6 Please review the various approaches to extend the toolkit. Creating a Notification Plugin \u00b6 The Chaos Toolkit triggers events while it runs. Those events may be forwarded to any endpoint that you care for through HTTP or, when you need more control, a full Python project. There is no template for such a project yet but it is very close to an extension project except it doesn\u2019t have probes and actions. You can therefore start by cloning the extension template project and start from there. Instead, it should define a function in a module. That function takes two parameters: the notification channel settings (coming from the Chaos Toolkit settings file ) as a dictionary the event payload as a Python dictionary which is documented here The event has a payload key which is the content associated to the event. It can be one of: None when there was no payload () a string an experiment dictionary an journal dictionary Three kind of events can be triggered: started , completed and failed for each phase of the flow. Those events are defined here . A typical notification callback function will look like this: from typing import Any , Dict from chaoslib.notification import RunFlowEvent from chaoslib.types import EventPayload import logzero def notify ( settings : Dict [ str , Any ], event : EventPayload ): if event [ \"name\" ] == RunFlowEvent . RunStarted . value : logzero . info ( \"Event phase \" + event [ \"phase\" ]) logzero . info ( \"Event timestamp \" + event [ \"ts\" ]) logzero . info ( \"Event payload \" + event [ \"payload\" ]) logzero . info ( \"Event error \" + event . get ( \"error\" , \"N/A\" )) logzero is a third-party package that the Chaos Toolkit uses to log when it runs.","title":"Guidelines"},{"location":"reference/developing/guidelines/#developer-guidelines","text":"Contributors to the Chaos Toolkit are always welcome. This guide describes the general elements you probably need to know to get started. Once past those elements, you should dive into the code of each project and come discuss on our Slack .","title":"Developer Guidelines"},{"location":"reference/developing/guidelines/#overview","text":"","title":"Overview"},{"location":"reference/developing/guidelines/#programming-environment","text":"The programming environment really is up to you. However, since the Chaos Toolkit is implemented in Python so make sure to have the right tooling for it. The most basics are: Python 3.5+ installed. Right now, we officially support 3.5 and 3.6 but there should not be harm in using 3.7 as long as it can gracefully degrade down to 3.5 A virtual environment so you can deploy the dependencies in a specific environment If you\u2019re not familiar with Python, you will find a few helpful books online, such The Hitchhiker\u2019s Guide to Python .","title":"Programming Environment"},{"location":"reference/developing/guidelines/#the-ultimate-trick","text":"Whenever you code on one of the projects, you should run the following command so that the project you are hacking on is part of your virtual environment without being installed: (chaostk) $ cd <project-name> (chaostk) $ python setup.py develop Sometimes, your virtual env may be borked and not point to your development directory. In that case, make sure to remove any previously installed version of the project: (chaostk) $ pip uninstall <project-name> Then make sure your virtual environment point at your local directory with: (chaostk) $ pip freeze","title":"The Ultimate Trick"},{"location":"reference/developing/guidelines/#github","text":"The Chaos Toolkit projects are hosted on GitHub . If you wish to contribute , you will need to have an account there. The general workflow is to fork the project you wish to contribute to, make your changes in a dedicated branch, rebase against the original master and finally submit a pull-request to the project with a clear description of the what and why.","title":"GitHub"},{"location":"reference/developing/guidelines/#chaos-toolkit-projects-at-a-glance","text":"The Chaos Toolkit is made of several projects. The core ones are: chaostoolkit : the CLI chaostoolkit-lib : the core library that propels the CLI Basically, those projects represent the Chaos Toolkit itself. However, the toolkit is naked without extensions. The currently core extensions are: chaostoolkit-kubernetes In addition, there are a bunch of incubating projects .","title":"Chaos Toolkit Projects At A Glance"},{"location":"reference/developing/guidelines/#creating-an-extension","text":"Please review the various approaches to extend the toolkit.","title":"Creating an Extension"},{"location":"reference/developing/guidelines/#creating-a-notification-plugin","text":"The Chaos Toolkit triggers events while it runs. Those events may be forwarded to any endpoint that you care for through HTTP or, when you need more control, a full Python project. There is no template for such a project yet but it is very close to an extension project except it doesn\u2019t have probes and actions. You can therefore start by cloning the extension template project and start from there. Instead, it should define a function in a module. That function takes two parameters: the notification channel settings (coming from the Chaos Toolkit settings file ) as a dictionary the event payload as a Python dictionary which is documented here The event has a payload key which is the content associated to the event. It can be one of: None when there was no payload () a string an experiment dictionary an journal dictionary Three kind of events can be triggered: started , completed and failed for each phase of the flow. Those events are defined here . A typical notification callback function will look like this: from typing import Any , Dict from chaoslib.notification import RunFlowEvent from chaoslib.types import EventPayload import logzero def notify ( settings : Dict [ str , Any ], event : EventPayload ): if event [ \"name\" ] == RunFlowEvent . RunStarted . value : logzero . info ( \"Event phase \" + event [ \"phase\" ]) logzero . info ( \"Event timestamp \" + event [ \"ts\" ]) logzero . info ( \"Event payload \" + event [ \"payload\" ]) logzero . info ( \"Event error \" + event . get ( \"error\" , \"N/A\" )) logzero is a third-party package that the Chaos Toolkit uses to log when it runs.","title":"Creating a Notification Plugin"},{"location":"reference/developing/technologies/","text":"Technology Choices \u00b6 Python 3 \u00b6 The Chaos Toolkit is implemented in Python 3 . A high-level language with a long successfully story for writing great software. It\u2019s a common choice for tooling purpose. The language supports readability well and has a large ecosystem of libraries. It is also well-spread and easy to install. The choice to not support Python 2 is a look at Python\u2019s present and future. The choice for a dynamic language was also motivated because the Chaos Toolkit manipulates a lot of strings and that task is made straightforward with Python. Although Python natively does not generate (though it can be done ) standalone binaries like golang would. We do not believe this will harm the project and hope that package managers will eventually provide native installers. Functional \u00b6 Well, this project is not truly a functional piece of code but the code relies as little as possible on stateful constructions as provided by classes. Mutable data structures are used but mostly created and returned from functions rather than modified. Generally speaking, the project draws inspirations from certain ideas of functional paradigms but does not enforce them strictly. One notable area where the code strays away from these principles is the use of exceptions rather than returning error codes. This may change if the community expresses such an intention.","title":"Technology Choices"},{"location":"reference/developing/technologies/#technology-choices","text":"","title":"Technology Choices"},{"location":"reference/developing/technologies/#python-3","text":"The Chaos Toolkit is implemented in Python 3 . A high-level language with a long successfully story for writing great software. It\u2019s a common choice for tooling purpose. The language supports readability well and has a large ecosystem of libraries. It is also well-spread and easy to install. The choice to not support Python 2 is a look at Python\u2019s present and future. The choice for a dynamic language was also motivated because the Chaos Toolkit manipulates a lot of strings and that task is made straightforward with Python. Although Python natively does not generate (though it can be done ) standalone binaries like golang would. We do not believe this will harm the project and hope that package managers will eventually provide native installers.","title":"Python 3"},{"location":"reference/developing/technologies/#functional","text":"Well, this project is not truly a functional piece of code but the code relies as little as possible on stateful constructions as provided by classes. Mutable data structures are used but mostly created and returned from functions rather than modified. Generally speaking, the project draws inspirations from certain ideas of functional paradigms but does not enforce them strictly. One notable area where the code strays away from these principles is the use of exceptions rather than returning error codes. This may change if the community expresses such an intention.","title":"Functional"},{"location":"reference/developing/values/","text":"Key Project Values \u00b6 The following key values of the Chaos Toolkit reflect the mindset the community has when engineering the Chaos Toolkit project. Simplicity \u00b6 The Chaos Toolkit aims at being a simple piece of technology both from a user and developer perspective. To achieve simplicity, the Chaos Toolkit comes as a command line interface driven by a description file. As a user, this means no code and no need to learn a programming language. As a developer, this reduces the functional surface area to consider. Extensibility \u00b6 The Chaos Toolkit does not wish to be a monolith and strives to be extended to fully reach its goal through community driven efforts. By using a description file, the implementation is not prescribed by the Chaos Toolkit project. Although we fully expect the community to eventually settle on certain implementations of probes and actions. Readability \u00b6 We believe code readability is a factor for positive maintenance and evolutivity. Readable code never goes out of fashion. As the code of the Chaos Toolkit is mostly written in Python, best practices such as defined in PEP8 . Diversity \u00b6 Although not strictly speaking referring to the technological aspect of the project, having diversity in the community will contribute to a better project overall.","title":"Key Project Values"},{"location":"reference/developing/values/#key-project-values","text":"The following key values of the Chaos Toolkit reflect the mindset the community has when engineering the Chaos Toolkit project.","title":"Key Project Values"},{"location":"reference/developing/values/#simplicity","text":"The Chaos Toolkit aims at being a simple piece of technology both from a user and developer perspective. To achieve simplicity, the Chaos Toolkit comes as a command line interface driven by a description file. As a user, this means no code and no need to learn a programming language. As a developer, this reduces the functional surface area to consider.","title":"Simplicity"},{"location":"reference/developing/values/#extensibility","text":"The Chaos Toolkit does not wish to be a monolith and strives to be extended to fully reach its goal through community driven efforts. By using a description file, the implementation is not prescribed by the Chaos Toolkit project. Although we fully expect the community to eventually settle on certain implementations of probes and actions.","title":"Extensibility"},{"location":"reference/developing/values/#readability","text":"We believe code readability is a factor for positive maintenance and evolutivity. Readable code never goes out of fashion. As the code of the Chaos Toolkit is mostly written in Python, best practices such as defined in PEP8 .","title":"Readability"},{"location":"reference/developing/values/#diversity","text":"Although not strictly speaking referring to the technological aspect of the project, having diversity in the community will contribute to a better project overall.","title":"Diversity"},{"location":"reference/extending/approaches/","text":"Extending the Chaos Toolkit \u00b6 The Chaos Toolkit is designed to be extended with new probes and actions so that you can work with any failure injection and system observability systems that you choose. The toolkit has a growing number of open source extensions for just this purpose, but the intention is that you may also want to extend the Chaos Toolkit for your own unique, possible closed, systems as well. The ChaosToolkit currently supports three extension approaches: Python function : see this page for more information on creating Python extensions Process HTTP You can extend your actions and probes by implementing them using one of these approaches. Tip The Chaos Toolkit maintains a set of open-source extensions ready to be integrated into your Chaos experiments.","title":"Extension Approaches"},{"location":"reference/extending/approaches/#extending-the-chaos-toolkit","text":"The Chaos Toolkit is designed to be extended with new probes and actions so that you can work with any failure injection and system observability systems that you choose. The toolkit has a growing number of open source extensions for just this purpose, but the intention is that you may also want to extend the Chaos Toolkit for your own unique, possible closed, systems as well. The ChaosToolkit currently supports three extension approaches: Python function : see this page for more information on creating Python extensions Process HTTP You can extend your actions and probes by implementing them using one of these approaches. Tip The Chaos Toolkit maintains a set of open-source extensions ready to be integrated into your Chaos experiments.","title":"Extending the Chaos Toolkit"},{"location":"reference/extending/create-control-extension/","text":"Create a Control Extension \u00b6 A control extension implements the interface defined by the Chaos Toolkit to support the Controls element of the specification . Controls Interface \u00b6 When implementing a control module, you must simply define a set of functions that are called by the Chaos Toolkit when executing the experiment. Tip All of these functions are optional, only implement the one you need. from typing import Any , Dict , List from chaoslib.types import Activity , Configuration , \\ Experiment , Hypothesis , Journal , Run , Secrets def configure_control ( config : Configuration , secrets : Secrets ): \"\"\" Configure the control's global state This is called once only per Chaos Toolkit's run and should be used to initialize any state your control may require. \"\"\" pass def cleanup_control (): \"\"\" Cleanup the control's global state Called once only during the experiment's execution. \"\"\" pass def before_experiment_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the experiment's execution Called by the Chaos Toolkit before the experiment's begin but after the configuration and secrets have been loaded. \"\"\" pass def after_experiment_control ( context : Experiment , state : Journal , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the experiment's execution Called by the Chaos Toolkit after the experiment's completed. It passes the journal of the execution. At that stage, the after control has no influence over the execution however. Please see https://docs.chaostoolkit.org/reference/api/journal/#journal-elements for more information about the journal. \"\"\" pass def before_hypothesis_control ( context : Hypothesis , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the hypothesis's execution Called by the Chaos Toolkit before the steady-state hypothesis is applied. \"\"\" pass def after_hypothesis_control ( context : Hypothesis , state : Dict [ str , Any ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the hypothesis's execution Called by the Chaos Toolkit after the steady-state hypothesis is complete. The `state` contains the result of the hypothesis. Refer to https://docs.chaostoolkit.org/reference/api/journal/#steady-state-outcomes for the description of that state. \"\"\" pass def before_method_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the method's execution Called by the Chaos Toolkit before the activities of the method are applied. \"\"\" pass def after_method_control ( context : Experiment , state : List [ Run ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the method's execution Called by the Chaos Toolkit after the activities of the method have been applied. The `state` is the list of activity results. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass def before_rollback_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the rollback's execution Called by the Chaos Toolkit before the actions of the rollback are applied. \"\"\" pass def after_rollback_control ( context : Experiment , state : List [ Run ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the rollback's execution Called by the Chaos Toolkit after the actions of the rollback have been applied. The `state` is the list of actions results. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass def before_activity_control ( context : Activity , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the activity's execution Called by the Chaos Toolkit before the activity is applied. \"\"\" pass def after_activity_control ( context : Activity , state : Run , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the activity's execution Called by the Chaos Toolkit before the activity is applied. The result of the execution is passed as `state`. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass Use your control \u00b6 Define those functions into a module that is used as a provider. For instance, assume the above definition is stored into a module chaosstuff.control , in other words a control.py module of the chaosstuff package. Then, your control can be used as follows: \"controls\" : [ { \"name\" : \"my-stuff\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosstuff.control\" } } ] The package must obviously be available to the PYTHONPATH in which the chaos runs. Things to note \u00b6 Unforeseen errors \u00b6 The Chaos Toolkit will not let a control abort the execution of the experiment. So if an exception is raised, it will be caught by the Chaos Toolkit, logged and the execution will carry on. Interruptinng the execution \u00b6 While unforeseen errors in your controls cannot stop the execution, you can interrupt the execution by raising chaoslib.exceptions.InterruptExecution from any of your control functions. Note however, this is a harsh way to terminate the execution since, none of the rollbacks will be applied. Here is an example: from chaoslib.exceptions import InterruptExecution def after_activity_control ( context : Activity , state : Run , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): if check_stuff ( state [ \"output\" ]): raise InterruptExecution ( \"Well things went really bad!\" ) In that case, the experiment\u2019s execution will have its status set to \"interrupted\" as described here .","title":"Create Control"},{"location":"reference/extending/create-control-extension/#create-a-control-extension","text":"A control extension implements the interface defined by the Chaos Toolkit to support the Controls element of the specification .","title":"Create a Control Extension"},{"location":"reference/extending/create-control-extension/#controls-interface","text":"When implementing a control module, you must simply define a set of functions that are called by the Chaos Toolkit when executing the experiment. Tip All of these functions are optional, only implement the one you need. from typing import Any , Dict , List from chaoslib.types import Activity , Configuration , \\ Experiment , Hypothesis , Journal , Run , Secrets def configure_control ( config : Configuration , secrets : Secrets ): \"\"\" Configure the control's global state This is called once only per Chaos Toolkit's run and should be used to initialize any state your control may require. \"\"\" pass def cleanup_control (): \"\"\" Cleanup the control's global state Called once only during the experiment's execution. \"\"\" pass def before_experiment_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the experiment's execution Called by the Chaos Toolkit before the experiment's begin but after the configuration and secrets have been loaded. \"\"\" pass def after_experiment_control ( context : Experiment , state : Journal , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the experiment's execution Called by the Chaos Toolkit after the experiment's completed. It passes the journal of the execution. At that stage, the after control has no influence over the execution however. Please see https://docs.chaostoolkit.org/reference/api/journal/#journal-elements for more information about the journal. \"\"\" pass def before_hypothesis_control ( context : Hypothesis , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the hypothesis's execution Called by the Chaos Toolkit before the steady-state hypothesis is applied. \"\"\" pass def after_hypothesis_control ( context : Hypothesis , state : Dict [ str , Any ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the hypothesis's execution Called by the Chaos Toolkit after the steady-state hypothesis is complete. The `state` contains the result of the hypothesis. Refer to https://docs.chaostoolkit.org/reference/api/journal/#steady-state-outcomes for the description of that state. \"\"\" pass def before_method_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the method's execution Called by the Chaos Toolkit before the activities of the method are applied. \"\"\" pass def after_method_control ( context : Experiment , state : List [ Run ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the method's execution Called by the Chaos Toolkit after the activities of the method have been applied. The `state` is the list of activity results. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass def before_rollback_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the rollback's execution Called by the Chaos Toolkit before the actions of the rollback are applied. \"\"\" pass def after_rollback_control ( context : Experiment , state : List [ Run ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the rollback's execution Called by the Chaos Toolkit after the actions of the rollback have been applied. The `state` is the list of actions results. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass def before_activity_control ( context : Activity , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the activity's execution Called by the Chaos Toolkit before the activity is applied. \"\"\" pass def after_activity_control ( context : Activity , state : Run , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the activity's execution Called by the Chaos Toolkit before the activity is applied. The result of the execution is passed as `state`. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass","title":"Controls Interface"},{"location":"reference/extending/create-control-extension/#use-your-control","text":"Define those functions into a module that is used as a provider. For instance, assume the above definition is stored into a module chaosstuff.control , in other words a control.py module of the chaosstuff package. Then, your control can be used as follows: \"controls\" : [ { \"name\" : \"my-stuff\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosstuff.control\" } } ] The package must obviously be available to the PYTHONPATH in which the chaos runs.","title":"Use your control"},{"location":"reference/extending/create-control-extension/#things-to-note","text":"","title":"Things to note"},{"location":"reference/extending/create-control-extension/#unforeseen-errors","text":"The Chaos Toolkit will not let a control abort the execution of the experiment. So if an exception is raised, it will be caught by the Chaos Toolkit, logged and the execution will carry on.","title":"Unforeseen errors"},{"location":"reference/extending/create-control-extension/#interruptinng-the-execution","text":"While unforeseen errors in your controls cannot stop the execution, you can interrupt the execution by raising chaoslib.exceptions.InterruptExecution from any of your control functions. Note however, this is a harsh way to terminate the execution since, none of the rollbacks will be applied. Here is an example: from chaoslib.exceptions import InterruptExecution def after_activity_control ( context : Activity , state : Run , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): if check_stuff ( state [ \"output\" ]): raise InterruptExecution ( \"Well things went really bad!\" ) In that case, the experiment\u2019s execution will have its status set to \"interrupted\" as described here .","title":"Interruptinng the execution"},{"location":"reference/extending/extending-with-python/","text":"Extending Chaos Toolkit with Python \u00b6 Create your new Chaos Toolkit extension project \u00b6 All Chaos Toolkit extensions follow the same structure and you can benefit from a project generator such as cookiecutter . This will drive you through a set of basic questions for metadata and will create a local project you can then start put your code into. Let\u2019s use the community-driven template project : $ pip install - U cookiecutter $ cookiecutter https://github.com/dastergon/cookiecutter-chaostoolkit.git Where to put your code \u00b6 There are two extension points for a Chaos Toolkit Python extension, and they are captured in two files: actions.py and probes.py . It is conventional to use the actions.py module as the place where you expose the actions that you would like to conduct as part of your Chaos Toolkit experimental method against the environment you want to inject failure into. It\u2019s also conventional to use the probes.py module as the place where you can integrate with your system\u2019s existing observability so that those values can be used either for an experiment\u2019s Steady State Hypothesis , or as simple additional data-gathering probes that can be declared throughout an experiment\u2019s method. Running Discover on a New Extension \u00b6 Chaos Toolkit extensions often implement functionality that assists in discovering what a system, and the extension against that system, supports. This is executed using the chaos discover command. When writing your own implementation of discovery you will often want to test the new functionality locally. To do this you should first execute from your extension workspace: $ python setup.py develop Then you can exercise your discovery functionality using the --no-install flag on the chaos discover command, for example: chaos discover --no-install ext-name Log From Your Extension \u00b6 You can write to the Chaos Toolkit log by using the logzero package. from logzero import logger logger . info ( \"Hello!\" ) Make sure to add logzero as an entry of the requirements.txt file of your extension.","title":"Extend with Python"},{"location":"reference/extending/extending-with-python/#extending-chaos-toolkit-with-python","text":"","title":"Extending Chaos Toolkit with Python"},{"location":"reference/extending/extending-with-python/#create-your-new-chaos-toolkit-extension-project","text":"All Chaos Toolkit extensions follow the same structure and you can benefit from a project generator such as cookiecutter . This will drive you through a set of basic questions for metadata and will create a local project you can then start put your code into. Let\u2019s use the community-driven template project : $ pip install - U cookiecutter $ cookiecutter https://github.com/dastergon/cookiecutter-chaostoolkit.git","title":"Create your new Chaos Toolkit extension project"},{"location":"reference/extending/extending-with-python/#where-to-put-your-code","text":"There are two extension points for a Chaos Toolkit Python extension, and they are captured in two files: actions.py and probes.py . It is conventional to use the actions.py module as the place where you expose the actions that you would like to conduct as part of your Chaos Toolkit experimental method against the environment you want to inject failure into. It\u2019s also conventional to use the probes.py module as the place where you can integrate with your system\u2019s existing observability so that those values can be used either for an experiment\u2019s Steady State Hypothesis , or as simple additional data-gathering probes that can be declared throughout an experiment\u2019s method.","title":"Where to put your code"},{"location":"reference/extending/extending-with-python/#running-discover-on-a-new-extension","text":"Chaos Toolkit extensions often implement functionality that assists in discovering what a system, and the extension against that system, supports. This is executed using the chaos discover command. When writing your own implementation of discovery you will often want to test the new functionality locally. To do this you should first execute from your extension workspace: $ python setup.py develop Then you can exercise your discovery functionality using the --no-install flag on the chaos discover command, for example: chaos discover --no-install ext-name","title":"Running Discover on a New Extension"},{"location":"reference/extending/extending-with-python/#log-from-your-extension","text":"You can write to the Chaos Toolkit log by using the logzero package. from logzero import logger logger . info ( \"Hello!\" ) Make sure to add logzero as an entry of the requirements.txt file of your extension.","title":"Log From Your Extension"},{"location":"reference/usage/cli/","text":"The heart of the Chaos Toolkit is the chaos command line. Activate the Python virtual environment If you run the Chaos Toolkit directly, rather than using a container, always ensure you have activated the virtual environment so that it can be found along its dependencies: $ source ~/.venvs/chaostk/bin/activate (chaostk) $ Once installed , the Chaos Toolkit CLI will display the commands it supports by executing: (chaostk) $ chaos --help Configure the Chaos Toolkit \u00b6 For the most part, the Chaos Toolkit does not necessitate to be configured. These settings are stored in a YAML file on your local machine. Tip Unless you enable one of the features requiring extra configuration, you don\u2019t need to create that file. Create The Settings File \u00b6 The settings file for the Chaos Toolkit should be located under the following path: $HOME/.chaostoolkit/settings.yaml As this file may hold sensitive data, it is advised to make it readable only for your own user: chmod 600 $HOME/.chaostoolkit/settings.yaml Features Settings \u00b6 The settings file entries depend on which features you wish to enable. Notification \u00b6 If you want to get notified of the Chaos Toolkit events, you should set the following section: notifications: - type: http url: https://mystuff.com/api verify_tls: false headers: Auth: \"Bearer 1234\" This entry is a list of mapping. Each item of this list defines one channel of notification, and potentially which events this channel should receive. Please refer to the notifications section for more information. How to Investigate Issues \u00b6 When your experiment fails to work as you would expect, you should start looking at the chaostoolkit.log file written to by the chaos command. This file contains a lot of traces from the Chaos Toolkit core but also any extensions that used the toolkit\u2019s logger. As new logs are appended to that file, it may grow big. Do not hesitate to wipe it out from time to time. Please, do make sure to visit our Slack or GitHub when you have a question around how the toolkit does things. The community will be pleased to help you out.","title":"Overview"},{"location":"reference/usage/cli/#configure-the-chaos-toolkit","text":"For the most part, the Chaos Toolkit does not necessitate to be configured. These settings are stored in a YAML file on your local machine. Tip Unless you enable one of the features requiring extra configuration, you don\u2019t need to create that file.","title":"Configure the Chaos Toolkit"},{"location":"reference/usage/cli/#create-the-settings-file","text":"The settings file for the Chaos Toolkit should be located under the following path: $HOME/.chaostoolkit/settings.yaml As this file may hold sensitive data, it is advised to make it readable only for your own user: chmod 600 $HOME/.chaostoolkit/settings.yaml","title":"Create The Settings File"},{"location":"reference/usage/cli/#features-settings","text":"The settings file entries depend on which features you wish to enable.","title":"Features Settings"},{"location":"reference/usage/cli/#notification","text":"If you want to get notified of the Chaos Toolkit events, you should set the following section: notifications: - type: http url: https://mystuff.com/api verify_tls: false headers: Auth: \"Bearer 1234\" This entry is a list of mapping. Each item of this list defines one channel of notification, and potentially which events this channel should receive. Please refer to the notifications section for more information.","title":"Notification"},{"location":"reference/usage/cli/#how-to-investigate-issues","text":"When your experiment fails to work as you would expect, you should start looking at the chaostoolkit.log file written to by the chaos command. This file contains a lot of traces from the Chaos Toolkit core but also any extensions that used the toolkit\u2019s logger. As new logs are appended to that file, it may grow big. Do not hesitate to wipe it out from time to time. Please, do make sure to visit our Slack or GitHub when you have a question around how the toolkit does things. The community will be pleased to help you out.","title":"How to Investigate Issues"},{"location":"reference/usage/discover/","text":"The chaos discover command \u00b6 You use the chaos discover command to specify a Chaos Toolkit integration extension and, if supported by the integration, to then explore your target environment in order to build a discovery report that can be used by the chaos init command to help you bootstrap your own chaos engineering experiments. You can see the options available to you by executing: (chaostk) $ chaos discover --help A tutorial on how to use the chaos discover command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials. Discovering capabilities and experiments \u00b6 To execute discover all you need to do is specify the Chaos Toolkit integration extension that you\u2019d like to use, for example to use Kubernetes: (chaostk) $ chaos discover chaostoolkit-kubernetes The chaos discover command will produce a report saved in ./discovery.json by default, although you can specify where this report is produced by supplying the --discovery-report-path option. Discovery without System Information \u00b6 To not probe the target system during the discovery process you can supply the --no-system-info option. Discovery without Installation of an Integration Extension \u00b6 If you already have the integration extension installed and available you can speed up the discovery process by specifying the --no-install option.","title":"Discover"},{"location":"reference/usage/discover/#the-chaos-discover-command","text":"You use the chaos discover command to specify a Chaos Toolkit integration extension and, if supported by the integration, to then explore your target environment in order to build a discovery report that can be used by the chaos init command to help you bootstrap your own chaos engineering experiments. You can see the options available to you by executing: (chaostk) $ chaos discover --help A tutorial on how to use the chaos discover command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials.","title":"The chaos discover command"},{"location":"reference/usage/discover/#discovering-capabilities-and-experiments","text":"To execute discover all you need to do is specify the Chaos Toolkit integration extension that you\u2019d like to use, for example to use Kubernetes: (chaostk) $ chaos discover chaostoolkit-kubernetes The chaos discover command will produce a report saved in ./discovery.json by default, although you can specify where this report is produced by supplying the --discovery-report-path option.","title":"Discovering capabilities and experiments"},{"location":"reference/usage/discover/#discovery-without-system-information","text":"To not probe the target system during the discovery process you can supply the --no-system-info option.","title":"Discovery without System Information"},{"location":"reference/usage/discover/#discovery-without-installation-of-an-integration-extension","text":"If you already have the integration extension installed and available you can speed up the discovery process by specifying the --no-install option.","title":"Discovery without Installation of an Integration Extension"},{"location":"reference/usage/init/","text":"The chaos init command \u00b6 You use the chaos init command to take a discovery report , usually created by the chaos discover command, to then create an experiment based upon what has been discovered about the integration extension and, if applicable, the target environment. You can see the options available to you by executing: (chaostk) $ chaos init --help A tutorial on how to use the chaos init command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials. Initialise a new experiment \u00b6 To initialise a new experiment based on what has been discovered you simply need to execute the chaos init command: (chaostk) $ chaos init By default, the chaos init command will look for a ./discovery.json file and use that as the basis of a new experiment\u2019s initialisation. You can specify another file to be used by suppling the --discovery-report-path option. In addition the default output from the init command will be a new Chaos Toolkit experiment definition in a ./experiment.json file. If you would prefer a different filename then this can be specified using the --experiment-path option.","title":"Init"},{"location":"reference/usage/init/#the-chaos-init-command","text":"You use the chaos init command to take a discovery report , usually created by the chaos discover command, to then create an experiment based upon what has been discovered about the integration extension and, if applicable, the target environment. You can see the options available to you by executing: (chaostk) $ chaos init --help A tutorial on how to use the chaos init command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials.","title":"The chaos init command"},{"location":"reference/usage/init/#initialise-a-new-experiment","text":"To initialise a new experiment based on what has been discovered you simply need to execute the chaos init command: (chaostk) $ chaos init By default, the chaos init command will look for a ./discovery.json file and use that as the basis of a new experiment\u2019s initialisation. You can specify another file to be used by suppling the --discovery-report-path option. In addition the default output from the init command will be a new Chaos Toolkit experiment definition in a ./experiment.json file. If you would prefer a different filename then this can be specified using the --experiment-path option.","title":"Initialise a new experiment"},{"location":"reference/usage/install/","text":"How to Install the Chaos Toolkit \u00b6 Python Requirements \u00b6 The chaostoolkit CLI is implemented in Python 3 and this requires a working Python installation to run. It officially supports Python 3.5+. It has only been tested against [CPython][python]. Install Python \u00b6 Install Python for your system: On MacOS X: $ brew install python3 On Debian/Ubuntu: $ sudo apt-get install python3 python3-venv On CentOS: $ sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm $ sudo yum -y install python35u Notice, on CentOS, the Python 3.5 binary is named python3.5 rather than python3 as other systems. On Windows: Download the latest binary installer from the Python website. Create a virtual environment \u00b6 Dependencies can be installed for your system via its package management but, more likely, you will want to install them yourself in a local virtual environment. $ python3 -m venv ~/.venvs/chaostk Make sure to always activate your virtual environment before using it: $ source ~/.venvs/chaostk/bin/activate Tip You may want to use virtualenvwrapper to make this process much nicer. Install the CLI \u00b6 Install chaostoolkit in the virtual environment as follows: (chaostk) $ pip install chaostoolkit You can verify the command was installed by running: (chaostk) $ chaos --version Install Extensions \u00b6 At this stage, you have installed the chaos command line and its core library. To fully enjoy the Chaos Toolkit, you will also want to install extensions for the various facets of your journey into Chaos Engineering.","title":"Install"},{"location":"reference/usage/install/#how-to-install-the-chaos-toolkit","text":"","title":"How to Install the Chaos Toolkit"},{"location":"reference/usage/install/#python-requirements","text":"The chaostoolkit CLI is implemented in Python 3 and this requires a working Python installation to run. It officially supports Python 3.5+. It has only been tested against [CPython][python].","title":"Python Requirements"},{"location":"reference/usage/install/#install-python","text":"Install Python for your system: On MacOS X: $ brew install python3 On Debian/Ubuntu: $ sudo apt-get install python3 python3-venv On CentOS: $ sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm $ sudo yum -y install python35u Notice, on CentOS, the Python 3.5 binary is named python3.5 rather than python3 as other systems. On Windows: Download the latest binary installer from the Python website.","title":"Install Python"},{"location":"reference/usage/install/#create-a-virtual-environment","text":"Dependencies can be installed for your system via its package management but, more likely, you will want to install them yourself in a local virtual environment. $ python3 -m venv ~/.venvs/chaostk Make sure to always activate your virtual environment before using it: $ source ~/.venvs/chaostk/bin/activate Tip You may want to use virtualenvwrapper to make this process much nicer.","title":"Create a virtual environment"},{"location":"reference/usage/install/#install-the-cli","text":"Install chaostoolkit in the virtual environment as follows: (chaostk) $ pip install chaostoolkit You can verify the command was installed by running: (chaostk) $ chaos --version","title":"Install the CLI"},{"location":"reference/usage/install/#install-extensions","text":"At this stage, you have installed the chaos command line and its core library. To fully enjoy the Chaos Toolkit, you will also want to install extensions for the various facets of your journey into Chaos Engineering.","title":"Install Extensions"},{"location":"reference/usage/investigating/","text":"How to Investigate Issues \u00b6 When your experiment fails to work as you would expect, you should start looking at the chaostoolkit.log file written to by the chaos command. This file contains a lot of traces from the Chaos Toolkit core but also any extensions that used the toolkit\u2019s logger. As new logs are appended to that file, it may grow big. Do not hesitate to wipe it out from time to time. Please, do make sure to visit our Slack or GitHub when you have a question around how the toolkit does things. The community will be pleased to help you out.","title":"How to Investigate Issues"},{"location":"reference/usage/investigating/#how-to-investigate-issues","text":"When your experiment fails to work as you would expect, you should start looking at the chaostoolkit.log file written to by the chaos command. This file contains a lot of traces from the Chaos Toolkit core but also any extensions that used the toolkit\u2019s logger. As new logs are appended to that file, it may grow big. Do not hesitate to wipe it out from time to time. Please, do make sure to visit our Slack or GitHub when you have a question around how the toolkit does things. The community will be pleased to help you out.","title":"How to Investigate Issues"},{"location":"reference/usage/notification/","text":"Get Notifications From The Chaos Toolkit Flow \u00b6 The Chaos Toolkit generates events when it is executed. You may benefit from those events to get notified via your chosen notification channels. Chaos Toolkit Flow Events \u00b6 The Chaos Toolkit defines the following events: Discovery flow \"discover-started\" : when the discovery flow has begun Payload: the name of the Chaos Toolkit extension used to discover the system \"discover-completed\" : when the discovery flow has completed Payload: the result of the discovery \"discover-failed\" : when the discovery flow has failed Payload: the name of the Chaos Toolkit extension usd to discover the system Additional Payload: The error Init flow \"init-started\" : when the init flow has begun Payload: None \"init-completed\" : when the init flow has completed Payload: the generated experiment Run flow \"run-started\" : when the run flow has begun Payload: The experiment that gets executed \"run-completed\" : when the run flow has completed Payload: The journal of the experiment\u2019s execution \"run-failed\" : when the run flow has failed Payload: The journal of the experiment\u2019s execution Validate flow \"validate-started\" : when the validate flow has begun Payload: The experiment to validate \"validate-completed\" : when the validate flow has completed Payload: The experiment to validate \"validate-failed\" : when the validate flow has failed Payload: The experiment to validate Additional Payload: The error Notification Event Structure \u00b6 The events structure is as follows: { \"name\" : \"run-started|...\" , \"payload\" : \"the payload for the given event\" , \"phase\" : \"run|discovery|init|validate\" , \"error\" : \"only set when an error was triggered. Set to the actual raw error\" , \"ts\" : \"<now>\" } Note, the error is not a failure of the experiment\u2019s steady-state but an error during the processing of the flow (for instance, the experiment\u2019s file has a mistake somewhere in its syntax, or an exception is raised somehow). Declare Notification Channels \u00b6 Notification channels are declared in the Chaos Toolkit settings file under the notifications: section. Here is an example: notifications : - type : http url : https://mystuff.com/api verify_tls : false headers : Authorization : \"Bearer 1234\" - type : plugin module : chaosslack.notification token : xop-1235 channel : general As you can see, channels are items in a list. Each channel is a mapping describing the kind of channel and its required information. For instance, here we have two channels. The first one is a call to the HTTPS endpoint while the other one uses the Chaos Toolkit Extension for Slack to send messages to Slack channels. Warning Notification channels are run sequential to the whole chaos flow, so the more you declare, the bigger the impact they could have on the readability of the experiment results. Filter Events \u00b6 By default, all events are sent to the channels. However, you may decide, on a per channel basis, which events you want to be sent. This is done by adding the events field to a channel: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general events : - run-failed The Slack channel will only receive events when a run experiment fails. This is a list so declare as many events as you need. HTTP Notification Channel \u00b6 A HTTP notification channel tells the Chaos Toolkit it must send the event over HTTP (or HTTPS) to the given endpoint. Here is the description of its fields: type : must \"http\" (required) url : the endpoint address (required) verify_tls : true|false depending if the endpoint certificates are self-signed headers : a mapping where the keys are header names and their associated values forward_event_payload : true|false . If true , the default, then the event payload is sent to that endpoint in a POST request. Otherwise, a GET request is performed with no body Plugin Notification Channel \u00b6 A plugin notification channel is an integration between an external system and the Chaos Toolkit event notification flow. It is more capable than basic HTTP channels as they are fully fledged Python functions. Warning A plugin channel could also be understood as a hook point into the Chaos Toolkit flow. Nothing prevents you from writing a plugin that performs operations based on those hook events. Please note however that they run sequentially to the whole flow, so the longer your operation takes, the longer it takes for your chaos experiment to carry on. This may invalidate certain experiments when timing is critical. Here are the fields to declare one: type : must \"plugin\" (required) module : the dotted path to the Python module containing the function to apply (required) func : the name of the function to apply (in that module), defaults to \"notify\" Any other fields will be passed on as-is to the function for its internal usage. For instance: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general The token and channel fields will be provided directly to the notify function of the chaosslack.notification module. Send Notifications To Slack \u00b6 Notifying about Chaos Experiment in a slack channel is so common that we will describe this integration here. First, you must install the Chaos Toolkit Integration for Slack as usual: (chaostk) $ pip install -U chaostoolkit-slack Then, you should declare your notification channels as follows in the Chaos Toolkit settings file. notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general You may define as many channels as you need, for instance for different kind of events. The token and channel fields are mandatory in this case. The token field must be set to a valid Slack token. You may start with a legacy token before moving on to a Slack App as per Slack guidelines . The Chaos Toolkit itself does not provide a Slack App at this moment. The channel must be a name of an existing channel. The payload message sent to Slack is defined in the plugin . If you need to amend it, please open an issue there. Debugging Notifications \u00b6 The Chaos Toolkit does its best to not break the experiment when an event could not be pushed. If you do not see the notification you were expecting, you should start investigating in the chaostoolkit.og file. Indeed, in that case the error is logged at the DEBUG level with, hopefully, enough information why the event could not be sent. If the error occurs inside the core Chaos Toolkit library, please raise an issue there . Otherwise, raise an issue with the appropriate plugin.","title":"Notify"},{"location":"reference/usage/notification/#get-notifications-from-the-chaos-toolkit-flow","text":"The Chaos Toolkit generates events when it is executed. You may benefit from those events to get notified via your chosen notification channels.","title":"Get Notifications From The Chaos Toolkit Flow"},{"location":"reference/usage/notification/#chaos-toolkit-flow-events","text":"The Chaos Toolkit defines the following events: Discovery flow \"discover-started\" : when the discovery flow has begun Payload: the name of the Chaos Toolkit extension used to discover the system \"discover-completed\" : when the discovery flow has completed Payload: the result of the discovery \"discover-failed\" : when the discovery flow has failed Payload: the name of the Chaos Toolkit extension usd to discover the system Additional Payload: The error Init flow \"init-started\" : when the init flow has begun Payload: None \"init-completed\" : when the init flow has completed Payload: the generated experiment Run flow \"run-started\" : when the run flow has begun Payload: The experiment that gets executed \"run-completed\" : when the run flow has completed Payload: The journal of the experiment\u2019s execution \"run-failed\" : when the run flow has failed Payload: The journal of the experiment\u2019s execution Validate flow \"validate-started\" : when the validate flow has begun Payload: The experiment to validate \"validate-completed\" : when the validate flow has completed Payload: The experiment to validate \"validate-failed\" : when the validate flow has failed Payload: The experiment to validate Additional Payload: The error","title":"Chaos Toolkit Flow Events"},{"location":"reference/usage/notification/#notification-event-structure","text":"The events structure is as follows: { \"name\" : \"run-started|...\" , \"payload\" : \"the payload for the given event\" , \"phase\" : \"run|discovery|init|validate\" , \"error\" : \"only set when an error was triggered. Set to the actual raw error\" , \"ts\" : \"<now>\" } Note, the error is not a failure of the experiment\u2019s steady-state but an error during the processing of the flow (for instance, the experiment\u2019s file has a mistake somewhere in its syntax, or an exception is raised somehow).","title":"Notification Event Structure"},{"location":"reference/usage/notification/#declare-notification-channels","text":"Notification channels are declared in the Chaos Toolkit settings file under the notifications: section. Here is an example: notifications : - type : http url : https://mystuff.com/api verify_tls : false headers : Authorization : \"Bearer 1234\" - type : plugin module : chaosslack.notification token : xop-1235 channel : general As you can see, channels are items in a list. Each channel is a mapping describing the kind of channel and its required information. For instance, here we have two channels. The first one is a call to the HTTPS endpoint while the other one uses the Chaos Toolkit Extension for Slack to send messages to Slack channels. Warning Notification channels are run sequential to the whole chaos flow, so the more you declare, the bigger the impact they could have on the readability of the experiment results.","title":"Declare Notification Channels"},{"location":"reference/usage/notification/#filter-events","text":"By default, all events are sent to the channels. However, you may decide, on a per channel basis, which events you want to be sent. This is done by adding the events field to a channel: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general events : - run-failed The Slack channel will only receive events when a run experiment fails. This is a list so declare as many events as you need.","title":"Filter Events"},{"location":"reference/usage/notification/#http-notification-channel","text":"A HTTP notification channel tells the Chaos Toolkit it must send the event over HTTP (or HTTPS) to the given endpoint. Here is the description of its fields: type : must \"http\" (required) url : the endpoint address (required) verify_tls : true|false depending if the endpoint certificates are self-signed headers : a mapping where the keys are header names and their associated values forward_event_payload : true|false . If true , the default, then the event payload is sent to that endpoint in a POST request. Otherwise, a GET request is performed with no body","title":"HTTP Notification Channel"},{"location":"reference/usage/notification/#plugin-notification-channel","text":"A plugin notification channel is an integration between an external system and the Chaos Toolkit event notification flow. It is more capable than basic HTTP channels as they are fully fledged Python functions. Warning A plugin channel could also be understood as a hook point into the Chaos Toolkit flow. Nothing prevents you from writing a plugin that performs operations based on those hook events. Please note however that they run sequentially to the whole flow, so the longer your operation takes, the longer it takes for your chaos experiment to carry on. This may invalidate certain experiments when timing is critical. Here are the fields to declare one: type : must \"plugin\" (required) module : the dotted path to the Python module containing the function to apply (required) func : the name of the function to apply (in that module), defaults to \"notify\" Any other fields will be passed on as-is to the function for its internal usage. For instance: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general The token and channel fields will be provided directly to the notify function of the chaosslack.notification module.","title":"Plugin Notification Channel"},{"location":"reference/usage/notification/#send-notifications-to-slack","text":"Notifying about Chaos Experiment in a slack channel is so common that we will describe this integration here. First, you must install the Chaos Toolkit Integration for Slack as usual: (chaostk) $ pip install -U chaostoolkit-slack Then, you should declare your notification channels as follows in the Chaos Toolkit settings file. notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general You may define as many channels as you need, for instance for different kind of events. The token and channel fields are mandatory in this case. The token field must be set to a valid Slack token. You may start with a legacy token before moving on to a Slack App as per Slack guidelines . The Chaos Toolkit itself does not provide a Slack App at this moment. The channel must be a name of an existing channel. The payload message sent to Slack is defined in the plugin . If you need to amend it, please open an issue there.","title":"Send Notifications To Slack"},{"location":"reference/usage/notification/#debugging-notifications","text":"The Chaos Toolkit does its best to not break the experiment when an event could not be pushed. If you do not see the notification you were expecting, you should start investigating in the chaostoolkit.og file. Indeed, in that case the error is logged at the DEBUG level with, hopefully, enough information why the event could not be sent. If the error occurs inside the core Chaos Toolkit library, please raise an issue there . Otherwise, raise an issue with the appropriate plugin.","title":"Debugging Notifications"},{"location":"reference/usage/overview/","text":"The Chaos Toolkit implements a specific workflow that intends to help you discover, explore, build, run and , most importantly, learn from your chaos engineering experiments. Install or Upgrade the Chaos Toolkit. Discover what can be explored in your target environment. Init to bootstrap your own, new chaos engineering experiments based on what has been discovered . Run your chaos engineering experiments. Produce great reports based on the findings of your chaos engineering experiments. Notify your team to make your experiments visible to all.","title":"Overview"},{"location":"reference/usage/report/","text":"The chaos report command \u00b6 You use the chaos report command to take the journal produced by the chaos run command and produce a report in a specified format. Due to the many operating system-dependent features that the chaos report command relies upon, the chaos report command is not installed with the Chaos Toolkit CLI. To install the chaos report command you need to install the chaostoolkit-reporting plugin and the dependencies appropriate to your own operating system . Once the plugin is installed you can see the options available to you by executing: (chaostk) $ chaos report --help A tutorial on how to use the chaos report command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials. Generating a report \u00b6 When an experiment completes after using the chaos run command a journal is generated and stored in the chaos-report.json file. A PDF or HTML report may be generated from this journal using the chaostoolkit-reporting library. The chaos report command expects the path to the chaos-report.json file and a path to the actual report file that you require. You can export various formats of report by specifying what you want using the --export-format option. For example, to generate a PDF report you can run the following command: $ chaos report --export-format=pdf chaos-report.json report.pdf An HTML report can be produced using: $ chaos report --export-format=html5 chaos-report.json report.html","title":"Report"},{"location":"reference/usage/report/#the-chaos-report-command","text":"You use the chaos report command to take the journal produced by the chaos run command and produce a report in a specified format. Due to the many operating system-dependent features that the chaos report command relies upon, the chaos report command is not installed with the Chaos Toolkit CLI. To install the chaos report command you need to install the chaostoolkit-reporting plugin and the dependencies appropriate to your own operating system . Once the plugin is installed you can see the options available to you by executing: (chaostk) $ chaos report --help A tutorial on how to use the chaos report command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials.","title":"The chaos report command"},{"location":"reference/usage/report/#generating-a-report","text":"When an experiment completes after using the chaos run command a journal is generated and stored in the chaos-report.json file. A PDF or HTML report may be generated from this journal using the chaostoolkit-reporting library. The chaos report command expects the path to the chaos-report.json file and a path to the actual report file that you require. You can export various formats of report by specifying what you want using the --export-format option. For example, to generate a PDF report you can run the following command: $ chaos report --export-format=pdf chaos-report.json report.pdf An HTML report can be produced using: $ chaos report --export-format=html5 chaos-report.json report.html","title":"Generating a report"},{"location":"reference/usage/run/","text":"The chaos run command \u00b6 You use the chaos run command to execute your declarative chaos engineering experiments. To see the options that can be passed to the chaos run command, execute: (chaostk) $ chaos run --help A tutorial on how to use the chaos run command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials. Executing an Experiment Plan \u00b6 To execute an experiment plan you simply pass it to the chaos run command: (chaostk) $ chaos run experiment.json chaostoolkit will log all the steps it follows from your plan in a journal by default called chaos-report.json . You can specify the name of this journal output file using the --report-path option. Rehearsing an experiment execution \u00b6 To test that you have a valid experiment you can pass the --dry option. Run an experiment without validation \u00b6 You can run an experiment and skip the experiment\u2019s validation using the --no-validation option.","title":"Run"},{"location":"reference/usage/run/#the-chaos-run-command","text":"You use the chaos run command to execute your declarative chaos engineering experiments. To see the options that can be passed to the chaos run command, execute: (chaostk) $ chaos run --help A tutorial on how to use the chaos run command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials.","title":"The chaos run command"},{"location":"reference/usage/run/#executing-an-experiment-plan","text":"To execute an experiment plan you simply pass it to the chaos run command: (chaostk) $ chaos run experiment.json chaostoolkit will log all the steps it follows from your plan in a journal by default called chaos-report.json . You can specify the name of this journal output file using the --report-path option.","title":"Executing an Experiment Plan"},{"location":"reference/usage/run/#rehearsing-an-experiment-execution","text":"To test that you have a valid experiment you can pass the --dry option.","title":"Rehearsing an experiment execution"},{"location":"reference/usage/run/#run-an-experiment-without-validation","text":"You can run an experiment and skip the experiment\u2019s validation using the --no-validation option.","title":"Run an experiment without validation"},{"location":"reference/usage/scheduling/","text":"Scheduling your Experiments \u00b6 Scheduling is not built into the Chaos Toolkit itself. However it is common to want to run an experiment periodically when you may not be at the keyboard. In these cases we recommend using a system such as cron to schedule your experiment executions. You can also use a Kubernetes job to give you full control over the lifecycle of that job using the common Kubernetes features.","title":"Schedule"},{"location":"reference/usage/scheduling/#scheduling-your-experiments","text":"Scheduling is not built into the Chaos Toolkit itself. However it is common to want to run an experiment periodically when you may not be at the keyboard. In these cases we recommend using a system such as cron to schedule your experiment executions. You can also use a Kubernetes job to give you full control over the lifecycle of that job using the common Kubernetes features.","title":"Scheduling your Experiments"},{"location":"reference/usage/settings/","text":"","title":"Settings"},{"location":"reference/usage/upgrade/","text":"How to Upgrade the Chaos Toolkit \u00b6 You can update your Chaos Toolkit installation by executing: (chaostk) $ pip install -U chaostoolkit","title":"Upgrade"},{"location":"reference/usage/upgrade/#how-to-upgrade-the-chaos-toolkit","text":"You can update your Chaos Toolkit installation by executing: (chaostk) $ pip install -U chaostoolkit","title":"How to Upgrade the Chaos Toolkit"},{"location":"resources/logos/","text":"Chaos Toolkit Resources: Logos \u00b6 The following resources are licensed under the CC BY 4.0 license so you can use them wherever you (presentations, web sites etc) like as long as you attribute back to the Chaos Toolkit project : Chaos Toolkit Logo Sources","title":"Logos"},{"location":"resources/logos/#chaos-toolkit-resources-logos","text":"The following resources are licensed under the CC BY 4.0 license so you can use them wherever you (presentations, web sites etc) like as long as you attribute back to the Chaos Toolkit project : Chaos Toolkit Logo Sources","title":"Chaos Toolkit Resources: Logos"},{"location":"resources/slides/","text":"Chaos Toolkit Resources: Slides \u00b6 The following is a growing collection of slides that can be used by anyone in the community when speaking about the Chaos Toolkit. These resources are licensed under the CC BY 4.0 license so you can use them wherever you like (presentations, web sites etc) as long as you attribute back to the Chaos Toolkit project : Chaos Toolkit Timeline","title":"Slides"},{"location":"resources/slides/#chaos-toolkit-resources-slides","text":"The following is a growing collection of slides that can be used by anyone in the community when speaking about the Chaos Toolkit. These resources are licensed under the CC BY 4.0 license so you can use them wherever you like (presentations, web sites etc) as long as you attribute back to the Chaos Toolkit project : Chaos Toolkit Timeline","title":"Chaos Toolkit Resources: Slides"},{"location":"shared/code/","text":"Chaos Toolkit Documentation Support Code \u00b6 Support code for the documentation . You may want to clone this repository to play with the code used in the tutorials.","title":"Chaos Toolkit Documentation Support Code"},{"location":"shared/code/#chaos-toolkit-documentation-support-code","text":"Support code for the documentation . You may want to clone this repository to play with the code used in the tutorials.","title":"Chaos Toolkit Documentation Support Code"}]}