{
    "docs": [
        {
            "location": "/",
            "text": "An Open API for Chaos Engineering\n\u00b6\n\n\nThe Chaos Toolkit is a free, open source project that enables you to create and\napply Chaos Experiments to various types of infrastructure, platforms and\napplications.\n\n\nRunning experiments is as simple as:\n\n\n$ chaos run experiment.json\n\n\n\n\nThis takes the description of your experiment, as per the \nAPI\n, runs it\nand outputs a report to share with your team.\n\n\nMission\n\u00b6\n\n\nThe Chaos Toolkit aims at simplifying your journey through the\n\nPrinciples of Chaos Engineering\n and more generally considers that\nyou should embrace continuously observing and poking your system to empower your\nteam in face of adversity.\n\n\nThe Chaos Toolkit proposes an \nOpen API\n for Chaos Engineering that will\nfederate communities around the discipline with a standard, open and evolutive\nAPI.\n\n\nCome join the Chaos Toolkit community\n\u00b6\n\n\nThe Chaos Toolkit is an \nopen source project\n and strives on a diverse and\ncooperative community. We welcome input and discussions on the project itself\nbut also on the \nPrinciples of Chaos Engineering\n in general.\n\n\nPlease \njoin us\n!",
            "title": "Introduction"
        },
        {
            "location": "/#an-open-api-for-chaos-engineering",
            "text": "The Chaos Toolkit is a free, open source project that enables you to create and\napply Chaos Experiments to various types of infrastructure, platforms and\napplications.  Running experiments is as simple as:  $ chaos run experiment.json  This takes the description of your experiment, as per the  API , runs it\nand outputs a report to share with your team.",
            "title": "An Open API for Chaos Engineering"
        },
        {
            "location": "/#mission",
            "text": "The Chaos Toolkit aims at simplifying your journey through the Principles of Chaos Engineering  and more generally considers that\nyou should embrace continuously observing and poking your system to empower your\nteam in face of adversity.  The Chaos Toolkit proposes an  Open API  for Chaos Engineering that will\nfederate communities around the discipline with a standard, open and evolutive\nAPI.",
            "title": "Mission"
        },
        {
            "location": "/#come-join-the-chaos-toolkit-community",
            "text": "The Chaos Toolkit is an  open source project  and strives on a diverse and\ncooperative community. We welcome input and discussions on the project itself\nbut also on the  Principles of Chaos Engineering  in general.  Please  join us !",
            "title": "Come join the Chaos Toolkit community"
        },
        {
            "location": "/overview/concepts/",
            "text": "Chaos Engeering Concepts in the Chaos Toolkit\n\u00b6\n\n\nIf you haven\u2019t already, we strongly recommend reading the fantastic\n\nChaos Engineering\n book from O\u2019Reilly Media. This\nbook will give you some fantastic background on the whole Chaos Engineering\ndiscipline, and it\u2019s free!\n\n\nChaos Engineering is a discipline that allows you to surface weaknesses, and\neventually build confidence, in complex and often distributed systems. \n\n\nThe Chaos Toolkit aims to give you the simplest experience for writing and\nrunning your own Chaos Engineering experiments. The main concepts are all\nexpressed in an experiment definition, of which the following is an example\nfrom the\n\nChaos Toolkit Samples\n\nproject:\n\n\n{\n\n    \n\"version\"\n:\n \n\"1.0.0\"\n,\n\n    \n\"title\"\n:\n \n\"System is resilient to provider's failures\"\n,\n\n    \n\"description\"\n:\n \n\"Can our consumer survive gracefully a provider's failure?\"\n,\n\n    \n\"tags\"\n:\n \n[\n\n        \n\"service\"\n,\n\n        \n\"kubernetes\"\n,\n\n        \n\"spring\"\n\n    \n],\n\n    \n\"steady-state-hypothesis\"\n:\n \n{\n\n        \n\"title\"\n:\n \n\"Services are all available and healthy\"\n,\n\n        \n\"probes\"\n:\n \n[\n\n            \n{\n\n                \n\"type\"\n:\n \n\"probe\"\n,\n\n                \n\"name\"\n:\n \n\"all-services-are-healthy\"\n,\n\n                \n\"tolerance\"\n:\n \ntrue\n,\n\n                \n\"provider\"\n:\n \n{\n\n                    \n\"type\"\n:\n \n\"python\"\n,\n\n                    \n\"module\"\n:\n \n\"chaosk8s.probes\"\n,\n\n                    \n\"func\"\n:\n \n\"all_microservices_healthy\"\n\n                \n}\n\n            \n}\n\n        \n]\n\n    \n},\n\n    \n\"method\"\n:\n \n[\n\n        \n{\n\n            \n\"type\"\n:\n \n\"action\"\n,\n\n            \n\"name\"\n:\n \n\"stop-provider-service\"\n,\n\n            \n\"provider\"\n:\n \n{\n\n                \n\"type\"\n:\n \n\"python\"\n,\n\n                \n\"module\"\n:\n \n\"chaosk8s.actions\"\n,\n\n                \n\"func\"\n:\n \n\"kill_microservice\"\n,\n\n                \n\"arguments\"\n:\n \n{\n\n                    \n\"name\"\n:\n \n\"my-provider-service\"\n\n                \n}\n\n            \n},\n\n            \n\"pauses\"\n:\n \n{\n\n                \n\"after\"\n:\n \n10\n\n            \n}\n\n        \n},\n\n        \n{\n\n            \n\"ref\"\n:\n \n\"all-services-are-healthy\"\n\n        \n},\n\n        \n{\n\n            \n\"type\"\n:\n \n\"probe\"\n,\n\n            \n\"name\"\n:\n \n\"consumer-service-must-still-respond\"\n,\n\n            \n\"provider\"\n:\n \n{\n\n                \n\"type\"\n:\n \n\"http\"\n,\n\n                \n\"url\"\n:\n \n\"http://192.168.42.58:31018/invokeConsumedService\"\n\n            \n}\n\n        \n}\n\n    \n],\n\n    \n\"rollbacks\"\n:\n \n[]\n\n\n}\n\n\n\n\n\nThe key concepts of the Chaos Toolkit are \nExperiments\n,\n\nSteady State Hypothesis\n and the experiment\u2019s \nMethod\n. The \nMethod\n\ncontains a combination of \nProbes\n and \nActions\n.\n\n\nExperiments\n\u00b6\n\n\nA Chaos Toolkit experiment is provided in a single file and is currently\nexpressed in JSON.\n\n\nSteady State Hypothesis\n\u00b6\n\n\nA Steady State Hypothesis describes \u201cwhat normal looks like\u201d for your system\nin order for the experiment to surface information you can make sense of.\n\n\nIndeed, should your system be already in a broken state, your experiment\ncould be difficult to interpret.\n\n\nThere is a single Steady State Hypothesis per experiment and is made of\nprobes. If any of those fail, the experiment is halted.\n\n\nMethod\n\u00b6\n\n\nAn experiment\u2019s activities are contained within its \nMethod\n block.\n\n\nProbes\n\u00b6\n\n\nA probe is a way of observing a particular set of conditions in the system that\nis undergoing experimentation.\n\n\nActions\n\u00b6\n\n\nAn action is a particular activity that needs to be enacted on the system under\nexperimentation.\n\n\nRollbacks\n\u00b6\n\n\nAn experiment may define a sequence of actions that revert what was undone\nduring the experiment.",
            "title": "Concepts"
        },
        {
            "location": "/overview/concepts/#chaos-engeering-concepts-in-the-chaos-toolkit",
            "text": "If you haven\u2019t already, we strongly recommend reading the fantastic Chaos Engineering  book from O\u2019Reilly Media. This\nbook will give you some fantastic background on the whole Chaos Engineering\ndiscipline, and it\u2019s free!  Chaos Engineering is a discipline that allows you to surface weaknesses, and\neventually build confidence, in complex and often distributed systems.   The Chaos Toolkit aims to give you the simplest experience for writing and\nrunning your own Chaos Engineering experiments. The main concepts are all\nexpressed in an experiment definition, of which the following is an example\nfrom the Chaos Toolkit Samples \nproject:  { \n     \"version\" :   \"1.0.0\" , \n     \"title\" :   \"System is resilient to provider's failures\" , \n     \"description\" :   \"Can our consumer survive gracefully a provider's failure?\" , \n     \"tags\" :   [ \n         \"service\" , \n         \"kubernetes\" , \n         \"spring\" \n     ], \n     \"steady-state-hypothesis\" :   { \n         \"title\" :   \"Services are all available and healthy\" , \n         \"probes\" :   [ \n             { \n                 \"type\" :   \"probe\" , \n                 \"name\" :   \"all-services-are-healthy\" , \n                 \"tolerance\" :   true , \n                 \"provider\" :   { \n                     \"type\" :   \"python\" , \n                     \"module\" :   \"chaosk8s.probes\" , \n                     \"func\" :   \"all_microservices_healthy\" \n                 } \n             } \n         ] \n     }, \n     \"method\" :   [ \n         { \n             \"type\" :   \"action\" , \n             \"name\" :   \"stop-provider-service\" , \n             \"provider\" :   { \n                 \"type\" :   \"python\" , \n                 \"module\" :   \"chaosk8s.actions\" , \n                 \"func\" :   \"kill_microservice\" , \n                 \"arguments\" :   { \n                     \"name\" :   \"my-provider-service\" \n                 } \n             }, \n             \"pauses\" :   { \n                 \"after\" :   10 \n             } \n         }, \n         { \n             \"ref\" :   \"all-services-are-healthy\" \n         }, \n         { \n             \"type\" :   \"probe\" , \n             \"name\" :   \"consumer-service-must-still-respond\" , \n             \"provider\" :   { \n                 \"type\" :   \"http\" , \n                 \"url\" :   \"http://192.168.42.58:31018/invokeConsumedService\" \n             } \n         } \n     ], \n     \"rollbacks\" :   []  }   The key concepts of the Chaos Toolkit are  Experiments , Steady State Hypothesis  and the experiment\u2019s  Method . The  Method \ncontains a combination of  Probes  and  Actions .",
            "title": "Chaos Engeering Concepts in the Chaos Toolkit"
        },
        {
            "location": "/overview/concepts/#experiments",
            "text": "A Chaos Toolkit experiment is provided in a single file and is currently\nexpressed in JSON.",
            "title": "Experiments"
        },
        {
            "location": "/overview/concepts/#steady-state-hypothesis",
            "text": "A Steady State Hypothesis describes \u201cwhat normal looks like\u201d for your system\nin order for the experiment to surface information you can make sense of.  Indeed, should your system be already in a broken state, your experiment\ncould be difficult to interpret.  There is a single Steady State Hypothesis per experiment and is made of\nprobes. If any of those fail, the experiment is halted.",
            "title": "Steady State Hypothesis"
        },
        {
            "location": "/overview/concepts/#method",
            "text": "An experiment\u2019s activities are contained within its  Method  block.",
            "title": "Method"
        },
        {
            "location": "/overview/concepts/#probes",
            "text": "A probe is a way of observing a particular set of conditions in the system that\nis undergoing experimentation.",
            "title": "Probes"
        },
        {
            "location": "/overview/concepts/#actions",
            "text": "An action is a particular activity that needs to be enacted on the system under\nexperimentation.",
            "title": "Actions"
        },
        {
            "location": "/overview/concepts/#rollbacks",
            "text": "An experiment may define a sequence of actions that revert what was undone\nduring the experiment.",
            "title": "Rollbacks"
        },
        {
            "location": "/faq/",
            "text": "FAQ\n\u00b6\n\n\nWhat is the Chaos Toolkit?\n\u00b6\n\n\nIt is an open-source software that runs an experiment against your system to\nconfirm or infirm an hypothesis. Colloquially this refers to the \nC\nhaos Engineering Principles\n.\n\n\nWhy do I need to run experiments?\n\u00b6\n\n\nSystems do not live in a vacuum, they are subjected to real world events, some\nexpected and tolerated, others considered as attacks. Waiting for those\nconditions arise does not give the time your team needs to handle, learn and\nadapt to the situation at hand.\n\n\nIn many countries, fire alarm tests are conducted at random in offices so \npeople learn how to react well for the benefit of everyone. Software systems\nshould go through the same exercises. The Chaos Toolkit hopes to make it \nsimple and safe to run experiments like these.\n\n\nEngaging the team and organisation\n\u00b6\n\n\nChaos engineering aims at making you learn from your system. This is not a lone\nactivity but a team, potentially the whole organisation, endeavour.\n\n\nIndeed, a hypothesis you could set the hypothesis \u201cwe have been hacked and lost\nusers sensitive data, we should issue a statement we are doing everything to\nfix the problem within 15mn\u201d. This experiment is not really technical but\norganisational: is the chain of information and command working effectively?\n\n\nIsn\u2019t it testing?\n\u00b6\n\n\nWe do not consider testing and chaos engineering to conflict with each other.\nThey both provide useful and actionable feedback. Where they differ is their\nobjective. \n\n\nTesting is a process that aims at telling you if your application,\nwithin controlled boundaries, runs as expected. \n\n\nChaos engineering is a displine of posing a hypothesis before collecting\nevidence to reject or accept that hypothesis.\n\n\nA test is sort of an hypothesis in its own. The difference lies in the\nexperimental approach of the chaos engineering displine. It asks a question and\nthen observe the system to see if we can answer that question positively or\nnegatively.\n\n\nIncidentaly, some forms of testing are not too dissmilar to a chaos engineering\nexperiment. Say for instance, you run a load testing. Your hypothesis is that\nresponse time should not be impacted under load. By running your experiment,\nyou may answer that question.\n\n\nIsn\u2019t it monitoring?\n\u00b6\n\n\nMuch like chaos engineering is not testing, it should not be conflated with\nmonitoring. If anything, chaos engineering strives for good monitoring for it\nhelps observing the system during the experiment.\n\n\nMonitoring surfaces, informs and may even react to confitions in your system.\nBut this is not answering a question like chaos engineering tries to do.\n\n\nWhy a toolkit?\n\u00b6\n\n\nCurrently, running experiments is not an easy task because the ecosystem is \nstill fairly young. Complex cases have been demonstrated at large corporations\nsuch as Netflix or LinkedIn. Tools such as \nChAP\n or \nSimoorg\n\nare powerful but quite involved.\n\n\nThe Chaos Toolkit aims at providing a more straightforward initial user\nexperience to gain confidence in doing Chaos Engineering experiments. The\nsimpler it gets the greater our cognitive capacity to understand what is going\non.\n\n\nUltimately, the Chaos Toolkit should lead you on the path to using richer tools\nsuch as those cited above.\n\n\nWhat does the Chaos Toolkit do?\n\u00b6\n\n\nThe Chaos Toolkit user-interface is a command line that takes a JSON-encoded\nfile describing the experiment to run. It consists of a sequence of activities\nthe toolkit executes in order to produce a final report. \n\n\nThe activities are of two kinds. Probes observe the system at various point of\nthe experiment. Actions interact with the system to change its state. Usually\nthe action represents the hypothesis you are trying to learn from.\n\n\nWho is behind the Chaos Toolkit?\n\u00b6\n\n\nThe effort was initiated by \nRuss Miles\n and\n\nSylvain Hellegouarch\n, two engineers passionate about fluidity in\ncomplex systems. However, their vision is really to build a\n\nstrong community\n of engineer experiences to feedback\ninto the Chaos Toolkit.\n\n\nWhat is the license of the Chaos Toolkit?\n\u00b6\n\n\nApache 2.0\n.\n\n\nHow can I contribute?\n\u00b6\n\n\nThe Chaos Toolkit welcomes contributors! To help the project, please go to\nthe right project on \nGitHub\n and create an issue. If you feel like it,\ndo not hesitate to fork the repository, make a change and submit a \npull-request to the upstream project for review.",
            "title": "FAQ"
        },
        {
            "location": "/faq/#faq",
            "text": "",
            "title": "FAQ"
        },
        {
            "location": "/faq/#what-is-the-chaos-toolkit",
            "text": "It is an open-source software that runs an experiment against your system to\nconfirm or infirm an hypothesis. Colloquially this refers to the \nC haos Engineering Principles .",
            "title": "What is the Chaos Toolkit?"
        },
        {
            "location": "/faq/#why-do-i-need-to-run-experiments",
            "text": "Systems do not live in a vacuum, they are subjected to real world events, some\nexpected and tolerated, others considered as attacks. Waiting for those\nconditions arise does not give the time your team needs to handle, learn and\nadapt to the situation at hand.  In many countries, fire alarm tests are conducted at random in offices so \npeople learn how to react well for the benefit of everyone. Software systems\nshould go through the same exercises. The Chaos Toolkit hopes to make it \nsimple and safe to run experiments like these.",
            "title": "Why do I need to run experiments?"
        },
        {
            "location": "/faq/#engaging-the-team-and-organisation",
            "text": "Chaos engineering aims at making you learn from your system. This is not a lone\nactivity but a team, potentially the whole organisation, endeavour.  Indeed, a hypothesis you could set the hypothesis \u201cwe have been hacked and lost\nusers sensitive data, we should issue a statement we are doing everything to\nfix the problem within 15mn\u201d. This experiment is not really technical but\norganisational: is the chain of information and command working effectively?",
            "title": "Engaging the team and organisation"
        },
        {
            "location": "/faq/#isnt-it-testing",
            "text": "We do not consider testing and chaos engineering to conflict with each other.\nThey both provide useful and actionable feedback. Where they differ is their\nobjective.   Testing is a process that aims at telling you if your application,\nwithin controlled boundaries, runs as expected.   Chaos engineering is a displine of posing a hypothesis before collecting\nevidence to reject or accept that hypothesis.  A test is sort of an hypothesis in its own. The difference lies in the\nexperimental approach of the chaos engineering displine. It asks a question and\nthen observe the system to see if we can answer that question positively or\nnegatively.  Incidentaly, some forms of testing are not too dissmilar to a chaos engineering\nexperiment. Say for instance, you run a load testing. Your hypothesis is that\nresponse time should not be impacted under load. By running your experiment,\nyou may answer that question.",
            "title": "Isn't it testing?"
        },
        {
            "location": "/faq/#isnt-it-monitoring",
            "text": "Much like chaos engineering is not testing, it should not be conflated with\nmonitoring. If anything, chaos engineering strives for good monitoring for it\nhelps observing the system during the experiment.  Monitoring surfaces, informs and may even react to confitions in your system.\nBut this is not answering a question like chaos engineering tries to do.",
            "title": "Isn't it monitoring?"
        },
        {
            "location": "/faq/#why-a-toolkit",
            "text": "Currently, running experiments is not an easy task because the ecosystem is \nstill fairly young. Complex cases have been demonstrated at large corporations\nsuch as Netflix or LinkedIn. Tools such as  ChAP  or  Simoorg \nare powerful but quite involved.  The Chaos Toolkit aims at providing a more straightforward initial user\nexperience to gain confidence in doing Chaos Engineering experiments. The\nsimpler it gets the greater our cognitive capacity to understand what is going\non.  Ultimately, the Chaos Toolkit should lead you on the path to using richer tools\nsuch as those cited above.",
            "title": "Why a toolkit?"
        },
        {
            "location": "/faq/#what-does-the-chaos-toolkit-do",
            "text": "The Chaos Toolkit user-interface is a command line that takes a JSON-encoded\nfile describing the experiment to run. It consists of a sequence of activities\nthe toolkit executes in order to produce a final report.   The activities are of two kinds. Probes observe the system at various point of\nthe experiment. Actions interact with the system to change its state. Usually\nthe action represents the hypothesis you are trying to learn from.",
            "title": "What does the Chaos Toolkit do?"
        },
        {
            "location": "/faq/#who-is-behind-the-chaos-toolkit",
            "text": "The effort was initiated by  Russ Miles  and Sylvain Hellegouarch , two engineers passionate about fluidity in\ncomplex systems. However, their vision is really to build a strong community  of engineer experiences to feedback\ninto the Chaos Toolkit.",
            "title": "Who is behind the Chaos Toolkit?"
        },
        {
            "location": "/faq/#what-is-the-license-of-the-chaos-toolkit",
            "text": "Apache 2.0 .",
            "title": "What is the license of the Chaos Toolkit?"
        },
        {
            "location": "/faq/#how-can-i-contribute",
            "text": "The Chaos Toolkit welcomes contributors! To help the project, please go to\nthe right project on  GitHub  and create an issue. If you feel like it,\ndo not hesitate to fork the repository, make a change and submit a \npull-request to the upstream project for review.",
            "title": "How can I contribute?"
        },
        {
            "location": "/usage/install/",
            "text": "How to Install the Chaos Toolkit\n\u00b6\n\n\nYou can either install the chaostoolkit command line or run it from a container.\n\n\nThe former expects \nPython 3.5+\n properly setup on your machine while\nthe latter expects a tool implementing the \nOCI 1.0 specification\n, \nsuch as \nDocker\n or \nrunc\n.\n\n\nPython Requirements\n\u00b6\n\n\nThe \nchaostoolkit CLI\n is implemented in Python 3 and this require a\nworking Python installation to run. It officially supports Python 3.5+. It has\nonly been tested against \nCPython\n.\n\n\nInstall Python\n\u00b6\n\n\nInstall Python for your system:\n\n\nOn MacOSX:\n\n\n$ brew install python3\n\n\n\n\nOn Debian/Ubuntu:\n\n\n$ sudo apt-get install python3 python3-venv\n\n\n\n\nOn CentOS:\n\n\n$ sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm\n$ sudo yum -y install python35u\n\n\n\n\nNotice, on CentOS, the Python 3.5 binary is named \npython3.5\n rather than\n\npython3\n as other systems.\n\n\nOn Windows:\n\n\nDownload the latest binary installer\n from the Python website.\n\n\nCreate a virtual environment\n\u00b6\n\n\nDependencies can be installed for your system via its package management but,\nmore likely, you will want to install them yourself in a local virtual\nenvironment.\n\n\n$ python3 -m venv ~/.venvs/chaostk\n\n\n\n\nMake sure to always activate your virtual environment before using it:\n\n\n$ source  ~/.venvs/chaostk/bin/activate\n\n\n\n\n\n\nTip\n\n\nYou may want to use \nvirtualenvwrapper\n to make this process much nicer.\n\n\n\n\nInstall the CLI\n\u00b6\n\n\nInstall \nchaostoolkit\n in the virtual environment as follows:\n\n\n(chaostk) $ pip install chaostoolkit\n\n\n\n\nYou can verify the command was installed by running:\n\n\n(chaostk) $ chaos --version\n\n\n\n\nDownload the container image\n\u00b6\n\n\nYou can run the chaostoolkit from a container rather than install it.\n\n\nFor instance, using \nDocker\n, you can pull the\n\nchaostoolkit image\n:\n\n\n$ docker pull chaostoolkit/chaostoolkit",
            "title": "Install"
        },
        {
            "location": "/usage/install/#how-to-install-the-chaos-toolkit",
            "text": "You can either install the chaostoolkit command line or run it from a container.  The former expects  Python 3.5+  properly setup on your machine while\nthe latter expects a tool implementing the  OCI 1.0 specification , \nsuch as  Docker  or  runc .",
            "title": "How to Install the Chaos Toolkit"
        },
        {
            "location": "/usage/install/#python-requirements",
            "text": "The  chaostoolkit CLI  is implemented in Python 3 and this require a\nworking Python installation to run. It officially supports Python 3.5+. It has\nonly been tested against  CPython .",
            "title": "Python Requirements"
        },
        {
            "location": "/usage/install/#install-python",
            "text": "Install Python for your system:  On MacOSX:  $ brew install python3  On Debian/Ubuntu:  $ sudo apt-get install python3 python3-venv  On CentOS:  $ sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm\n$ sudo yum -y install python35u  Notice, on CentOS, the Python 3.5 binary is named  python3.5  rather than python3  as other systems.  On Windows:  Download the latest binary installer  from the Python website.",
            "title": "Install Python"
        },
        {
            "location": "/usage/install/#create-a-virtual-environment",
            "text": "Dependencies can be installed for your system via its package management but,\nmore likely, you will want to install them yourself in a local virtual\nenvironment.  $ python3 -m venv ~/.venvs/chaostk  Make sure to always activate your virtual environment before using it:  $ source  ~/.venvs/chaostk/bin/activate   Tip  You may want to use  virtualenvwrapper  to make this process much nicer.",
            "title": "Create a virtual environment"
        },
        {
            "location": "/usage/install/#install-the-cli",
            "text": "Install  chaostoolkit  in the virtual environment as follows:  (chaostk) $ pip install chaostoolkit  You can verify the command was installed by running:  (chaostk) $ chaos --version",
            "title": "Install the CLI"
        },
        {
            "location": "/usage/install/#download-the-container-image",
            "text": "You can run the chaostoolkit from a container rather than install it.  For instance, using  Docker , you can pull the chaostoolkit image :  $ docker pull chaostoolkit/chaostoolkit",
            "title": "Download the container image"
        },
        {
            "location": "/usage/upgrade/",
            "text": "How to Upgrade the Chaos Toolkit\n\u00b6\n\n\nUsing pip\n\u00b6\n\n\nYou can update your Chaos Toolkit installation as follows:\n\n\n(chaostk) $ pip install -U chaostoolkit\n\n\n\n\nUsing a container image\n\u00b6\n\n\nIf you downloaded the Docker image of the toolkit, you can pull it again:\n\n\n$ docker pull chaostoolkit/chaostoolkit",
            "title": "Upgrade"
        },
        {
            "location": "/usage/upgrade/#how-to-upgrade-the-chaos-toolkit",
            "text": "",
            "title": "How to Upgrade the Chaos Toolkit"
        },
        {
            "location": "/usage/upgrade/#using-pip",
            "text": "You can update your Chaos Toolkit installation as follows:  (chaostk) $ pip install -U chaostoolkit",
            "title": "Using pip"
        },
        {
            "location": "/usage/upgrade/#using-a-container-image",
            "text": "If you downloaded the Docker image of the toolkit, you can pull it again:  $ docker pull chaostoolkit/chaostoolkit",
            "title": "Using a container image"
        },
        {
            "location": "/usage/running/",
            "text": "Running the Chaos Toolkit\n\u00b6\n\n\nThe \nchaostoolkit\n CLI will display commands it supports as follows:\n\n\n(chaostk) $ chaos --help\n\n\n\n\n\n\nActivate the Python virtual environment\n\n\nIf you run the Chaos Toolkit directly, rather than using a container,\nalways ensure you have activated the virtual environment so that it can\nbe found along its dependencies:\n\n\n$ source ~/.venvs/chaostk/bin/activate\n(chaostk) $\n\n\n\n\n\n\nExecuting a plan\n\u00b6\n\n\nThe main function of the \nchaostoolkit\n CLI is to execute the plan you\ndeclared. This is done as follows:\n\n\n(chaostk) $ chaos run my-plan.json\n\n\n\n\nchaostoolkit\n will log all the steps it follows from your plan.\n\n\nIf you run the command from a container:\n\n\n$ docker run --rm -it \\\n    --user `id -u` \\\n    -v $HOME/.kube:/root/.kube \\\n    -v $HOME/.minikube:$HOME/.minikube \\\n    -v `pwd`:/tmp/chaos \\\n    chaostoolkit/chaostoolkit run /tmp/chaos/my-plan.json\n\n\n\n\nThis command snippet shows how you would share your \nKubernetes\n\n and \nminikube\n configurations if your experiment targets Kubernetes.\n\n\n\n\nBattery not included in the container\n\n\nDepending on your experiment, running as a container may not be as simple\nas it looks because all the extensions (Python packages, commands to run,\nconfig files\u2026) are not included in the base image.\n\n\n\n\nGenerating a report\n\u00b6\n\n\nWhen an experiment completes, a journal is generated and stored in the\n\nchaos-report.json\n file. A PDF or HTML report may be generated from this\njournal using the \nchaostoolkit-reporting\n library.\n\n\nFirst, install that library as per its README. Do note this involves a few\ndependencies, both system-wide and Python-wide.\n\n\nTo generate a PDF report, run the following command:\n\n\n$ chaos report --export-format=pdf chaos-report.json report.pdf\n\n\n\n\nwhile a HTML report will be done as follows:\n\n\n$ chaos report --export-format=html5 chaos-report.json report.html",
            "title": "Run"
        },
        {
            "location": "/usage/running/#running-the-chaos-toolkit",
            "text": "The  chaostoolkit  CLI will display commands it supports as follows:  (chaostk) $ chaos --help   Activate the Python virtual environment  If you run the Chaos Toolkit directly, rather than using a container,\nalways ensure you have activated the virtual environment so that it can\nbe found along its dependencies:  $ source ~/.venvs/chaostk/bin/activate\n(chaostk) $",
            "title": "Running the Chaos Toolkit"
        },
        {
            "location": "/usage/running/#executing-a-plan",
            "text": "The main function of the  chaostoolkit  CLI is to execute the plan you\ndeclared. This is done as follows:  (chaostk) $ chaos run my-plan.json  chaostoolkit  will log all the steps it follows from your plan.  If you run the command from a container:  $ docker run --rm -it \\\n    --user `id -u` \\\n    -v $HOME/.kube:/root/.kube \\\n    -v $HOME/.minikube:$HOME/.minikube \\\n    -v `pwd`:/tmp/chaos \\\n    chaostoolkit/chaostoolkit run /tmp/chaos/my-plan.json  This command snippet shows how you would share your  Kubernetes \n and  minikube  configurations if your experiment targets Kubernetes.   Battery not included in the container  Depending on your experiment, running as a container may not be as simple\nas it looks because all the extensions (Python packages, commands to run,\nconfig files\u2026) are not included in the base image.",
            "title": "Executing a plan"
        },
        {
            "location": "/usage/running/#generating-a-report",
            "text": "When an experiment completes, a journal is generated and stored in the chaos-report.json  file. A PDF or HTML report may be generated from this\njournal using the  chaostoolkit-reporting  library.  First, install that library as per its README. Do note this involves a few\ndependencies, both system-wide and Python-wide.  To generate a PDF report, run the following command:  $ chaos report --export-format=pdf chaos-report.json report.pdf  while a HTML report will be done as follows:  $ chaos report --export-format=html5 chaos-report.json report.html",
            "title": "Generating a report"
        },
        {
            "location": "/usage/latest/",
            "text": "The latest release of the \nchaostoolkit\n is \n\n0.6.0\n.\n\n\nYou can upgrade as follows:\n\n\n$\n pip install -U chaostoolkit\n\n\n\n\nPlease, read the\n\nCHANGELOG\n\nfor more information regarding that release.",
            "title": "Latest Release"
        },
        {
            "location": "/tutorials/create-run-first-experiment/",
            "text": "Creating and Running your first Chaos Experiment\n\u00b6\n\n\nThis walkthrough will drive you the basics of writing your very first\nexperiment.\n\n\nDefine your hypothesis\n\u00b6\n\n\nBefore you start writing code, you need to define your hypthesis. What is it\nyou are trying to confirm or infirm?\n\n\nThere are various ways to come up with an hypothesis:\n\n\n\n\na real scenario that you and your team did not fully get a chance to learn\n  from while in emergency mode. Retrospective sessions in agile teams may be\n  a great starting point\n\n\nimpact mapping\n is another strategy to let the team bubble\n  up relevant scenarios\n\n\nyour existing disaster recovery playbooks could be turned into experiments\n  that are actively applied against the system\n\n\n\n\nHowever you come up with your hypothesis, make sure you can analyse the \nresult so keep its scope and objective simple and comprehensible.\n\n\nGet the requirements\n\u00b6\n\n\nOften, an experiment involves fairly specific access to observe or interact\nwith the system. Make sure you can gather the right permissions and people on\nboard.\n\n\nA first experiment: a missing file\n\u00b6\n\n\nLet\u2019s say we have a service that polls a local file every second to see if new\ncontent was added for processing. Development made the assumption the file\nwould always be there and did not write a failure code path.\n\n\nOur hypothesis is that the service should not break but simply try again until\nthe file comes back. \n\n\nOur experiment should try that hypothesis to see where our system stands.\n\n\nBelow is the code of our service as it is now:\n\n\n# -*- coding: utf-8 -*-\n\n\nfrom\n \ndatetime\n \nimport\n \ndatetime\n\n\nimport\n \nio\n\n\nimport\n \ntime\n\n\nimport\n \nthreading\n\n\nfrom\n \nwsgiref.validate\n \nimport\n \nvalidator\n\n\nfrom\n \nwsgiref.simple_server\n \nimport\n \nmake_server\n\n\n\nEXCHANGE_FILE\n \n=\n \n\"./exchange.dat\"\n\n\n\n\ndef\n \nupdate_exchange_file\n():\n\n    \n\"\"\"\n\n\n    Writes the current date and time every 10 seconds into the exchange file.\n\n\n\n    The file is created if it does not exist.\n\n\n    \"\"\"\n\n    \nprint\n(\n\"Will update to exchange file\"\n)\n\n    \nwhile\n \nTrue\n:\n\n        \nwith\n \nio\n.\nopen\n(\nEXCHANGE_FILE\n,\n \n\"w\"\n)\n \nas\n \nf\n:\n\n            \nf\n.\nwrite\n(\ndatetime\n.\nnow\n()\n.\nisoformat\n())\n\n        \ntime\n.\nsleep\n(\n10\n)\n\n\n\n\ndef\n \nsimple_app\n(\nenviron\n,\n \nstart_response\n):\n\n    \n\"\"\"\n\n\n    Read the content of the exchange file and return it.\n\n\n    \"\"\"\n\n    \nstart_response\n(\n'200 OK'\n,\n \n[(\n'Content-type'\n,\n \n'text/plain'\n)])\n\n    \nwith\n \nio\n.\nopen\n(\nEXCHANGE_FILE\n)\n \nas\n \nf\n:\n\n        \nreturn\n \n[\nf\n.\nread\n()\n.\nencode\n(\n'utf-8'\n)]\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nt\n \n=\n \nthreading\n.\nThread\n(\ntarget\n=\nupdate_exchange_file\n)\n\n    \nt\n.\nstart\n()\n\n\n    \nhttpd\n \n=\n \nmake_server\n(\n''\n,\n \n8080\n,\n \nsimple_app\n)\n\n    \nprint\n(\n\"Listening on port 8080....\"\n)\n\n\n    \ntry\n:\n\n        \nhttpd\n.\nserve_forever\n()\n\n    \nexcept\n \nKeyboardInterrupt\n:\n\n        \nhttpd\n.\nshutdown\n()\n\n        \nt\n.\njoin\n(\ntimeout\n=\n1\n)\n\n\n\n\n\nThe code is simple for the purpose of this tutorial. As you can see, we declare\na simple function that reads a file and returns its content when called.\n\n\nA background thread function writes the current data to that file every 10\nseconds.\n\n\nNotice how we do not check the file exists before reading it soo it is likely\nthis can fail.\n\n\nRun this service from another terminal as follows:\n\n\n$ python service.py\n\n\n\n\n\n\nTip\n\n\nThe \ncode of this tutorial\n can be found along side this\ndocumentation.\n\n\n\n\nDeclare your experiment\n\u00b6\n\n\nBelow is the experiment for our hypothesis:\n\n\n{\n\n    \n\"title\"\n:\n \n\"Does our service tolerate the loss of its exchange file?\"\n,\n\n    \n\"description\"\n:\n \n\"Our service reads data from an exchange file, can it support that file disappearing?\"\n,\n\n    \n\"tags\"\n:\n \n[\n\n        \n\"tutorial\"\n,\n\n        \n\"filesystem\"\n\n    \n],\n\n    \n\"steady-state-hypothesis\"\n:\n \n{\n\n        \n\"title\"\n:\n \n\"The exchange file must exist\"\n,\n\n        \n\"probes\"\n:\n \n[\n\n            \n{\n\n                \n\"type\"\n:\n \n\"probe\"\n,\n\n                \n\"name\"\n:\n \n\"exchange-file-exists\"\n,\n\n                \n\"tolerance\"\n:\n \ntrue\n,\n\n                \n\"provider\"\n:\n \n{\n\n                    \n\"type\"\n:\n \n\"python\"\n,\n\n                    \n\"module\"\n:\n \n\"os.path\"\n,\n\n                    \n\"func\"\n:\n \n\"exists\"\n,\n\n                    \n\"arguments\"\n:\n \n{\n\n                        \n\"path\"\n:\n \n\"./exchange.dat\"\n\n                    \n}\n\n                \n}\n\n            \n}\n\n        \n]\n\n    \n},\n\n    \n\"method\"\n:\n \n[\n\n        \n{\n\n            \n\"name\"\n:\n \n\"move-exchange-file\"\n,\n\n            \n\"type\"\n:\n \n\"action\"\n,\n\n            \n\"provider\"\n:\n \n{\n\n                \n\"type\"\n:\n \n\"python\"\n,\n\n                \n\"module\"\n:\n \n\"os\"\n,\n\n                \n\"func\"\n:\n \n\"rename\"\n,\n\n                \n\"arguments\"\n:\n \n{\n\n                    \n\"src\"\n:\n \n\"./exchange.dat\"\n,\n\n                    \n\"dst\"\n:\n \n\"./exchange.dat.old\"\n\n                \n}\n\n            \n}\n\n        \n},\n\n        \n{\n\n            \n\"type\"\n:\n \n\"probe\"\n,\n\n            \n\"name\"\n:\n \n\"service-is-unavailable\"\n,\n\n            \n\"provider\"\n:\n \n{\n\n                \n\"type\"\n:\n \n\"http\"\n,\n\n                \n\"expected_status\"\n:\n \n503\n,\n\n                \n\"url\"\n:\n \n\"http://localhost:8080/\"\n\n            \n}\n\n        \n}\n\n    \n]\n\n\n}\n\n\n\n\n\nThi experiment shows the bricks of encoding your experiment with Chaos Toolkit.\nOnce you have provided various metadata, you tell the chaos Toolkit the\nactivitites it ought to play for us.\n\n\nUsually we start with a probe that tells us the steady state of our system. In\nthis case, we simply ensure the exchange file exists. That tells us the\nservice has its expectation met.\n\n\nNext, we create the conditions of our hypothesis by pretending our file does not\nexist any longer by renaming it.\n\n\nFinally, we query our service over HTTP and expect a response that does not\nindicate the service is unexpectedly broken.\n\n\nAn experiment is made of any numbering of those activities - probes and actions.\nNote that an action can also have its own probes for a specific inspection\nbefore and after the action was applied.\n\n\nThe steady probe and the action are implemented by using Python functions while\nthe last probe performs a HTTP call on your behalf. Please review the\n\ndocumentation\n for other supported implementations.\n\n\nRun your experiment\n\u00b6\n\n\nTo run the experiment, use the \nchaostoolkit\n CLI as follows:\n\n\n(\nchaostk\n)\n $ chaos --change-dir sources/shared/snippets/tutorials run experiment.json\n\n[\n2017\n-12-17 \n20\n:48:27 INFO\n]\n Validating experiment\n's syntax\n\n\n[2017-12-17 20:48:27 INFO] Experiment looks valid\n\n\n[2017-12-17 20:48:27 INFO] Running experiment: Does our service tolerate the loss of its exchange file?\n\n\n[2017-12-17 20:48:27 INFO] Steady state hypothesis: The exchange file must exist\n\n\n[2017-12-17 20:48:27 INFO] Probe: exchange-file-exists\n\n\n[2017-12-17 20:48:27 INFO] Steady state hypothesis is met, we can carry on!\n\n\n[2017-12-17 20:48:27 INFO] Action: move-exchange-file\n\n\n[2017-12-17 20:48:27 INFO] Probe: service-is-unavailable\n\n\n[2017-12-17 20:48:27 ERROR]   => failed: HTTP call failed with code 500 (expected 503): A server error occurred.  Please contact the administrator.\n\n\n[2017-12-17 20:48:27 INFO] Let'\ns rollback...\n\n[\n2017\n-12-17 \n20\n:48:27 INFO\n]\n No declared rollbacks, let\n'\ns move on.\n\n[\n2017\n-12-17 \n20\n:48:27 INFO\n]\n Experiment ended with status: completed\n\n\n\n\nNotice the error towards the end, it tells us the service failed with an\nunexpected error.\n\n\nAt this stage, you need to pause and analyse the results of this experiment\nto decide what to do next.\n\n\nFix your service\n\u00b6\n\n\nWhen we ran our service, it broke because the file was not found when read.\nFixing it can take various aspects, we could ensure the file can never be\nremoved through permissions or locking. Or we could also tolerate such \nfailure but let the service return a more appropriate error message in that\ncase.\n\n\nThis is how we are going to fix it in this tutorial:\n\n\n# -*- coding: utf-8 -*-\n\n\nfrom\n \ndatetime\n \nimport\n \ndatetime\n\n\nimport\n \nio\n\n\nimport\n \nos.path\n\n\nimport\n \ntime\n\n\nimport\n \nthreading\n\n\nfrom\n \nwsgiref.validate\n \nimport\n \nvalidator\n\n\nfrom\n \nwsgiref.simple_server\n \nimport\n \nmake_server\n\n\n\nEXCHANGE_FILE\n \n=\n \n\"./exchange.dat\"\n\n\n\n\ndef\n \nupdate_exchange_file\n():\n\n    \n\"\"\"\n\n\n    Writes the current date and time every 10 seconds into the exchange file.\n\n\n\n    The file is created if it does not exist.\n\n\n    \"\"\"\n\n    \nprint\n(\n\"Will update to exchange file\"\n)\n\n    \nwhile\n \nTrue\n:\n\n        \nwith\n \nio\n.\nopen\n(\nEXCHANGE_FILE\n,\n \n\"w\"\n)\n \nas\n \nf\n:\n\n            \nf\n.\nwrite\n(\ndatetime\n.\nnow\n()\n.\nisoformat\n())\n\n        \ntime\n.\nsleep\n(\n10\n)\n\n\n\n\ndef\n \nsimple_app\n(\nenviron\n,\n \nstart_response\n):\n\n    \n\"\"\"\n\n\n    Read the content of the exchange file and return it.\n\n\n    \"\"\"\n\n    \nif\n \nnot\n \nos\n.\npath\n.\nexists\n(\nEXCHANGE_FILE\n):\n\n        \nstart_response\n(\n\n            \n'503 Service Unavailable'\n,\n\n            \n[(\n'Content-type'\n,\n \n'text/plain'\n)]\n\n        \n)\n\n        \nreturn\n \n[\nb\n'Exchange file is not ready'\n]\n\n\n    \nstart_response\n(\n'200 OK'\n,\n \n[(\n'Content-type'\n,\n \n'text/plain'\n)])\n\n    \nwith\n \nio\n.\nopen\n(\nEXCHANGE_FILE\n)\n \nas\n \nf\n:\n\n        \nreturn\n \n[\nf\n.\nread\n()\n.\nencode\n(\n'utf-8'\n)]\n\n\n\n\nif\n \n__name__\n \n==\n \n'__main__'\n:\n\n    \nt\n \n=\n \nthreading\n.\nThread\n(\ntarget\n=\nupdate_exchange_file\n)\n\n    \nt\n.\nstart\n()\n\n\n    \nhttpd\n \n=\n \nmake_server\n(\n''\n,\n \n8080\n,\n \nsimple_app\n)\n\n    \nprint\n(\n\"Listening on port 8080....\"\n)\n\n\n    \ntry\n:\n\n        \nhttpd\n.\nserve_forever\n()\n\n    \nexcept\n \nKeyboardInterrupt\n:\n\n        \nhttpd\n.\nshutdown\n()\n\n        \nt\n.\njoin\n(\ntimeout\n=\n1\n)\n\n\n\n\n\nThe service looks very similar but notice how we check the file indeed exists\nbefore reading it. When it does not exist, we return a more useful \n[503 Service Unavailable][503] error that a consumer could interpret as\n\u201ctry again later\u201d.\n\n\nNote, that we understand a race condition may happen between the time we\nchecked for the path and the time we read content at that location. We keep\nit easy for the benefit of this tutorial.\n\n\nRun your experiment again\n\u00b6\n\n\nLet\u2019s run again our experiment now that we have fixed and restart our service:\n\n\n(\nchaostk\n)\n $ chaos --change-dir sources/shared/snippets/tutorials run experiment.json\n\n[\n2017\n-12-17 \n20\n:49:41 INFO\n]\n Validating experiment\n's syntax\n\n\n[2017-12-17 20:49:41 INFO] Experiment looks valid\n\n\n[2017-12-17 20:49:41 INFO] Running experiment: Does our service tolerate the loss of its exchange file?\n\n\n[2017-12-17 20:49:41 INFO] Steady state hypothesis: The exchange file must exist\n\n\n[2017-12-17 20:49:41 INFO] Probe: exchange-file-exists\n\n\n[2017-12-17 20:49:41 INFO] Steady state hypothesis is met, we can carry on!\n\n\n[2017-12-17 20:49:41 INFO] Action: move-exchange-file\n\n\n[2017-12-17 20:49:41 INFO] Probe: service-is-unavailable\n\n\n[2017-12-17 20:49:41 INFO] Let'\ns rollback...\n\n[\n2017\n-12-17 \n20\n:49:41 INFO\n]\n No declared rollbacks, let\n'\ns move on.\n\n[\n2017\n-12-17 \n20\n:49:41 INFO\n]\n Experiment ended with status: completed\n\n\n\n\nNotice we do not see the error any more because the probe matched its\nexpectation.\n\n\nGo further\n\u00b6\n\n\nIn this tutorial, you first approached the Chaos Toolkit to apply experiments\nagainst your system to confirm or infirm your initial hypothesis.\n\n\nThe example is basic on purpose but shows the simplicity of exercising\nthe \nchaos engineering principles\n to learn and adapt your system.\n\n\nThe Chaos Toolkit does not limit itself to local use-cases like this one and\noffers the possibility to interact with any system through remote API calls.\n\n\nPlease \njoin us\n on the Chaos Toolkit community to continue your\nexploration.",
            "title": "Creating and Running your first Chaos Experiment"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#creating-and-running-your-first-chaos-experiment",
            "text": "This walkthrough will drive you the basics of writing your very first\nexperiment.",
            "title": "Creating and Running your first Chaos Experiment"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#define-your-hypothesis",
            "text": "Before you start writing code, you need to define your hypthesis. What is it\nyou are trying to confirm or infirm?  There are various ways to come up with an hypothesis:   a real scenario that you and your team did not fully get a chance to learn\n  from while in emergency mode. Retrospective sessions in agile teams may be\n  a great starting point  impact mapping  is another strategy to let the team bubble\n  up relevant scenarios  your existing disaster recovery playbooks could be turned into experiments\n  that are actively applied against the system   However you come up with your hypothesis, make sure you can analyse the \nresult so keep its scope and objective simple and comprehensible.",
            "title": "Define your hypothesis"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#get-the-requirements",
            "text": "Often, an experiment involves fairly specific access to observe or interact\nwith the system. Make sure you can gather the right permissions and people on\nboard.",
            "title": "Get the requirements"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#a-first-experiment-a-missing-file",
            "text": "Let\u2019s say we have a service that polls a local file every second to see if new\ncontent was added for processing. Development made the assumption the file\nwould always be there and did not write a failure code path.  Our hypothesis is that the service should not break but simply try again until\nthe file comes back.   Our experiment should try that hypothesis to see where our system stands.  Below is the code of our service as it is now:  # -*- coding: utf-8 -*-  from   datetime   import   datetime  import   io  import   time  import   threading  from   wsgiref.validate   import   validator  from   wsgiref.simple_server   import   make_server  EXCHANGE_FILE   =   \"./exchange.dat\"  def   update_exchange_file (): \n     \"\"\"      Writes the current date and time every 10 seconds into the exchange file.      The file is created if it does not exist.      \"\"\" \n     print ( \"Will update to exchange file\" ) \n     while   True : \n         with   io . open ( EXCHANGE_FILE ,   \"w\" )   as   f : \n             f . write ( datetime . now () . isoformat ()) \n         time . sleep ( 10 )  def   simple_app ( environ ,   start_response ): \n     \"\"\"      Read the content of the exchange file and return it.      \"\"\" \n     start_response ( '200 OK' ,   [( 'Content-type' ,   'text/plain' )]) \n     with   io . open ( EXCHANGE_FILE )   as   f : \n         return   [ f . read () . encode ( 'utf-8' )]  if   __name__   ==   '__main__' : \n     t   =   threading . Thread ( target = update_exchange_file ) \n     t . start () \n\n     httpd   =   make_server ( '' ,   8080 ,   simple_app ) \n     print ( \"Listening on port 8080....\" ) \n\n     try : \n         httpd . serve_forever () \n     except   KeyboardInterrupt : \n         httpd . shutdown () \n         t . join ( timeout = 1 )   The code is simple for the purpose of this tutorial. As you can see, we declare\na simple function that reads a file and returns its content when called.  A background thread function writes the current data to that file every 10\nseconds.  Notice how we do not check the file exists before reading it soo it is likely\nthis can fail.  Run this service from another terminal as follows:  $ python service.py   Tip  The  code of this tutorial  can be found along side this\ndocumentation.",
            "title": "A first experiment: a missing file"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#declare-your-experiment",
            "text": "Below is the experiment for our hypothesis:  { \n     \"title\" :   \"Does our service tolerate the loss of its exchange file?\" , \n     \"description\" :   \"Our service reads data from an exchange file, can it support that file disappearing?\" , \n     \"tags\" :   [ \n         \"tutorial\" , \n         \"filesystem\" \n     ], \n     \"steady-state-hypothesis\" :   { \n         \"title\" :   \"The exchange file must exist\" , \n         \"probes\" :   [ \n             { \n                 \"type\" :   \"probe\" , \n                 \"name\" :   \"exchange-file-exists\" , \n                 \"tolerance\" :   true , \n                 \"provider\" :   { \n                     \"type\" :   \"python\" , \n                     \"module\" :   \"os.path\" , \n                     \"func\" :   \"exists\" , \n                     \"arguments\" :   { \n                         \"path\" :   \"./exchange.dat\" \n                     } \n                 } \n             } \n         ] \n     }, \n     \"method\" :   [ \n         { \n             \"name\" :   \"move-exchange-file\" , \n             \"type\" :   \"action\" , \n             \"provider\" :   { \n                 \"type\" :   \"python\" , \n                 \"module\" :   \"os\" , \n                 \"func\" :   \"rename\" , \n                 \"arguments\" :   { \n                     \"src\" :   \"./exchange.dat\" , \n                     \"dst\" :   \"./exchange.dat.old\" \n                 } \n             } \n         }, \n         { \n             \"type\" :   \"probe\" , \n             \"name\" :   \"service-is-unavailable\" , \n             \"provider\" :   { \n                 \"type\" :   \"http\" , \n                 \"expected_status\" :   503 , \n                 \"url\" :   \"http://localhost:8080/\" \n             } \n         } \n     ]  }   Thi experiment shows the bricks of encoding your experiment with Chaos Toolkit.\nOnce you have provided various metadata, you tell the chaos Toolkit the\nactivitites it ought to play for us.  Usually we start with a probe that tells us the steady state of our system. In\nthis case, we simply ensure the exchange file exists. That tells us the\nservice has its expectation met.  Next, we create the conditions of our hypothesis by pretending our file does not\nexist any longer by renaming it.  Finally, we query our service over HTTP and expect a response that does not\nindicate the service is unexpectedly broken.  An experiment is made of any numbering of those activities - probes and actions.\nNote that an action can also have its own probes for a specific inspection\nbefore and after the action was applied.  The steady probe and the action are implemented by using Python functions while\nthe last probe performs a HTTP call on your behalf. Please review the documentation  for other supported implementations.",
            "title": "Declare your experiment"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#run-your-experiment",
            "text": "To run the experiment, use the  chaostoolkit  CLI as follows:  ( chaostk )  $ chaos --change-dir sources/shared/snippets/tutorials run experiment.json [ 2017 -12-17  20 :48:27 INFO ]  Validating experiment 's syntax  [2017-12-17 20:48:27 INFO] Experiment looks valid  [2017-12-17 20:48:27 INFO] Running experiment: Does our service tolerate the loss of its exchange file?  [2017-12-17 20:48:27 INFO] Steady state hypothesis: The exchange file must exist  [2017-12-17 20:48:27 INFO] Probe: exchange-file-exists  [2017-12-17 20:48:27 INFO] Steady state hypothesis is met, we can carry on!  [2017-12-17 20:48:27 INFO] Action: move-exchange-file  [2017-12-17 20:48:27 INFO] Probe: service-is-unavailable  [2017-12-17 20:48:27 ERROR]   => failed: HTTP call failed with code 500 (expected 503): A server error occurred.  Please contact the administrator.  [2017-12-17 20:48:27 INFO] Let' s rollback... [ 2017 -12-17  20 :48:27 INFO ]  No declared rollbacks, let ' s move on. [ 2017 -12-17  20 :48:27 INFO ]  Experiment ended with status: completed  Notice the error towards the end, it tells us the service failed with an\nunexpected error.  At this stage, you need to pause and analyse the results of this experiment\nto decide what to do next.",
            "title": "Run your experiment"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#fix-your-service",
            "text": "When we ran our service, it broke because the file was not found when read.\nFixing it can take various aspects, we could ensure the file can never be\nremoved through permissions or locking. Or we could also tolerate such \nfailure but let the service return a more appropriate error message in that\ncase.  This is how we are going to fix it in this tutorial:  # -*- coding: utf-8 -*-  from   datetime   import   datetime  import   io  import   os.path  import   time  import   threading  from   wsgiref.validate   import   validator  from   wsgiref.simple_server   import   make_server  EXCHANGE_FILE   =   \"./exchange.dat\"  def   update_exchange_file (): \n     \"\"\"      Writes the current date and time every 10 seconds into the exchange file.      The file is created if it does not exist.      \"\"\" \n     print ( \"Will update to exchange file\" ) \n     while   True : \n         with   io . open ( EXCHANGE_FILE ,   \"w\" )   as   f : \n             f . write ( datetime . now () . isoformat ()) \n         time . sleep ( 10 )  def   simple_app ( environ ,   start_response ): \n     \"\"\"      Read the content of the exchange file and return it.      \"\"\" \n     if   not   os . path . exists ( EXCHANGE_FILE ): \n         start_response ( \n             '503 Service Unavailable' , \n             [( 'Content-type' ,   'text/plain' )] \n         ) \n         return   [ b 'Exchange file is not ready' ] \n\n     start_response ( '200 OK' ,   [( 'Content-type' ,   'text/plain' )]) \n     with   io . open ( EXCHANGE_FILE )   as   f : \n         return   [ f . read () . encode ( 'utf-8' )]  if   __name__   ==   '__main__' : \n     t   =   threading . Thread ( target = update_exchange_file ) \n     t . start () \n\n     httpd   =   make_server ( '' ,   8080 ,   simple_app ) \n     print ( \"Listening on port 8080....\" ) \n\n     try : \n         httpd . serve_forever () \n     except   KeyboardInterrupt : \n         httpd . shutdown () \n         t . join ( timeout = 1 )   The service looks very similar but notice how we check the file indeed exists\nbefore reading it. When it does not exist, we return a more useful \n[503 Service Unavailable][503] error that a consumer could interpret as\n\u201ctry again later\u201d.  Note, that we understand a race condition may happen between the time we\nchecked for the path and the time we read content at that location. We keep\nit easy for the benefit of this tutorial.",
            "title": "Fix your service"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#run-your-experiment-again",
            "text": "Let\u2019s run again our experiment now that we have fixed and restart our service:  ( chaostk )  $ chaos --change-dir sources/shared/snippets/tutorials run experiment.json [ 2017 -12-17  20 :49:41 INFO ]  Validating experiment 's syntax  [2017-12-17 20:49:41 INFO] Experiment looks valid  [2017-12-17 20:49:41 INFO] Running experiment: Does our service tolerate the loss of its exchange file?  [2017-12-17 20:49:41 INFO] Steady state hypothesis: The exchange file must exist  [2017-12-17 20:49:41 INFO] Probe: exchange-file-exists  [2017-12-17 20:49:41 INFO] Steady state hypothesis is met, we can carry on!  [2017-12-17 20:49:41 INFO] Action: move-exchange-file  [2017-12-17 20:49:41 INFO] Probe: service-is-unavailable  [2017-12-17 20:49:41 INFO] Let' s rollback... [ 2017 -12-17  20 :49:41 INFO ]  No declared rollbacks, let ' s move on. [ 2017 -12-17  20 :49:41 INFO ]  Experiment ended with status: completed  Notice we do not see the error any more because the probe matched its\nexpectation.",
            "title": "Run your experiment again"
        },
        {
            "location": "/tutorials/create-run-first-experiment/#go-further",
            "text": "In this tutorial, you first approached the Chaos Toolkit to apply experiments\nagainst your system to confirm or infirm your initial hypothesis.  The example is basic on purpose but shows the simplicity of exercising\nthe  chaos engineering principles  to learn and adapt your system.  The Chaos Toolkit does not limit itself to local use-cases like this one and\noffers the possibility to interact with any system through remote API calls.  Please  join us  on the Chaos Toolkit community to continue your\nexploration.",
            "title": "Go further"
        },
        {
            "location": "/tutorials/custom-extension-probes/",
            "text": "Create a new Chaos Toolkit Extension with Custom Probes\n\u00b6\n\n\nThe Chaos Toolkit can be extended to observe specific information about your system, using probes, as well as provide custom actions that can be used from within your experiment\u2019s method. \n\n\nIn this tutorial you will learn how to create a new custom Python extension to the Chaos Toolkit to expose some custom probes in order to gather more data from the observability of your system. This is done so that you can customize how you specify your Steady State Hypothesis as well as providing a custom means of gathering additional data during your experiment execution.\n\n\n\n\nNote\n\n\nThe next tutorial in this series will show how to construct custom actions as well so that those can be used within your Chaos experiment\u2019s method.\n\n\n\n\nIntroducing the Extension\n\u00b6\n\n\nThe extension we are going to create here will be a simple integration with \nPrometheus\n to provide a couple of new probes that we can use in our Chaos Engineering experiments. The probes will be:\n\n\n\n\nquery\n - Runs an instant query against a \nPrometheus\n server and returns its result as-is.\n\n\nquery_interval\n - Runs a range query against a \nPrometheus\n server and returns its result as-is.\n\n\n\n\nThe \nquery\n probe will naturally, if specified with some tolerances, be a good candidate for use as part of a \nStead State Hypothesis\n as well as a general-purpose probe.\n\n\n\n\nNote\n\n\nThere is already a \nchaostoolkit-prometheus extension project\n and the tutorial shown here is based on how it was originally developed.\n\n\n\n\nCreating a new Extension based on the Template project\n\u00b6\n\n\nTo create a new project based on the Chaos Toolkit Extension Template grab the \nlatest released code for the template\n and place this code in a new project that ideally follows the naming convention of \nchaostoolkit-<your extension name here>\n. \n\n\nFor our purposes we will create a new project based on the templates code called \nchaostoolkit-prometheus\n. You will also need to change any references to \nchaosext\n to the name of your new extension and its associated package. Once you have made those changes you should have a project contents that looks like the following:\n\n\n.\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 MANIFEST.in\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 chaosprometheus\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 probes.py\n\u251c\u2500\u2500 ci.bash\n\u251c\u2500\u2500 coverage.xml\n\u251c\u2500\u2500 junit-test-results.xml\n\u251c\u2500\u2500 pytest.ini\n\u251c\u2500\u2500 requirements-dev.txt\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 tests\n    \u2514\u2500\u2500 test_probes.py\n\n\n\n\n(Optional) Create a virtual environment for your new extension\n\u00b6\n\n\nA Python virtual environment is a great way of managing your project\u2019s dependencies. We recommend creating a virtual environment for your new Chaos Toolkit extension project using the following command:\n\n\n> python3 -m venv ~/.venvs/<your-ext-venv>\n\n\n\n\nSetup your extensions dependencies\n\u00b6\n\n\nNow you can added dependencies into the \nrequirements-dev.txt\n, for dependencies you only need at development time, and \nrequirements.txt\n, for dependencies you only need at runtime. We need a few extra dependencies to work with Prometheus:\n\n\nlogzero\nrequests\ndateparser\nmaya\n\n\n\n\nBriefly, these dependencies are useful because they:\n\n\n\n\nlogzero\n - Makes it simpler to add logging to the Python extension. Also it is what the core Chaos Toolkit uses so this is consistent.\n\n\nrequests\n - Adds an HTTP client for working against the Prometheus API\n\n\ndateparser\n - Provides support for manupulating dates and time, including generalinh time/date ranges.\n\n\nmaya\n - Provides support for serialising dates and times to and from the dates and times needed for the Prometheus API.\n\n\n\n\nWith those changes made you can now install your dependencies for your development work using the following command:\n\n\n> python setup.py develop\n\n\n\n\nCreate tests for the new probes\n\u00b6\n\n\nYou\u2019re now ready to start coding up your new probes for Prometheus. Using TDD, you can construct tests that exercise the success and failure scenarios of the expected probe functions in a \ntests/test_probes.py\n module:\n\n\n# -*- coding: utf-8 -*-\n\n\nimport\n \npytest\n\n\nimport\n \nrequests\n\n\nimport\n \nrequests_mock\n\n\n\nfrom\n \nchaoslib.exceptions\n \nimport\n \nFailedActivity\n\n\nfrom\n \nchaosprometheus.probes\n \nimport\n \nquery\n,\n \nquery_interval\n\n\n\n\ndef\n \ntest_failed_parsing_when_date\n():\n\n    \nwith\n \npytest\n.\nraises\n(\nFailedActivity\n)\n \nas\n \nexc\n:\n\n        \nquery\n(\n\"request_processing_seconds_count\"\n,\n \nwhen\n=\n\"2 mns ago\"\n)\n\n    \nassert\n \n\"failed to parse '2 mns ago'\"\n \nin\n \nstr\n(\nexc\n)\n\n\n\n\ndef\n \ntest_failed_parsing_start_date\n():\n\n    \nwith\n \npytest\n.\nraises\n(\nFailedActivity\n)\n \nas\n \nexc\n:\n\n        \nquery_interval\n(\n\"request_processing_seconds_count\"\n,\n \nstart\n=\n\"2 mns ago\"\n,\n\n                       \nend\n=\n\"now\"\n)\n\n    \nassert\n \n\"failed to parse '2 mns ago'\"\n \nin\n \nstr\n(\nexc\n)\n\n\n\n\ndef\n \ntest_failed_parsing_end_date\n():\n\n    \nwith\n \npytest\n.\nraises\n(\nFailedActivity\n)\n \nas\n \nexc\n:\n\n        \nquery_interval\n(\n\"request_processing_seconds_count\"\n,\n\n                       \nstart\n=\n\"2 minutes ago\"\n,\n \nend\n=\n\"right now\"\n)\n\n    \nassert\n \n\"failed to parse 'right now'\"\n \nin\n \nstr\n(\nexc\n)\n\n\n\n\ndef\n \ntest_failed_running_query\n():\n\n    \nwith\n \nrequests_mock\n.\nmock\n()\n \nas\n \nm\n:\n\n        \nm\n.\nget\n(\n\n            \n\"http://localhost:9090/api/v1/query_range\"\n,\n \nstatus_code\n=\n400\n,\n\n            \ntext\n=\n\"Bad Request\"\n)\n\n\n        \nwith\n \npytest\n.\nraises\n(\nFailedActivity\n)\n \nas\n \nex\n:\n\n            \nquery_interval\n(\nquery\n=\n\"request_processing_seconds_count\"\n,\n\n                           \nstart\n=\n\"2 minutes ago\"\n,\n \nend\n=\n\"now\"\n)\n\n    \nassert\n \n\"Prometheus query\"\n \nin\n \nstr\n(\nex\n)\n\n\n\n\n\nCreate the new Probes\n\u00b6\n\n\nFinally it\u2019s time to create the new probes to meet the needs as specified by your tests in a file called \nchaosprometheus/probes.py\n:\n\n\n# -*- coding: utf-8 -*-\n\n\nfrom\n \ntyping\n \nimport\n \nAny\n,\n \nDict\n\n\n\nimport\n \ndateparser\n\n\nfrom\n \nlogzero\n \nimport\n \nlogger\n\n\nimport\n \nmaya\n\n\nimport\n \nrequests\n\n\n\nfrom\n \nchaoslib.exceptions\n \nimport\n \nFailedActivity\n\n\nfrom\n \nchaoslib.types\n \nimport\n \nConfiguration\n,\n \nSecrets\n\n\n\n__all__\n \n=\n \n[\n\"query\"\n,\n \n\"query_interval\"\n]\n\n\n\n\ndef\n \nquery\n(\nquery\n:\n \nstr\n,\n \nwhen\n:\n \nstr\n \n=\n \nNone\n,\n \ntimeout\n:\n \nfloat\n \n=\n \nNone\n,\n\n          \nconfiguration\n:\n \nConfiguration\n \n=\n \nNone\n,\n\n          \nsecrets\n:\n \nSecrets\n \n=\n \nNone\n)\n \n->\n \nDict\n[\nstr\n,\n \nAny\n]:\n\n    \n\"\"\"\n\n\n    Run an instant query against a Prometheus server and returns its result\n\n\n    as-is.\n\n\n    \"\"\"\n\n    \nbase\n \n=\n \n(\nconfiguration\n \nor\n \n{})\n.\nget\n(\n\n        \n\"prometheus_base_url\"\n,\n \n\"http://localhost:9090\"\n)\n\n    \nurl\n \n=\n \n\"{base}/api/v1/query\"\n.\nformat\n(\nbase\n=\nbase\n)\n\n\n    \nparams\n \n=\n \n{\n\"query\"\n:\n \nquery\n}\n\n\n    \nif\n \ntimeout\n \nis\n \nnot\n \nNone\n:\n\n        \nparams\n[\n\"timeout\"\n]\n \n=\n \ntimeout\n\n\n    \nif\n \nwhen\n:\n\n        \nwhen_dt\n \n=\n \ndateparser\n.\nparse\n(\nwhen\n,\n \nsettings\n=\n{\n\n            \n'RETURN_AS_TIMEZONE_AWARE'\n:\n \nTrue\n})\n\n        \nif\n \nnot\n \nwhen_dt\n:\n\n            \nraise\n \nFailedActivity\n(\n\"failed to parse '{s}'\"\n.\nformat\n(\ns\n=\nwhen\n))\n\n        \nparams\n[\n\"time\"\n]\n \n=\n \nmaya\n.\nMayaDT\n.\nfrom_datetime\n(\nwhen_dt\n)\n.\nrfc3339\n()\n\n\n    \nlogger\n.\ndebug\n(\n\"Querying with: {q}\"\n.\nformat\n(\nq\n=\nparams\n))\n\n\n    \nr\n \n=\n \nrequests\n.\nget\n(\n\n        \nurl\n,\n \nheaders\n=\n{\n\"Accept\"\n:\n \n\"application/json\"\n},\n \nparams\n=\nparams\n)\n\n\n    \nif\n \nr\n.\nstatus_code\n \n!=\n \n200\n:\n\n        \nraise\n \nFailedActivity\n(\n\n            \n\"Prometheus query {q} failed: {m}\"\n.\nformat\n(\nq\n=\nstr\n(\nparams\n),\n \nm\n=\nr\n.\ntext\n))\n\n\n    \nreturn\n \nr\n.\njson\n()\n\n\n\n\ndef\n \nquery_interval\n(\nquery\n:\n \nstr\n,\n \nstart\n:\n \nstr\n,\n \nend\n:\n \nstr\n,\n \nstep\n:\n \nint\n \n=\n \n1\n,\n\n                   \ntimeout\n:\n \nfloat\n \n=\n \nNone\n,\n \nconfiguration\n:\n \nConfiguration\n \n=\n \nNone\n,\n\n                   \nsecrets\n:\n \nSecrets\n \n=\n \nNone\n)\n \n->\n \nDict\n[\nstr\n,\n \nAny\n]:\n\n    \n\"\"\"\n\n\n    Run a range query against a Prometheus server and returns its result as-is.\n\n\n\n    The `start` and `end` arguments can be a RFC 3339 date or expressed more\n\n\n    colloquially such as `\"5 minutes ago\"`.\n\n\n    \"\"\"\n\n    \nbase\n \n=\n \n(\nconfiguration\n \nor\n \n{})\n.\nget\n(\n\n        \n\"prometheus_base_url\"\n,\n \n\"http://localhost:9090\"\n)\n\n    \nurl\n \n=\n \n\"{base}/api/v1/query_range\"\n.\nformat\n(\nbase\n=\nbase\n)\n\n\n    \nparams\n \n=\n \n{\n\"query\"\n:\n \nquery\n}\n\n\n    \nif\n \ntimeout\n \nis\n \nnot\n \nNone\n:\n\n        \nparams\n[\n\"timeout\"\n]\n \n=\n \ntimeout\n\n\n    \nif\n \nstep\n:\n\n        \nparams\n[\n\"step\"\n]\n \n=\n \nstep\n\n\n    \nstart_dt\n \n=\n \ndateparser\n.\nparse\n(\nstart\n,\n \nsettings\n=\n{\n\n        \n'RETURN_AS_TIMEZONE_AWARE'\n:\n \nTrue\n})\n\n    \nif\n \nnot\n \nstart_dt\n:\n\n        \nraise\n \nFailedActivity\n(\n\"failed to parse '{s}'\"\n.\nformat\n(\ns\n=\nstart\n))\n\n    \nparams\n[\n\"start\"\n]\n \n=\n \nmaya\n.\nMayaDT\n.\nfrom_datetime\n(\nstart_dt\n)\n.\nrfc3339\n()\n\n\n    \nend_dt\n \n=\n \ndateparser\n.\nparse\n(\nend\n,\n \nsettings\n=\n{\n\n        \n'RETURN_AS_TIMEZONE_AWARE'\n:\n \nTrue\n})\n\n    \nif\n \nnot\n \nend_dt\n:\n\n        \nraise\n \nFailedActivity\n(\n\"failed to parse '{s}'\"\n.\nformat\n(\ns\n=\nend\n))\n\n    \nparams\n[\n\"end\"\n]\n \n=\n \nmaya\n.\nMayaDT\n.\nfrom_datetime\n(\nend_dt\n)\n.\nrfc3339\n()\n\n\n    \nlogger\n.\ndebug\n(\n\"Querying with: {q}\"\n.\nformat\n(\nq\n=\nparams\n))\n\n\n    \nr\n \n=\n \nrequests\n.\nget\n(\n\n        \nurl\n,\n \nheaders\n=\n{\n\"Accept\"\n:\n \n\"application/json\"\n},\n \nparams\n=\nparams\n)\n\n\n    \nif\n \nr\n.\nstatus_code\n \n!=\n \n200\n:\n\n        \nraise\n \nFailedActivity\n(\n\n            \n\"Prometheus query range {q} failed: {m}\"\n.\nformat\n(\n\n                \nq\n=\nstr\n(\nparams\n),\n \nm\n=\nr\n.\ntext\n))\n\n\n    \nreturn\n \nr\n.\njson\n()\n\n\n\n\n\nExecute the tests\n\u00b6\n\n\nWith the implementations in place you can now run your tests to assert that everything is as expected:\n\n\n> pytest\n\n\n\n\nAnd you should then get an output similar to the following:\n\n\n> pytest\nTest session starts (platform: darwin, Python 3.6.2, pytest 3.3.0, pytest-sugar 0.9.0)\ncachedir: .cache\nrootdir: /Users/russellmiles/code/src/github.com/chaostoolkit/chaostoolkit-prometheus, inifile: pytest.ini\nplugins: sugar-0.9.0, cov-2.5.1\n\n tests/test_probes.py::test_failed_parsing_when_date \u2713                                                                                         25% \u2588\u2588\u258c       \n tests/test_probes.py::test_failed_parsing_start_date \u2713                                                                                        50% \u2588\u2588\u2588\u2588\u2588     \n tests/test_probes.py::test_failed_parsing_end_date \u2713                                                                                          75% \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  \n tests/test_probes.py::test_failed_running_query \u2713                                                                                            100% \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n------------------ generated xml file: /Users/russellmiles/code/src/github.com/chaostoolkit/chaostoolkit-prometheus/junit-test-results.xml ------------------\n\n---------- coverage: platform darwin, python 3.6.2-final-0 -----------\nName                        Stmts   Miss  Cover   Missing\n---------------------------------------------------------\nchaosprometheus/probes.py      45      9    80%   29, 36-47, 66, 93\n---------------------------------------------------------\nTOTAL                          46      9    80%\n\n1 file skipped due to complete coverage.\nCoverage XML written to file coverage.xml\n\n\nResults (3.64s):\n       4 passed\n\n\n\n\nUsing your new probes\n\u00b6\n\n\nThat\u2019s all you need to do! You have now created your first Python-based extension to the Chaos Toolkit. You can now release and distribute this project using a system such as PyPi so that it can be installed and called from Chaos Toolkit experiments all over the world.\n\n\nAs an example, here is a snippet showing how a chaos experiment could look using your new \nPrometheus\n \nquery\n probe:\n\n\n{\n\n    \n\"type\"\n:\n \n\"probe\"\n,\n\n    \n\"name\"\n:\n \n\"fetch-cpu-just-2mn-ago\"\n,\n\n    \n\"provider\"\n:\n \n{\n\n        \n\"type\"\n:\n \n\"python\"\n,\n\n        \n\"module\"\n:\n \n\"chaosprometheus.probes\"\n,\n\n        \n\"func\"\n:\n \n\"query\"\n,\n\n        \n\"arguments\"\n:\n \n{\n\n            \n\"query\"\n:\n \n\"process_cpu_seconds_total{job='websvc'}\"\n,\n\n            \n\"when\"\n:\n \n\"2 minutes ago\"\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nNext Steps\n\u00b6\n\n\nIn the next tutorial we will take a look at how to create an extension that includes actions that can be called to inject failure from your chaos experiments.",
            "title": "Create a new Chaos Toolkit Extension with Custom Probes"
        },
        {
            "location": "/tutorials/custom-extension-probes/#create-a-new-chaos-toolkit-extension-with-custom-probes",
            "text": "The Chaos Toolkit can be extended to observe specific information about your system, using probes, as well as provide custom actions that can be used from within your experiment\u2019s method.   In this tutorial you will learn how to create a new custom Python extension to the Chaos Toolkit to expose some custom probes in order to gather more data from the observability of your system. This is done so that you can customize how you specify your Steady State Hypothesis as well as providing a custom means of gathering additional data during your experiment execution.   Note  The next tutorial in this series will show how to construct custom actions as well so that those can be used within your Chaos experiment\u2019s method.",
            "title": "Create a new Chaos Toolkit Extension with Custom Probes"
        },
        {
            "location": "/tutorials/custom-extension-probes/#introducing-the-extension",
            "text": "The extension we are going to create here will be a simple integration with  Prometheus  to provide a couple of new probes that we can use in our Chaos Engineering experiments. The probes will be:   query  - Runs an instant query against a  Prometheus  server and returns its result as-is.  query_interval  - Runs a range query against a  Prometheus  server and returns its result as-is.   The  query  probe will naturally, if specified with some tolerances, be a good candidate for use as part of a  Stead State Hypothesis  as well as a general-purpose probe.   Note  There is already a  chaostoolkit-prometheus extension project  and the tutorial shown here is based on how it was originally developed.",
            "title": "Introducing the Extension"
        },
        {
            "location": "/tutorials/custom-extension-probes/#creating-a-new-extension-based-on-the-template-project",
            "text": "To create a new project based on the Chaos Toolkit Extension Template grab the  latest released code for the template  and place this code in a new project that ideally follows the naming convention of  chaostoolkit-<your extension name here> .   For our purposes we will create a new project based on the templates code called  chaostoolkit-prometheus . You will also need to change any references to  chaosext  to the name of your new extension and its associated package. Once you have made those changes you should have a project contents that looks like the following:  .\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 MANIFEST.in\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 chaosprometheus\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 probes.py\n\u251c\u2500\u2500 ci.bash\n\u251c\u2500\u2500 coverage.xml\n\u251c\u2500\u2500 junit-test-results.xml\n\u251c\u2500\u2500 pytest.ini\n\u251c\u2500\u2500 requirements-dev.txt\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 tests\n    \u2514\u2500\u2500 test_probes.py",
            "title": "Creating a new Extension based on the Template project"
        },
        {
            "location": "/tutorials/custom-extension-probes/#optional-create-a-virtual-environment-for-your-new-extension",
            "text": "A Python virtual environment is a great way of managing your project\u2019s dependencies. We recommend creating a virtual environment for your new Chaos Toolkit extension project using the following command:  > python3 -m venv ~/.venvs/<your-ext-venv>",
            "title": "(Optional) Create a virtual environment for your new extension"
        },
        {
            "location": "/tutorials/custom-extension-probes/#setup-your-extensions-dependencies",
            "text": "Now you can added dependencies into the  requirements-dev.txt , for dependencies you only need at development time, and  requirements.txt , for dependencies you only need at runtime. We need a few extra dependencies to work with Prometheus:  logzero\nrequests\ndateparser\nmaya  Briefly, these dependencies are useful because they:   logzero  - Makes it simpler to add logging to the Python extension. Also it is what the core Chaos Toolkit uses so this is consistent.  requests  - Adds an HTTP client for working against the Prometheus API  dateparser  - Provides support for manupulating dates and time, including generalinh time/date ranges.  maya  - Provides support for serialising dates and times to and from the dates and times needed for the Prometheus API.   With those changes made you can now install your dependencies for your development work using the following command:  > python setup.py develop",
            "title": "Setup your extensions dependencies"
        },
        {
            "location": "/tutorials/custom-extension-probes/#create-tests-for-the-new-probes",
            "text": "You\u2019re now ready to start coding up your new probes for Prometheus. Using TDD, you can construct tests that exercise the success and failure scenarios of the expected probe functions in a  tests/test_probes.py  module:  # -*- coding: utf-8 -*-  import   pytest  import   requests  import   requests_mock  from   chaoslib.exceptions   import   FailedActivity  from   chaosprometheus.probes   import   query ,   query_interval  def   test_failed_parsing_when_date (): \n     with   pytest . raises ( FailedActivity )   as   exc : \n         query ( \"request_processing_seconds_count\" ,   when = \"2 mns ago\" ) \n     assert   \"failed to parse '2 mns ago'\"   in   str ( exc )  def   test_failed_parsing_start_date (): \n     with   pytest . raises ( FailedActivity )   as   exc : \n         query_interval ( \"request_processing_seconds_count\" ,   start = \"2 mns ago\" , \n                        end = \"now\" ) \n     assert   \"failed to parse '2 mns ago'\"   in   str ( exc )  def   test_failed_parsing_end_date (): \n     with   pytest . raises ( FailedActivity )   as   exc : \n         query_interval ( \"request_processing_seconds_count\" , \n                        start = \"2 minutes ago\" ,   end = \"right now\" ) \n     assert   \"failed to parse 'right now'\"   in   str ( exc )  def   test_failed_running_query (): \n     with   requests_mock . mock ()   as   m : \n         m . get ( \n             \"http://localhost:9090/api/v1/query_range\" ,   status_code = 400 , \n             text = \"Bad Request\" ) \n\n         with   pytest . raises ( FailedActivity )   as   ex : \n             query_interval ( query = \"request_processing_seconds_count\" , \n                            start = \"2 minutes ago\" ,   end = \"now\" ) \n     assert   \"Prometheus query\"   in   str ( ex )",
            "title": "Create tests for the new probes"
        },
        {
            "location": "/tutorials/custom-extension-probes/#create-the-new-probes",
            "text": "Finally it\u2019s time to create the new probes to meet the needs as specified by your tests in a file called  chaosprometheus/probes.py :  # -*- coding: utf-8 -*-  from   typing   import   Any ,   Dict  import   dateparser  from   logzero   import   logger  import   maya  import   requests  from   chaoslib.exceptions   import   FailedActivity  from   chaoslib.types   import   Configuration ,   Secrets  __all__   =   [ \"query\" ,   \"query_interval\" ]  def   query ( query :   str ,   when :   str   =   None ,   timeout :   float   =   None , \n           configuration :   Configuration   =   None , \n           secrets :   Secrets   =   None )   ->   Dict [ str ,   Any ]: \n     \"\"\"      Run an instant query against a Prometheus server and returns its result      as-is.      \"\"\" \n     base   =   ( configuration   or   {}) . get ( \n         \"prometheus_base_url\" ,   \"http://localhost:9090\" ) \n     url   =   \"{base}/api/v1/query\" . format ( base = base ) \n\n     params   =   { \"query\" :   query } \n\n     if   timeout   is   not   None : \n         params [ \"timeout\" ]   =   timeout \n\n     if   when : \n         when_dt   =   dateparser . parse ( when ,   settings = { \n             'RETURN_AS_TIMEZONE_AWARE' :   True }) \n         if   not   when_dt : \n             raise   FailedActivity ( \"failed to parse '{s}'\" . format ( s = when )) \n         params [ \"time\" ]   =   maya . MayaDT . from_datetime ( when_dt ) . rfc3339 () \n\n     logger . debug ( \"Querying with: {q}\" . format ( q = params )) \n\n     r   =   requests . get ( \n         url ,   headers = { \"Accept\" :   \"application/json\" },   params = params ) \n\n     if   r . status_code   !=   200 : \n         raise   FailedActivity ( \n             \"Prometheus query {q} failed: {m}\" . format ( q = str ( params ),   m = r . text )) \n\n     return   r . json ()  def   query_interval ( query :   str ,   start :   str ,   end :   str ,   step :   int   =   1 , \n                    timeout :   float   =   None ,   configuration :   Configuration   =   None , \n                    secrets :   Secrets   =   None )   ->   Dict [ str ,   Any ]: \n     \"\"\"      Run a range query against a Prometheus server and returns its result as-is.      The `start` and `end` arguments can be a RFC 3339 date or expressed more      colloquially such as `\"5 minutes ago\"`.      \"\"\" \n     base   =   ( configuration   or   {}) . get ( \n         \"prometheus_base_url\" ,   \"http://localhost:9090\" ) \n     url   =   \"{base}/api/v1/query_range\" . format ( base = base ) \n\n     params   =   { \"query\" :   query } \n\n     if   timeout   is   not   None : \n         params [ \"timeout\" ]   =   timeout \n\n     if   step : \n         params [ \"step\" ]   =   step \n\n     start_dt   =   dateparser . parse ( start ,   settings = { \n         'RETURN_AS_TIMEZONE_AWARE' :   True }) \n     if   not   start_dt : \n         raise   FailedActivity ( \"failed to parse '{s}'\" . format ( s = start )) \n     params [ \"start\" ]   =   maya . MayaDT . from_datetime ( start_dt ) . rfc3339 () \n\n     end_dt   =   dateparser . parse ( end ,   settings = { \n         'RETURN_AS_TIMEZONE_AWARE' :   True }) \n     if   not   end_dt : \n         raise   FailedActivity ( \"failed to parse '{s}'\" . format ( s = end )) \n     params [ \"end\" ]   =   maya . MayaDT . from_datetime ( end_dt ) . rfc3339 () \n\n     logger . debug ( \"Querying with: {q}\" . format ( q = params )) \n\n     r   =   requests . get ( \n         url ,   headers = { \"Accept\" :   \"application/json\" },   params = params ) \n\n     if   r . status_code   !=   200 : \n         raise   FailedActivity ( \n             \"Prometheus query range {q} failed: {m}\" . format ( \n                 q = str ( params ),   m = r . text )) \n\n     return   r . json ()",
            "title": "Create the new Probes"
        },
        {
            "location": "/tutorials/custom-extension-probes/#execute-the-tests",
            "text": "With the implementations in place you can now run your tests to assert that everything is as expected:  > pytest  And you should then get an output similar to the following:  > pytest\nTest session starts (platform: darwin, Python 3.6.2, pytest 3.3.0, pytest-sugar 0.9.0)\ncachedir: .cache\nrootdir: /Users/russellmiles/code/src/github.com/chaostoolkit/chaostoolkit-prometheus, inifile: pytest.ini\nplugins: sugar-0.9.0, cov-2.5.1\n\n tests/test_probes.py::test_failed_parsing_when_date \u2713                                                                                         25% \u2588\u2588\u258c       \n tests/test_probes.py::test_failed_parsing_start_date \u2713                                                                                        50% \u2588\u2588\u2588\u2588\u2588     \n tests/test_probes.py::test_failed_parsing_end_date \u2713                                                                                          75% \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  \n tests/test_probes.py::test_failed_running_query \u2713                                                                                            100% \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n------------------ generated xml file: /Users/russellmiles/code/src/github.com/chaostoolkit/chaostoolkit-prometheus/junit-test-results.xml ------------------\n\n---------- coverage: platform darwin, python 3.6.2-final-0 -----------\nName                        Stmts   Miss  Cover   Missing\n---------------------------------------------------------\nchaosprometheus/probes.py      45      9    80%   29, 36-47, 66, 93\n---------------------------------------------------------\nTOTAL                          46      9    80%\n\n1 file skipped due to complete coverage.\nCoverage XML written to file coverage.xml\n\n\nResults (3.64s):\n       4 passed",
            "title": "Execute the tests"
        },
        {
            "location": "/tutorials/custom-extension-probes/#using-your-new-probes",
            "text": "That\u2019s all you need to do! You have now created your first Python-based extension to the Chaos Toolkit. You can now release and distribute this project using a system such as PyPi so that it can be installed and called from Chaos Toolkit experiments all over the world.  As an example, here is a snippet showing how a chaos experiment could look using your new  Prometheus   query  probe:  { \n     \"type\" :   \"probe\" , \n     \"name\" :   \"fetch-cpu-just-2mn-ago\" , \n     \"provider\" :   { \n         \"type\" :   \"python\" , \n         \"module\" :   \"chaosprometheus.probes\" , \n         \"func\" :   \"query\" , \n         \"arguments\" :   { \n             \"query\" :   \"process_cpu_seconds_total{job='websvc'}\" , \n             \"when\" :   \"2 minutes ago\" \n         } \n     }  }",
            "title": "Using your new probes"
        },
        {
            "location": "/tutorials/custom-extension-probes/#next-steps",
            "text": "In the next tutorial we will take a look at how to create an extension that includes actions that can be called to inject failure from your chaos experiments.",
            "title": "Next Steps"
        },
        {
            "location": "/project/values/",
            "text": "Key Project Values\n\u00b6\n\n\nThe following key values of the Chaos Toolkit reflect the mindset the community\nhas when engineering the Chaos Toolkit project.\n\n\nSimplicity\n\u00b6\n\n\nThe Chaos Toolkit aims at being a simple piece of technology both from a user\nand developer perspective.\n\n\nTo achieve simplicity, the Chaos Toolkit comes as a command line interface\ndriven by a description file. As a user, this means no code and no need to \nlearn a programming language. As a developer, this reduces the functional\nsurface area to consider.\n\n\nExtensibility\n\u00b6\n\n\nThe Chaos Toolkit does not wish to be a monolith and strives to be extended to\nfully reach its goal through community driven efforts.\n\n\nBy using a description file, the implementation is not prescribed by the Chaos\nToolkit project. Although we fully expect the community to eventually settle on\ncertain implementations of probes and actions.\n\n\nReadability\n\u00b6\n\n\nWe believe code readbility is a factor for positive maintenance and evolutivity.\n\n\nReadable code never goes out of fashion. As the code of the Chaos Toolkit is\nmostly written in Python, best practices such as defined in \nPEP8\n.\n\n\nDiversity\n\u00b6\n\n\nAlthough not strictly speaking referring to the technological aspect of the \nproject, having diversity in the community will contribute to a better project\noverall.",
            "title": "Key Project Values"
        },
        {
            "location": "/project/values/#key-project-values",
            "text": "The following key values of the Chaos Toolkit reflect the mindset the community\nhas when engineering the Chaos Toolkit project.",
            "title": "Key Project Values"
        },
        {
            "location": "/project/values/#simplicity",
            "text": "The Chaos Toolkit aims at being a simple piece of technology both from a user\nand developer perspective.  To achieve simplicity, the Chaos Toolkit comes as a command line interface\ndriven by a description file. As a user, this means no code and no need to \nlearn a programming language. As a developer, this reduces the functional\nsurface area to consider.",
            "title": "Simplicity"
        },
        {
            "location": "/project/values/#extensibility",
            "text": "The Chaos Toolkit does not wish to be a monolith and strives to be extended to\nfully reach its goal through community driven efforts.  By using a description file, the implementation is not prescribed by the Chaos\nToolkit project. Although we fully expect the community to eventually settle on\ncertain implementations of probes and actions.",
            "title": "Extensibility"
        },
        {
            "location": "/project/values/#readability",
            "text": "We believe code readbility is a factor for positive maintenance and evolutivity.  Readable code never goes out of fashion. As the code of the Chaos Toolkit is\nmostly written in Python, best practices such as defined in  PEP8 .",
            "title": "Readability"
        },
        {
            "location": "/project/values/#diversity",
            "text": "Although not strictly speaking referring to the technological aspect of the \nproject, having diversity in the community will contribute to a better project\noverall.",
            "title": "Diversity"
        },
        {
            "location": "/project/core/",
            "text": "Core Projects\n\u00b6\n\n\nThe Chaos Toolkit is made of several projects that work together to provide its\nservice.\n\n\nchaostoolkit\n\u00b6\n\n\nThe \nchaostoolkit\n project is the command-line interface (CLI), in other words\nthe command executed by users to run their experiments.\n\n\nThat project tries to remain as shallow as possible, only providing the user\ninterface commands by gluing other projects together.\n\n\nThis project is implemented in Python 3.\n\n\nchaostoolkit-lib\n\u00b6\n\n\nThe \nchaostoolkit-lib\n project is the core library which implements\nthe \ncore concepts\n of the Chaos Toolkit.\n\n\nThis project is implemented in Python 3.\n\n\nchaostoolkit-documentation\n\u00b6\n\n\nThe \nchaostoolkit-documehtation\n is the documentation source and\nrenderer of the Chaos Toolkit. Namely, that project generates the website you\nare currently reading.\n\n\nThis project is implemented in Python 3 by generating HTML from Markdown\ndocuments.",
            "title": "Core Projects"
        },
        {
            "location": "/project/core/#core-projects",
            "text": "The Chaos Toolkit is made of several projects that work together to provide its\nservice.",
            "title": "Core Projects"
        },
        {
            "location": "/project/core/#chaostoolkit",
            "text": "The  chaostoolkit  project is the command-line interface (CLI), in other words\nthe command executed by users to run their experiments.  That project tries to remain as shallow as possible, only providing the user\ninterface commands by gluing other projects together.  This project is implemented in Python 3.",
            "title": "chaostoolkit"
        },
        {
            "location": "/project/core/#chaostoolkit-lib",
            "text": "The  chaostoolkit-lib  project is the core library which implements\nthe  core concepts  of the Chaos Toolkit.  This project is implemented in Python 3.",
            "title": "chaostoolkit-lib"
        },
        {
            "location": "/project/core/#chaostoolkit-documentation",
            "text": "The  chaostoolkit-documehtation  is the documentation source and\nrenderer of the Chaos Toolkit. Namely, that project generates the website you\nare currently reading.  This project is implemented in Python 3 by generating HTML from Markdown\ndocuments.",
            "title": "chaostoolkit-documentation"
        },
        {
            "location": "/project/extensions/",
            "text": "Extension Projects\n\u00b6\n\n\nIn addition to the core projects, the Chaos Toolkit manages some extension\nprojects which provide probes and/or actions for experiments.\n\n\nchaostoolkit-kubernetes\n\u00b6\n\n\nThe \nchaostoolkit-kubernetes\n project implements probes and actions\nfor experiments targetting a \nKubernetes\n cluster. Those activities\nare implemented as Python functions.\n\n\nThis project is implemented in Python 3.\n\n\nchaostoolkit-gremlin\n\u00b6\n\n\nThe \nchaostoolkit-gremlin\n project implements actions\nfor experiments exploring resource failures (CPU, Memory, Network\u2026) in their\nsystem through the \nGremlin, Inc.\n services. Those activities\nare implemented as Python functions talking to the \nGremlin API\n.\n\n\nThis project is implemented in Python 3.\n\n\nchaostoolkit-prometheus\n\u00b6\n\n\nThe \nchaostoolkit-prometheus\n project implements probes to fetch\ninformation from your system through \nPrometheus\n. Those probes\nare implemented as Python functions talking to the \nPrometheus API\n.\n\n\nThis project is implemented in Python 3.",
            "title": "Extensions"
        },
        {
            "location": "/project/extensions/#extension-projects",
            "text": "In addition to the core projects, the Chaos Toolkit manages some extension\nprojects which provide probes and/or actions for experiments.",
            "title": "Extension Projects"
        },
        {
            "location": "/project/extensions/#chaostoolkit-kubernetes",
            "text": "The  chaostoolkit-kubernetes  project implements probes and actions\nfor experiments targetting a  Kubernetes  cluster. Those activities\nare implemented as Python functions.  This project is implemented in Python 3.",
            "title": "chaostoolkit-kubernetes"
        },
        {
            "location": "/project/extensions/#chaostoolkit-gremlin",
            "text": "The  chaostoolkit-gremlin  project implements actions\nfor experiments exploring resource failures (CPU, Memory, Network\u2026) in their\nsystem through the  Gremlin, Inc.  services. Those activities\nare implemented as Python functions talking to the  Gremlin API .  This project is implemented in Python 3.",
            "title": "chaostoolkit-gremlin"
        },
        {
            "location": "/project/extensions/#chaostoolkit-prometheus",
            "text": "The  chaostoolkit-prometheus  project implements probes to fetch\ninformation from your system through  Prometheus . Those probes\nare implemented as Python functions talking to the  Prometheus API .  This project is implemented in Python 3.",
            "title": "chaostoolkit-prometheus"
        },
        {
            "location": "/project/technologies/",
            "text": "Technology Choices\n\u00b6\n\n\nPython 3\n\u00b6\n\n\nThe Chaos Toolkit is implemented in \nPython 3\n. A high-level language with\na long successfuly story for writing great software. It\u2019s a common choice for\ntooling purpose.\n\n\nThe language supports readbility well and has a large ecosystem of libraries. It\nis also well-spread and easy to install. The choice to not support Python 2 is\na look at Python\u2019s present and future.\n\n\nThe choice for a dynamic language was also motivated because the Chaos Toolkit\nmanipulates a lot of strings and that task is made straightforward with Python.\n\n\nAlthough Python natively does not generate (though \nit can be done\n)\nstandalone binaries like \ngolang\n would. We do not believe this will harm\nthe project and hope that package managers will eventually provide native\ninstallers.\n\n\nFunctional\n\u00b6\n\n\nWell, this project is not truly a functional piece of code but the code relies\nas little as possible on stateful constructions as provided by classes.\n\n\nMutable data structures are used but mostly created and returned from functions\nrather than modified.\n\n\nGenerally speaking, the project draws inspirations from certain ideas of \n\nfunctional paradigms\n but does not enforce them strictly. One notable\narea where the code strays away from these principles is the use of exceptions\nrather than returning error codes. This may change if the community expresses\nsuch an intention.\n\n\nJSON\n\u00b6\n\n\nThe experiment description and structure is encoded using JSON. The choice for\nJSON over YAML is because it leaves less room for ambiguity and is marginally\nless readable for a structure with a shallow depth like Chaos Toolkit\nexperiments.",
            "title": "Technology Choices"
        },
        {
            "location": "/project/technologies/#technology-choices",
            "text": "",
            "title": "Technology Choices"
        },
        {
            "location": "/project/technologies/#python-3",
            "text": "The Chaos Toolkit is implemented in  Python 3 . A high-level language with\na long successfuly story for writing great software. It\u2019s a common choice for\ntooling purpose.  The language supports readbility well and has a large ecosystem of libraries. It\nis also well-spread and easy to install. The choice to not support Python 2 is\na look at Python\u2019s present and future.  The choice for a dynamic language was also motivated because the Chaos Toolkit\nmanipulates a lot of strings and that task is made straightforward with Python.  Although Python natively does not generate (though  it can be done )\nstandalone binaries like  golang  would. We do not believe this will harm\nthe project and hope that package managers will eventually provide native\ninstallers.",
            "title": "Python 3"
        },
        {
            "location": "/project/technologies/#functional",
            "text": "Well, this project is not truly a functional piece of code but the code relies\nas little as possible on stateful constructions as provided by classes.  Mutable data structures are used but mostly created and returned from functions\nrather than modified.  Generally speaking, the project draws inspirations from certain ideas of  functional paradigms  but does not enforce them strictly. One notable\narea where the code strays away from these principles is the use of exceptions\nrather than returning error codes. This may change if the community expresses\nsuch an intention.",
            "title": "Functional"
        },
        {
            "location": "/project/technologies/#json",
            "text": "The experiment description and structure is encoded using JSON. The choice for\nJSON over YAML is because it leaves less room for ambiguity and is marginally\nless readable for a structure with a shallow depth like Chaos Toolkit\nexperiments.",
            "title": "JSON"
        },
        {
            "location": "/extending/approaches/",
            "text": "Extending the Chaos Toolkit\n\u00b6\n\n\nThe Chaos Toolkit is designed to be extended with new probes and actions so that\nyou can work with any failure injection and system observability systems that you choose. The toolkit has a growing number of open source extensions for just this purpose, but the intention is that you may also want to extend the Chaos Toolkit for your own unique, possible closed, systems as well.\n\n\nThe ChaosToolkit currently \nsupports\n three extension approaches:\n\n\n\n\nPython function\n\n\nProcess\n\n\nHTTP\n\n\n\n\nYou can extend your actions and probes by implementing them using one of these\napproaches.",
            "title": "Extension Approaches"
        },
        {
            "location": "/extending/approaches/#extending-the-chaos-toolkit",
            "text": "The Chaos Toolkit is designed to be extended with new probes and actions so that\nyou can work with any failure injection and system observability systems that you choose. The toolkit has a growing number of open source extensions for just this purpose, but the intention is that you may also want to extend the Chaos Toolkit for your own unique, possible closed, systems as well.  The ChaosToolkit currently  supports  three extension approaches:   Python function  Process  HTTP   You can extend your actions and probes by implementing them using one of these\napproaches.",
            "title": "Extending the Chaos Toolkit"
        },
        {
            "location": "/extending/extending-with-python/",
            "text": "Extending Chaos Toolkit with Python\n\u00b6\n\n\nTo create your own extension to the Chaos Toolkit using Python, a \ntemplate Python Chaos Toolkit extension project\n is available as a good starting point.\n\n\nCreate your new Chaos Toolkit extension project\n\u00b6\n\n\nTo use the Python template extension project, simply download the latest release of \nthe baseline project\n from GitHub, place this in your own new project, and make the following amendments:\n\n\n\n\nEdit the name of the project to the name of your unique extension: \n\n\nRename the package directory (\nchaosext\n in the template) \n\n\nRename the imports in the tests from \nchaosext\n to the name of your extension\u2019s package\n\n\nMake the same change across the \nREADME.md\n, the\nCHANGELOG.md\n, \npytest.ini\n and \nsetup.py\n\n\n\n\n\n\nRemove \nci.bash\n and \n.travis.yml\n as these are artifacts from the CI build system for the template only.\n\n\n\n\nWhere to put your code\n\u00b6\n\n\nThere are two extension points for a Chaos Toolkit Python extension, and they are captured in two files: \nactions.py\n and \nprobes.py\n.\n\n\nIt is conventional to use the \nactions.py\n module as the place where you expose the actions that you would like to conduct as part of your Chaos Toolkit experimental method against the environment you want to inject failure into.\n\n\nIt\u2019s also conventional to use the \nprobes.py\n module as the place where you can integrate with your system\u2019s existing \nobservability\n so that those values can be used either for an experiment\u2019s \nSteady State Hypothesis\n, or as \nsimple additional data-gathering probes\n that can be declared throughout an experiment\u2019s method.",
            "title": "Python"
        },
        {
            "location": "/extending/extending-with-python/#extending-chaos-toolkit-with-python",
            "text": "To create your own extension to the Chaos Toolkit using Python, a  template Python Chaos Toolkit extension project  is available as a good starting point.",
            "title": "Extending Chaos Toolkit with Python"
        },
        {
            "location": "/extending/extending-with-python/#create-your-new-chaos-toolkit-extension-project",
            "text": "To use the Python template extension project, simply download the latest release of  the baseline project  from GitHub, place this in your own new project, and make the following amendments:   Edit the name of the project to the name of your unique extension:   Rename the package directory ( chaosext  in the template)   Rename the imports in the tests from  chaosext  to the name of your extension\u2019s package  Make the same change across the  README.md , the CHANGELOG.md ,  pytest.ini  and  setup.py    Remove  ci.bash  and  .travis.yml  as these are artifacts from the CI build system for the template only.",
            "title": "Create your new Chaos Toolkit extension project"
        },
        {
            "location": "/extending/extending-with-python/#where-to-put-your-code",
            "text": "There are two extension points for a Chaos Toolkit Python extension, and they are captured in two files:  actions.py  and  probes.py .  It is conventional to use the  actions.py  module as the place where you expose the actions that you would like to conduct as part of your Chaos Toolkit experimental method against the environment you want to inject failure into.  It\u2019s also conventional to use the  probes.py  module as the place where you can integrate with your system\u2019s existing  observability  so that those values can be used either for an experiment\u2019s  Steady State Hypothesis , or as  simple additional data-gathering probes  that can be declared throughout an experiment\u2019s method.",
            "title": "Where to put your code"
        },
        {
            "location": "/api/experiment/",
            "text": "An Open API for Chaos Engineering Experiments\n\u00b6\n\n\n\n\nInfo\n\n\nThe current specification has not reached its 1.0.0 stable version yet. Make\nsure to \njoin the discussion\n to provide any feedback you might have.\n\n\n\n\nIntroduction\n\u00b6\n\n\nThe purpose of this specification is to formalize the elements of a Chaos\nEngineering experiment and offer a way to federate the community around a\ncommon syntax and semantic.\n\n\nAs a fairly recent field, Chaos Engineering is a dynamic and its foundations\nare still emerging. However, it appears certain concepts are settling down\nenough to start agreeing on a shared understanding.\n\n\nThis specification is not prescriptive and does not aim at forcing the\ncommunity into one direction, rather it strives at providing a common\nvocabulary that new practicionners can easily make sense of.\n\n\nIt is necessary to appreciate that this document does not specify what tools,\nsuch as the Chaos Monkey or similar, should look like. Instead, this document\nspecifies how Chaos Engineering Experiment could be described, shared and\nconducted collaboratively.\n\n\nConventions Used in This Document\n\u00b6\n\n\nThe key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d,\n\u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this\ndocument are to be interpreted as described in \nRFC 2119\n.\n\n\nThe terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d,\n\u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this\ndocument are to be interpreted as defined in \nRFC 7159\n.\n\n\nChaos Engineering Elements\n\u00b6\n\n\nOverview\n\u00b6\n\n\nAn Experiment is one possible description of the\n\nprinciples of the Chaos Engineering\n. The intention of such a\ndescription is to provide shared understanding around a hypothesis on how\nto discover system\u2019s behavior under certain conditions.\n\n\nAn \nExperiment\n declares a steady \nstate hypothesis\n, alongside\n\nprobes\n to validate this steady state is met, and a \nmethod\n as a\nsequence \nactions\n and \nprobes\n, to interact and query the system\nrespectively.\n\n\nBy using a variety of \nprobes\n, experiments should gather information to\nsense behaviors in the system, potentially leading to systemic patterns that can\nbe stabilized.\n\n\nExperiment\n\u00b6\n\n\nA Chaos Engineering experiment, or simply an experiment, describes both the\nelements and the order in which they should be applied.\n\n\nAn experiment is a JSON object.\n\n\nAn experiment MUST declare:\n\n\n\n\na \nversion\n property\n\n\na \ntitle\n property\n\n\na \ndescription\n property\n\n\na \nsteady-state-hypothesis\n property\n\n\na \nmethod\n property\n\n\n\n\nThe \nversion\n property MUST be \n\"0.1.0\"\n.\n\n\nThe experiment\u2019s \ntitle\n and \ndescription\n are meant for humans and therefore\nshould be as descriptive as possible to clarify the experiment\u2019s rationale.\n\n\nTitle and description are JSON strings with no maximum length.\n\n\nAn experiment SHOULD also declare:\n\n\n\n\na \nrollbacks\n property\n\n\n\n\nAn experiment MAY finally declare:\n\n\n\n\na \ntags\n property\n\n\na \nsecrets\n property\n\n\n\n\nTags provide a way of categorizing experiments. It is a sequence of JSON\nstrings.\n\n\nSteady State Hypothesis\n\u00b6\n\n\nThe Steady State Hypothesis element describes what normal looks like in your\nsystem before the Method element is applied. If the steady state is not met,\nthe Method element is not applied and the experiment MUST bail out.\n\n\nThe Steady State Hypothesis element is a JSON object.\n\n\nSteady State Hypothesis element MUST declare:\n\n\n\n\na \ntitle\n property\n\n\na \nprobes\n property\n\n\n\n\nThe \ntitle\n is meant for humans and therefore should clarify the rationale for\nthis hypothesis.\n\n\nEach \nProbe\n MUST define a \ntolerance\n property that acting as a gate\nmechanism for the experiment to carry on or bail. Any \nProbe\n that does not\nfall into the \ntolerance\n zone MUST fail the experiment.\n\n\nSteady State Probe Tolerance\n\u00b6\n\n\nProbes\n of the Steady State Hypothesis MUST declare an additional property\nnamed \ntolerance\n.\n\n\nThe \ntolerance\n property\u2019s value MUST be one of:\n\n\n\n\na scalar: JSON string, number (an integer), boolean\n\n\na sequence of two scalars defining a lower and upper bounds\n\n\na Probe object\n\n\n\n\nIn the case of a scalar or the sequence, the tolerance validation MUST be\nstrict. The value returned by the \nProbe\n MUST be checked against the\nscalar value. The experiment MUST bail when both fail to match.\n\n\nWhen the \ntolerance\n is a sequence of two scalars, the returned value from\nthe \nProbe\n MUST fall within the boundaries they form.\n\n\nIn the case of a \nProbe\n object, the tolerance validation is left\nundefined as it is controlled by the \nProbe\n itself. However, it is\nRECOMMENDED that the \ntolerance\n \nProbe\n acts strictly in order to improve\nthe readability of the experiment\u2019s results.\n\n\nSome examples of \ntolerance\n properties.\n\n\nA boolean tolerance:\n\n\"tolerance\"\n:\n \ntrue\n\n\n\n\nA integer tolerance:\n\n\"tolerance\"\n:\n \n8\n\n\n\n\nA string tolerance:\n\n\"tolerance\"\n:\n \n\"OK\"\n\n\n\n\nA sequence tolerance:\n\n\"tolerance\"\n:\n \n[\n4\n,\n \n9\n]\n\n\n\n\nA \nProbe\n tolerance:\n\n\"tolerance\"\n:\n \n{\n\n    \n\"type\"\n:\n \n\"probe\"\n,\n\n    \n\"name\"\n:\n \n\"should-exist\"\n,\n\n    \n\"provider\"\n:\n \n{\n\n        \n\"type\"\n:\n \n\"python\"\n,\n\n        \n\"module\"\n:\n \n\"os.path\"\n,\n\n        \n\"func\"\n:\n \n\"exists\"\n,\n\n        \n\"arguments\"\n:\n \n{\n\n            \n\"path\"\n:\n \n\"some/file\"\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\nMethod\n\u00b6\n\n\nThe Method describes the sequence of \nProbe\n and \nAction\n elements\nto apply. The Method is declared under \nmethod\n property at the top-level of the\nexperiment.\n\n\nThe \nmethod\n MUST have at least one element but this can be either a \nProbe\n\nor an \nAction\n.\n\n\nThe elements MUST be applied in the order they are declared.\n\n\nProbe\n\u00b6\n\n\nA Probe collects information from the system during the experiment.\n\n\nA Probe is a JSON object. A Probe is declared fully or reference another Probe\nthrough the \nref\n property.\n\n\nWhen declared fully, a Probe MUST declare:\n\n\n\n\na \ntype\n property\n\n\na \nname\n property\n\n\na \nprovider\n property\n\n\n\n\nThe \ntype\n property MUST be the JSON string \n\"probe\"\n. \n\n\nThe \nname\n property is a free-form JSON string that MAY be considered as an\nidentifier withing the experiment.\n\n\nIt MAY also declare:\n\n\n\n\na \nsecret\n property\n\n\na \nconfiguration\n property\n\n\na \nbackground\n property\n\n\n\n\nThe \nsecret\n property MUST be a JSON string referencing an identifier declared\nin the top-level \nsecrets\n \nproperty\n. It is assumed that when not\ndeclared, the Probe requires no secrets.\n\n\nThe \nconfiguration\n property MUST be a JSON string referencing an identifier\ndeclared in the top-level \nconfiguration\n \nproperty\n. It is assumed that\nwhen not declared, the Probe requires no configuration.\n\n\nThe \nbackground\n property MUST be a JSON boolean value either \ntrue\n or \nfalse\n.\nIt is assumed that, when that property is not declared, it is set to \nfalse\n.\nWhen that property is set to \ntrue\n it indicates the Probe MUST not block\nand the next Action or Probe should immediatly be applied.\n\n\nWhen a Probe references another Probe in the Experiment, the Probe MUST\ndeclare a single property called \nref\n.\n\n\nThe \nref\n property MUST be a JSON string which MUST be the name of a declared\nProbe.\n\n\nAction\n\u00b6\n\n\nAn Action performs an operation against the system.\n\n\nAn Action collects information from the system during the experiment.\n\n\nAn Action is a JSON object. An Action is declared fully or reference another\nAction through the \nref\n property.\n\n\nWhen declared fully, a Action MUST declare:\n\n\n\n\na \ntype\n property\n\n\na \nname\n property\n\n\na \nprovider\n property\n\n\n\n\nThe \ntype\n property MUST be the JSON string \n\"action\"\n. \n\n\nThe \nname\n property is a free-form JSON string that MAY be considered as an\nidentifier withing the experiment.\n\n\nIt MAY also declare:\n\n\n\n\na \nsecret\n property\n\n\na \nconfiguration\n property\n\n\na \nbackground\n property\n\n\na \npauses\n property\n\n\n\n\nThe \nsecret\n property MUST be a JSON string referencing an identifier declared\nin the top-level \nsecrets\n \nproperty\n. It is assumed that when not\ndeclared, the Action requires no secrets.\n\n\nThe \nconfiguration\n property MUST be a JSON string referencing an identifier\ndeclared in the top-level \nconfiguration\n \nproperty\n. It is assumed that\nwhen not declared, the Action requires no configuration.\n\n\nThe \nbackground\n property MUST be a JSON boolean value either \ntrue\n or \nfalse\n.\nIt is assumed that, when that property is not declared, it is set to \nfalse\n.\nWhen that property is set to \ntrue\n it indicates the Action MUST not block\nand the next Action or Probe should immediatly be applied.\n\n\nThe \npauses\n property MUST be a JSON object which MAY have one or the two\nfollowing properties:\n\n\n\n\nbefore\n\n\nafter\n\n\n\n\nIn both cases, the value MUST be JSON number indicating the number of seconds to\nwait before continuining. The \nbefore\n pause MUST be performed before the Action\nwhile the \nafter\n MUST be performed afterwards.\n\n\nWhen a Action references another Action in the Experiment, the Action MUST\ndeclare a single property called \nref\n.\n\n\nThe \nref\n property MUST be a JSON string which MUST be the name of a declared\nAction.\n\n\nAction or Probe Provider\n\u00b6\n\n\nA provider MUST be a JSON object which MUST declare a \ntype\n property that\ndecides the other expected properties.\n\n\nThe \ntype\n property MUST be one of \n\"python\"\n, \n\"http\"\n or \n\"process\"\n.\n\n\nPython Provider\n\u00b6\n\n\nA Python Provider declares a Python function to be applied.\n\n\nA Python Provider MUST declare the following:\n\n\n\n\na \nmodule\n property\n\n\na \nfunc\n property\n\n\n\n\nIt SHOULD also declare an \narguments\n property when the function expects them.\n\n\nThe \nmodule\n property is the fully qualified module exposing the function. It\nMUST be a JSON string.\n\n\nThe \nfunc\n property is the name of the function to apply. It MUST be a JSON\nstring.\n\n\nWhen provided, the \narguments\n property MUST be a JSON object which\nproperties are the names of the \nfunction\u2019s arguments\n. When a function\u2019s\nsignature has \ndefault values\n for some of its arguments, those MAY be\nomitted from the \narguments\n object. In that case, those default values will be\nused.\n\n\nArgument values MUST be valid JSON entities.\n\n\nHTTP Provider\n\u00b6\n\n\nA HTTP Provider declares a URL to be called.\n\n\nA HTTP Provider MUST declare the following:\n\n\n\n\na \nurl\n property\n\n\n\n\nThe \nurl\n property MUST be a JSON string representing a URL as per\n\nRFC 3986\n.\n\n\nIn addition, the \nprovider\n object MAY declare any of the followings:\n\n\n\n\na \nmethod\n property\n\n\na \nheaders\n property\n\n\na \nexpected_status\n property\n\n\na \narguments\n property\n\n\na \ntimeout\n property\n\n\n\n\nThe \nmethod\n property MUST be a JSON string, such as \n\"POST\"\n, as per\n\nRFC 2616\n. It defaults to \n\"GET\"\n.\n\n\nThe \nheaders\n property MUST be a JSON object which properties are header names\nand values are header values, as per \nRFC 2616\n.\n\n\nThe \nexpected_status\n property MUST be a JSON number as per \nRFC 2616\n\ndefinining the expected HTTP response status for the Probe or Action to be\nconsidered failed or successful. It defaults to \n200\n.\n\n\nWhen provided, the \narguments\n property MUST be a JSON object which\nproperties are parameters of the HTTP request.\n\n\nWhen \nmethod\n is \n\"GET\"\n, the \narguments\n are mapped as a query-string of the\nURL. Otherwise, the \narguments\n are passed as the request body\u2019s data and the\nencoding depends on the \n\"Content-Type\"\n provided in the \nheaders\n object.\n\n\nThe \ntimeout\n property MUST be a JSON number specifying how long the request\nshould take to complete.\n\n\nProcess Provider\n\u00b6\n\n\nA Process Provider declares a process to be called.\n\n\nA Process Provider MUST declare the following:\n\n\n\n\na \npath\n property\n\n\n\n\nThe \npath\n property MUST be a JSON string of a path to an executable.\n\n\nIn addition, the \nprovider\n object MAY declare any of the followings:\n\n\n\n\na \narguments\n property\n\n\na \ntimeout\n property\n\n\n\n\nThe \narguments\n property MUST be a JSON object which defines the process\narguments. The properties are the names and each property\u2019s value is the\nthe argument\u2019s value. An argument that does not expect a value MUST set that\nvalue to the empty string \n\"\"\n.\n\n\nThe \ntimeout\n property MUST be a JSON number specifying how long the process\nshould take to complete.\n\n\nRollbacks\n\u00b6\n\n\nRollbacks declare the sequence of actions that attempt to put the system back\nto its initial state.\n\n\nThe experiment MAY declare a single \nrollbacks\n property which is a JSON array\nconsisting of \nActions\n.\n\n\nA failed rollback MUST not bail the sequence of rollbacks.\n\n\nSecrets\n\u00b6\n\n\nSecrets declare values that need to be passed on to \nActions\n or \n[Probes][probe] in a secure manner.\n\n\nThe \u0300\nsecrets\n property MUST be a JSON object. Its properties are identifiers\nreferenced by \nActions\n and [Probes][probe].\n\n\nThe value of each identifier is a JSON object which properties are the secrets\nkeys and the properties values are the secrets values.\n\n\nReferenced secrets MUST be injected into probes and actions when they are\napplied. Probes and actions MUST NOT modify the secrets.\n\n\nSecrets MUST be passed a mapping of keys and values to probes and actions.\n\n\nAn example of a \nsecrets\n element at the top-level:\n\n\n{\n\n    \n\"secrets\"\n:\n \n{\n\n        \n\"kubernetes\"\n:\n \n{\n\n            \n\"token\"\n:\n \n\"XYZ\"\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nThis can then referenced from probes or actions:\n\n\n{\n\n    \n\"type\"\n:\n \n\"probe\"\n,\n\n    \n\"secrets\"\n:\n \n\"kubernetes\"\n\n\n}\n\n\n\n\n\nInline Secrets\n\u00b6\n\n\nSecrets MAY be inlined in the \nExperiment\n directly.\n\n\nEnvironment Secrets\n\u00b6\n\n\nSecrets MAY be retrieved from the environment. In that case, they must be\ndeclared as a JSON object with a \ntype\n property set to \n\"env\"\n. The\nenvironment variable MUST be declared in the \nkey\n property as a JSON string.\n\n\n{\n\n    \n\"secrets\"\n:\n \n{\n\n        \n\"kubernetes\"\n:\n \n{\n\n            \n\"token\"\n:\n \n{\n\n                \n\"type\"\n:\n \n\"env\"\n,\n\n                \n\"key\"\n:\n \n\"KUBERNETES_TOKEN\"\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nVault Secrets\n\u00b6\n\n\nSecrets MAY be retrieved from a \nHashiCorp vault instance\n. In that case,\nthey must be declared as a JSON object with a \ntype\n property set to \n\"vault\"\n.\nThe path to the key MUST be declared in the \nkey\n property as a JSON\nstring.\n\n\n{\n\n    \n\"secrets\"\n:\n \n{\n\n        \n\"myapp\"\n:\n \n{\n\n            \n\"token\"\n:\n \n{\n\n                \n\"type\"\n:\n \n\"vault\"\n,\n\n                \n\"key\"\n:\n \n\"secrets/something\"\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nConfiguration\n\u00b6\n\n\nConfiguration is meant to provide runtime values to \nactions\n and\n[probes][probe].\n\n\nThe \nconfiguration\n element MUST be a JSON object. The value of each property\nMUST be a JSON string or object which properties are considered the\nconfiguration lookup. Configuration must be passed to all Probes and actions\nrequring it. Probes and actions MUST NOT modify the configuration.\n\n\nConfigurations MUST be passed a mapping of keys and values to probes and\nactions.\n\n\nAn example of a \nconfiguration\n element at the top-level:\n\n\n{\n\n    \n\"configuration\"\n:\n \n{\n\n        \n\"some_service\"\n:\n \n\"http://127.0.0.1:8080\"\n,\n\n        \n\"vault_addr\"\n:\n \n{\n\n            \n\"type\"\n:\n \n\"env\"\n,\n\n            \n\"key\"\n:\n \n\"VAULT_ADDR\"\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nInline Configurations\n\u00b6\n\n\nConfigurations MAY be inlined in the \nExperiment\n directly.\n\n\nEnvironment Configurations\n\u00b6\n\n\nConfigurations MAY be retrieved from the environment. In that case, they must be\ndeclared as a JSON object with a \ntype\n property set to \n\"env\"\n. The\nenvironment variable MUST be declared in the \nkey\n property as a JSON string.\n\n\n{\n\n    \n\"configuration\"\n:\n \n{\n\n        \n\"vault_address\"\n:\n \n{\n\n            \n\"type\"\n:\n \n\"env\"\n,\n\n            \n\"key\"\n:\n \n\"VAULT_ADDR\"\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nVariable Substitution\n\u00b6\n\n\nProbes and Actions argument values MAY be dynamically resolved at runtime. \n\n\nDynamic values MUST follow the syntax \n${name}\n where \nname\n is an identifier\ndeclared in either the Configuration or Secrets sections. When \nname\n is\ndeclared in both sections, the Configuration section MUST take precedence.\n\n\nDynamic values MUST be substituted before being passed to Probes or Actions.\n\n\nOther values, such as the HTTP Probe url, MAY be sustituted as well.\n\n\nExamples\n\u00b6\n\n\nThe following examples MUST NOT be considered normatives.\n\n\nMinimal Experiment\n\u00b6\n\n\nHere is an example of the most minimal experiment:\n\n\n{\n\n    \n\"version\"\n:\n \n\"0.1.0\"\n,\n\n    \n\"title\"\n:\n \n\"Moving a file from under our feet is forgivable\"\n,\n\n    \n\"description\"\n:\n \n\"Our application should re-create a file that was removed\"\n,\n\n    \n\"steady-state-hypothesis\"\n:\n \n{\n\n        \n\"title\"\n:\n \n\"The file must be around first\"\n,\n\n        \n\"probes\"\n:\n \n[\n\n            \n{\n\n                \n\"type\"\n:\n \n\"python\"\n,\n\n                \n\"name\"\n:\n \n\"file-must-exist\"\n,\n\n                \n\"tolerance\"\n:\n \ntrue\n,\n\n                \n\"provider\"\n:\n \n{\n\n                    \n\"module\"\n:\n \n\"os.path\"\n,\n\n                    \n\"func\"\n:\n \n\"exists\"\n,\n\n                    \n\"arguments\"\n:\n \n{\n\n                        \n\"path\"\n:\n \n\"some/file\"\n\n                    \n}\n\n                \n}\n\n            \n}\n\n        \n]\n\n    \n},\n\n    \n\"method\"\n:\n \n[\n\n        \n{\n\n            \n\"type\"\n:\n \n\"action\"\n,\n\n            \n\"name\"\n:\n \n\"file-be-gone\"\n,\n\n            \n\"provider\"\n:\n \n{\n\n                \n\"module\"\n:\n \n\"os.path\"\n,\n\n                \n\"func\"\n:\n \n\"remove\"\n,\n\n                \n\"arguments\"\n:\n \n{\n\n                    \n\"path\"\n:\n \n\"some/file\"\n\n                \n}\n\n            \n},\n\n            \n\"pauses\"\n:\n \n{\n\n                \n\"after\"\n:\n \n5\n\n            \n}\n\n        \n},\n\n        \n{\n\n            \n\"ref\"\n:\n \n\"file-must-exist\"\n\n        \n}\n\n    \n]\n\n\n}",
            "title": "Experiment"
        },
        {
            "location": "/api/experiment/#an-open-api-for-chaos-engineering-experiments",
            "text": "Info  The current specification has not reached its 1.0.0 stable version yet. Make\nsure to  join the discussion  to provide any feedback you might have.",
            "title": "An Open API for Chaos Engineering Experiments"
        },
        {
            "location": "/api/experiment/#introduction",
            "text": "The purpose of this specification is to formalize the elements of a Chaos\nEngineering experiment and offer a way to federate the community around a\ncommon syntax and semantic.  As a fairly recent field, Chaos Engineering is a dynamic and its foundations\nare still emerging. However, it appears certain concepts are settling down\nenough to start agreeing on a shared understanding.  This specification is not prescriptive and does not aim at forcing the\ncommunity into one direction, rather it strives at providing a common\nvocabulary that new practicionners can easily make sense of.  It is necessary to appreciate that this document does not specify what tools,\nsuch as the Chaos Monkey or similar, should look like. Instead, this document\nspecifies how Chaos Engineering Experiment could be described, shared and\nconducted collaboratively.",
            "title": "Introduction"
        },
        {
            "location": "/api/experiment/#conventions-used-in-this-document",
            "text": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d,\n\u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this\ndocument are to be interpreted as described in  RFC 2119 .  The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d,\n\u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this\ndocument are to be interpreted as defined in  RFC 7159 .",
            "title": "Conventions Used in This Document"
        },
        {
            "location": "/api/experiment/#chaos-engineering-elements",
            "text": "",
            "title": "Chaos Engineering Elements"
        },
        {
            "location": "/api/experiment/#overview",
            "text": "An Experiment is one possible description of the principles of the Chaos Engineering . The intention of such a\ndescription is to provide shared understanding around a hypothesis on how\nto discover system\u2019s behavior under certain conditions.  An  Experiment  declares a steady  state hypothesis , alongside probes  to validate this steady state is met, and a  method  as a\nsequence  actions  and  probes , to interact and query the system\nrespectively.  By using a variety of  probes , experiments should gather information to\nsense behaviors in the system, potentially leading to systemic patterns that can\nbe stabilized.",
            "title": "Overview"
        },
        {
            "location": "/api/experiment/#experiment",
            "text": "A Chaos Engineering experiment, or simply an experiment, describes both the\nelements and the order in which they should be applied.  An experiment is a JSON object.  An experiment MUST declare:   a  version  property  a  title  property  a  description  property  a  steady-state-hypothesis  property  a  method  property   The  version  property MUST be  \"0.1.0\" .  The experiment\u2019s  title  and  description  are meant for humans and therefore\nshould be as descriptive as possible to clarify the experiment\u2019s rationale.  Title and description are JSON strings with no maximum length.  An experiment SHOULD also declare:   a  rollbacks  property   An experiment MAY finally declare:   a  tags  property  a  secrets  property   Tags provide a way of categorizing experiments. It is a sequence of JSON\nstrings.",
            "title": "Experiment"
        },
        {
            "location": "/api/experiment/#steady-state-hypothesis",
            "text": "The Steady State Hypothesis element describes what normal looks like in your\nsystem before the Method element is applied. If the steady state is not met,\nthe Method element is not applied and the experiment MUST bail out.  The Steady State Hypothesis element is a JSON object.  Steady State Hypothesis element MUST declare:   a  title  property  a  probes  property   The  title  is meant for humans and therefore should clarify the rationale for\nthis hypothesis.  Each  Probe  MUST define a  tolerance  property that acting as a gate\nmechanism for the experiment to carry on or bail. Any  Probe  that does not\nfall into the  tolerance  zone MUST fail the experiment.",
            "title": "Steady State Hypothesis"
        },
        {
            "location": "/api/experiment/#steady-state-probe-tolerance",
            "text": "Probes  of the Steady State Hypothesis MUST declare an additional property\nnamed  tolerance .  The  tolerance  property\u2019s value MUST be one of:   a scalar: JSON string, number (an integer), boolean  a sequence of two scalars defining a lower and upper bounds  a Probe object   In the case of a scalar or the sequence, the tolerance validation MUST be\nstrict. The value returned by the  Probe  MUST be checked against the\nscalar value. The experiment MUST bail when both fail to match.  When the  tolerance  is a sequence of two scalars, the returned value from\nthe  Probe  MUST fall within the boundaries they form.  In the case of a  Probe  object, the tolerance validation is left\nundefined as it is controlled by the  Probe  itself. However, it is\nRECOMMENDED that the  tolerance   Probe  acts strictly in order to improve\nthe readability of the experiment\u2019s results.  Some examples of  tolerance  properties.  A boolean tolerance: \"tolerance\" :   true   A integer tolerance: \"tolerance\" :   8   A string tolerance: \"tolerance\" :   \"OK\"   A sequence tolerance: \"tolerance\" :   [ 4 ,   9 ]   A  Probe  tolerance: \"tolerance\" :   { \n     \"type\" :   \"probe\" , \n     \"name\" :   \"should-exist\" , \n     \"provider\" :   { \n         \"type\" :   \"python\" , \n         \"module\" :   \"os.path\" , \n         \"func\" :   \"exists\" , \n         \"arguments\" :   { \n             \"path\" :   \"some/file\" \n         } \n     }  }",
            "title": "Steady State Probe Tolerance"
        },
        {
            "location": "/api/experiment/#method",
            "text": "The Method describes the sequence of  Probe  and  Action  elements\nto apply. The Method is declared under  method  property at the top-level of the\nexperiment.  The  method  MUST have at least one element but this can be either a  Probe \nor an  Action .  The elements MUST be applied in the order they are declared.",
            "title": "Method"
        },
        {
            "location": "/api/experiment/#probe",
            "text": "A Probe collects information from the system during the experiment.  A Probe is a JSON object. A Probe is declared fully or reference another Probe\nthrough the  ref  property.  When declared fully, a Probe MUST declare:   a  type  property  a  name  property  a  provider  property   The  type  property MUST be the JSON string  \"probe\" .   The  name  property is a free-form JSON string that MAY be considered as an\nidentifier withing the experiment.  It MAY also declare:   a  secret  property  a  configuration  property  a  background  property   The  secret  property MUST be a JSON string referencing an identifier declared\nin the top-level  secrets   property . It is assumed that when not\ndeclared, the Probe requires no secrets.  The  configuration  property MUST be a JSON string referencing an identifier\ndeclared in the top-level  configuration   property . It is assumed that\nwhen not declared, the Probe requires no configuration.  The  background  property MUST be a JSON boolean value either  true  or  false .\nIt is assumed that, when that property is not declared, it is set to  false .\nWhen that property is set to  true  it indicates the Probe MUST not block\nand the next Action or Probe should immediatly be applied.  When a Probe references another Probe in the Experiment, the Probe MUST\ndeclare a single property called  ref .  The  ref  property MUST be a JSON string which MUST be the name of a declared\nProbe.",
            "title": "Probe"
        },
        {
            "location": "/api/experiment/#action",
            "text": "An Action performs an operation against the system.  An Action collects information from the system during the experiment.  An Action is a JSON object. An Action is declared fully or reference another\nAction through the  ref  property.  When declared fully, a Action MUST declare:   a  type  property  a  name  property  a  provider  property   The  type  property MUST be the JSON string  \"action\" .   The  name  property is a free-form JSON string that MAY be considered as an\nidentifier withing the experiment.  It MAY also declare:   a  secret  property  a  configuration  property  a  background  property  a  pauses  property   The  secret  property MUST be a JSON string referencing an identifier declared\nin the top-level  secrets   property . It is assumed that when not\ndeclared, the Action requires no secrets.  The  configuration  property MUST be a JSON string referencing an identifier\ndeclared in the top-level  configuration   property . It is assumed that\nwhen not declared, the Action requires no configuration.  The  background  property MUST be a JSON boolean value either  true  or  false .\nIt is assumed that, when that property is not declared, it is set to  false .\nWhen that property is set to  true  it indicates the Action MUST not block\nand the next Action or Probe should immediatly be applied.  The  pauses  property MUST be a JSON object which MAY have one or the two\nfollowing properties:   before  after   In both cases, the value MUST be JSON number indicating the number of seconds to\nwait before continuining. The  before  pause MUST be performed before the Action\nwhile the  after  MUST be performed afterwards.  When a Action references another Action in the Experiment, the Action MUST\ndeclare a single property called  ref .  The  ref  property MUST be a JSON string which MUST be the name of a declared\nAction.",
            "title": "Action"
        },
        {
            "location": "/api/experiment/#action-or-probe-provider",
            "text": "A provider MUST be a JSON object which MUST declare a  type  property that\ndecides the other expected properties.  The  type  property MUST be one of  \"python\" ,  \"http\"  or  \"process\" .",
            "title": "Action or Probe Provider"
        },
        {
            "location": "/api/experiment/#python-provider",
            "text": "A Python Provider declares a Python function to be applied.  A Python Provider MUST declare the following:   a  module  property  a  func  property   It SHOULD also declare an  arguments  property when the function expects them.  The  module  property is the fully qualified module exposing the function. It\nMUST be a JSON string.  The  func  property is the name of the function to apply. It MUST be a JSON\nstring.  When provided, the  arguments  property MUST be a JSON object which\nproperties are the names of the  function\u2019s arguments . When a function\u2019s\nsignature has  default values  for some of its arguments, those MAY be\nomitted from the  arguments  object. In that case, those default values will be\nused.  Argument values MUST be valid JSON entities.",
            "title": "Python Provider"
        },
        {
            "location": "/api/experiment/#http-provider",
            "text": "A HTTP Provider declares a URL to be called.  A HTTP Provider MUST declare the following:   a  url  property   The  url  property MUST be a JSON string representing a URL as per RFC 3986 .  In addition, the  provider  object MAY declare any of the followings:   a  method  property  a  headers  property  a  expected_status  property  a  arguments  property  a  timeout  property   The  method  property MUST be a JSON string, such as  \"POST\" , as per RFC 2616 . It defaults to  \"GET\" .  The  headers  property MUST be a JSON object which properties are header names\nand values are header values, as per  RFC 2616 .  The  expected_status  property MUST be a JSON number as per  RFC 2616 \ndefinining the expected HTTP response status for the Probe or Action to be\nconsidered failed or successful. It defaults to  200 .  When provided, the  arguments  property MUST be a JSON object which\nproperties are parameters of the HTTP request.  When  method  is  \"GET\" , the  arguments  are mapped as a query-string of the\nURL. Otherwise, the  arguments  are passed as the request body\u2019s data and the\nencoding depends on the  \"Content-Type\"  provided in the  headers  object.  The  timeout  property MUST be a JSON number specifying how long the request\nshould take to complete.",
            "title": "HTTP Provider"
        },
        {
            "location": "/api/experiment/#process-provider",
            "text": "A Process Provider declares a process to be called.  A Process Provider MUST declare the following:   a  path  property   The  path  property MUST be a JSON string of a path to an executable.  In addition, the  provider  object MAY declare any of the followings:   a  arguments  property  a  timeout  property   The  arguments  property MUST be a JSON object which defines the process\narguments. The properties are the names and each property\u2019s value is the\nthe argument\u2019s value. An argument that does not expect a value MUST set that\nvalue to the empty string  \"\" .  The  timeout  property MUST be a JSON number specifying how long the process\nshould take to complete.",
            "title": "Process Provider"
        },
        {
            "location": "/api/experiment/#rollbacks",
            "text": "Rollbacks declare the sequence of actions that attempt to put the system back\nto its initial state.  The experiment MAY declare a single  rollbacks  property which is a JSON array\nconsisting of  Actions .  A failed rollback MUST not bail the sequence of rollbacks.",
            "title": "Rollbacks"
        },
        {
            "location": "/api/experiment/#secrets",
            "text": "Secrets declare values that need to be passed on to  Actions  or \n[Probes][probe] in a secure manner.  The \u0300 secrets  property MUST be a JSON object. Its properties are identifiers\nreferenced by  Actions  and [Probes][probe].  The value of each identifier is a JSON object which properties are the secrets\nkeys and the properties values are the secrets values.  Referenced secrets MUST be injected into probes and actions when they are\napplied. Probes and actions MUST NOT modify the secrets.  Secrets MUST be passed a mapping of keys and values to probes and actions.  An example of a  secrets  element at the top-level:  { \n     \"secrets\" :   { \n         \"kubernetes\" :   { \n             \"token\" :   \"XYZ\" \n         } \n     }  }   This can then referenced from probes or actions:  { \n     \"type\" :   \"probe\" , \n     \"secrets\" :   \"kubernetes\"  }",
            "title": "Secrets"
        },
        {
            "location": "/api/experiment/#inline-secrets",
            "text": "Secrets MAY be inlined in the  Experiment  directly.",
            "title": "Inline Secrets"
        },
        {
            "location": "/api/experiment/#environment-secrets",
            "text": "Secrets MAY be retrieved from the environment. In that case, they must be\ndeclared as a JSON object with a  type  property set to  \"env\" . The\nenvironment variable MUST be declared in the  key  property as a JSON string.  { \n     \"secrets\" :   { \n         \"kubernetes\" :   { \n             \"token\" :   { \n                 \"type\" :   \"env\" , \n                 \"key\" :   \"KUBERNETES_TOKEN\" \n             } \n         } \n     }  }",
            "title": "Environment Secrets"
        },
        {
            "location": "/api/experiment/#vault-secrets",
            "text": "Secrets MAY be retrieved from a  HashiCorp vault instance . In that case,\nthey must be declared as a JSON object with a  type  property set to  \"vault\" .\nThe path to the key MUST be declared in the  key  property as a JSON\nstring.  { \n     \"secrets\" :   { \n         \"myapp\" :   { \n             \"token\" :   { \n                 \"type\" :   \"vault\" , \n                 \"key\" :   \"secrets/something\" \n             } \n         } \n     }  }",
            "title": "Vault Secrets"
        },
        {
            "location": "/api/experiment/#configuration",
            "text": "Configuration is meant to provide runtime values to  actions  and\n[probes][probe].  The  configuration  element MUST be a JSON object. The value of each property\nMUST be a JSON string or object which properties are considered the\nconfiguration lookup. Configuration must be passed to all Probes and actions\nrequring it. Probes and actions MUST NOT modify the configuration.  Configurations MUST be passed a mapping of keys and values to probes and\nactions.  An example of a  configuration  element at the top-level:  { \n     \"configuration\" :   { \n         \"some_service\" :   \"http://127.0.0.1:8080\" , \n         \"vault_addr\" :   { \n             \"type\" :   \"env\" , \n             \"key\" :   \"VAULT_ADDR\" \n         } \n     }  }",
            "title": "Configuration"
        },
        {
            "location": "/api/experiment/#inline-configurations",
            "text": "Configurations MAY be inlined in the  Experiment  directly.",
            "title": "Inline Configurations"
        },
        {
            "location": "/api/experiment/#environment-configurations",
            "text": "Configurations MAY be retrieved from the environment. In that case, they must be\ndeclared as a JSON object with a  type  property set to  \"env\" . The\nenvironment variable MUST be declared in the  key  property as a JSON string.  { \n     \"configuration\" :   { \n         \"vault_address\" :   { \n             \"type\" :   \"env\" , \n             \"key\" :   \"VAULT_ADDR\" \n         } \n     }  }",
            "title": "Environment Configurations"
        },
        {
            "location": "/api/experiment/#variable-substitution",
            "text": "Probes and Actions argument values MAY be dynamically resolved at runtime.   Dynamic values MUST follow the syntax  ${name}  where  name  is an identifier\ndeclared in either the Configuration or Secrets sections. When  name  is\ndeclared in both sections, the Configuration section MUST take precedence.  Dynamic values MUST be substituted before being passed to Probes or Actions.  Other values, such as the HTTP Probe url, MAY be sustituted as well.",
            "title": "Variable Substitution"
        },
        {
            "location": "/api/experiment/#examples",
            "text": "The following examples MUST NOT be considered normatives.",
            "title": "Examples"
        },
        {
            "location": "/api/experiment/#minimal-experiment",
            "text": "Here is an example of the most minimal experiment:  { \n     \"version\" :   \"0.1.0\" , \n     \"title\" :   \"Moving a file from under our feet is forgivable\" , \n     \"description\" :   \"Our application should re-create a file that was removed\" , \n     \"steady-state-hypothesis\" :   { \n         \"title\" :   \"The file must be around first\" , \n         \"probes\" :   [ \n             { \n                 \"type\" :   \"python\" , \n                 \"name\" :   \"file-must-exist\" , \n                 \"tolerance\" :   true , \n                 \"provider\" :   { \n                     \"module\" :   \"os.path\" , \n                     \"func\" :   \"exists\" , \n                     \"arguments\" :   { \n                         \"path\" :   \"some/file\" \n                     } \n                 } \n             } \n         ] \n     }, \n     \"method\" :   [ \n         { \n             \"type\" :   \"action\" , \n             \"name\" :   \"file-be-gone\" , \n             \"provider\" :   { \n                 \"module\" :   \"os.path\" , \n                 \"func\" :   \"remove\" , \n                 \"arguments\" :   { \n                     \"path\" :   \"some/file\" \n                 } \n             }, \n             \"pauses\" :   { \n                 \"after\" :   5 \n             } \n         }, \n         { \n             \"ref\" :   \"file-must-exist\" \n         } \n     ]  }",
            "title": "Minimal Experiment"
        },
        {
            "location": "/api/journal/",
            "text": "Experiment Journal\n\u00b6\n\n\nThe Journal API defines the output of an Experiment. This is by and large\nstill a work in progress.",
            "title": "Journal"
        },
        {
            "location": "/api/journal/#experiment-journal",
            "text": "The Journal API defines the output of an Experiment. This is by and large\nstill a work in progress.",
            "title": "Experiment Journal"
        }
    ]
}